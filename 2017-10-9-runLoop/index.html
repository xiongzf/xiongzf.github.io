<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ios深入学习 - runloop | KNOWLEDGE IS POWER</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="RunLoop" />
  
  
  
  
  <meta name="description" content="RunLoop概念：原文作者Blog地址点这里。一般来讲一个线程只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时执行任务但不退出，代码逻辑通常如下：runloop处理事件的代码逻辑模拟（Event Loop） 1234567function loop() &amp;#123;    initialize();    do &amp;#123;        var message =">
<meta name="keywords" content="RunLoop">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS深入学习 - RunLoop">
<meta property="og:url" content="http://yoursite.com/2017-10-9-runLoop/index.html">
<meta property="og:site_name" content="KNOWLEDGE IS POWER">
<meta property="og:description" content="RunLoop概念：原文作者Blog地址点这里。一般来讲一个线程只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时执行任务但不退出，代码逻辑通常如下：runloop处理事件的代码逻辑模拟（Event Loop） 1234567function loop() &amp;#123;    initialize();    do &amp;#123;        var message =">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2017-10-9-runLoop/17.jpg">
<meta property="og:image" content="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png">
<meta property="og:image" content="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png">
<meta property="og:image" content="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_3.png">
<meta property="og:image" content="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_4.png">
<meta property="og:image" content="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_5.png">
<meta property="og:image" content="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png">
<meta property="og:updated_time" content="2019-07-24T04:02:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS深入学习 - RunLoop">
<meta name="twitter:description" content="RunLoop概念：原文作者Blog地址点这里。一般来讲一个线程只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时执行任务但不退出，代码逻辑通常如下：runloop处理事件的代码逻辑模拟（Event Loop） 1234567function loop() &amp;#123;    initialize();    do &amp;#123;        var message =">
<meta name="twitter:image" content="http://yoursite.com/2017-10-9-runLoop/17.jpg">
  
    <link rel="alternate" href="/atom.xml" title="KNOWLEDGE IS POWER" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-2017-10-9-runLoop" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      iOS深入学习 - RunLoop
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017-10-9-runLoop/" class="article-date">
	  <time datetime="2017-10-08T16:00:00.000Z" itemprop="datePublished">2017-10-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/iOS-深入学习/">iOS 深入学习</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/2017-10-9-runLoop/17.jpg" alt=""></p>
<h2 id="RunLoop概念："><a href="#RunLoop概念：" class="headerlink" title="RunLoop概念："></a>RunLoop概念：</h2><p><a href="https://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="noopener">原文作者Blog地址</a>点这里。<br>一般来讲一个线程只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时执行任务但不退出，代码逻辑通常如下：runloop处理事件的代码逻辑模拟（Event Loop）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_messsage();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; while (message != quite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：<br>实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立即被唤醒</strong></p>
<p>1、OSX/iOS系统中提供了两个对象：NSRunLoop、CFRunLoopRef。<br><strong>CFRunLoopRef</strong>是在<strong>CoreFoundation</strong>框架内的，它提供了纯C函数的API，所有这些API都是线程安全的。<br><strong>NSRunLoop</strong>是基于<strong>CFRunLoopRef</strong>封装的，提供了面向对象的API，但是这些API不是线程安全的。</p>
<p><a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CFRunLoopRef源码</a></p>
<p>跨平台的<a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CoreFoundation版本源码</a></p>
<h2 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h2><p>iOS开发中可能遇到两个线程对象：<strong>pthread_t</strong>和<strong>NSThread</strong>。过去苹果有份<a href="https://www.fenestrated.net/mac/mirrors/Apple%20Technotes%20(As%20of%202002" target="_blank" rel="noopener">文档</a>/tn/tn2028.html)标明了<strong>NSThread</strong>只是<strong>pthread_t</strong>的封装，但是那份文档已经失效了，现在它们也有可能都是直接包装自最底层的<strong>mach thread</strong>。苹果没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是<strong>pthread_t</strong>和<strong>NSThread</strong>是一一对应的。比如，可以通过<strong>pthread_main_thread_np()</strong>或者<strong>[NSThread mainThread]</strong>来获取主线程；也可以通过<strong>pthread_self()</strong>或者<strong>[NSThread currentThread]</strong>来获取当前线程。<strong>CFRunLoop</strong>基于<strong>pthread</strong>来管理的。</p>
<p>苹果不允许直接创建RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//全局的Dictionary，key是pthread_t, value是CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">//访问loopsDic时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line">//获取一个pthread对应的Runloop</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        //第一次进入时，初始化全局Dic，并先为主线程创建一个RunLoop。</span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ///直接从Dictionary里获取</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread);</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        ///取不到，创建一个</span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        ///注册一个回调，当线程销毁时，顺便也销毁对应的RunLoop</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSPinLockUnlock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary里。线程刚创建时并没有RunLoop，如果你不主动获取，拿它一直不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁是发生在线程结束时。你只能在一个线程的内部获取其RunLoop（主线程除外）</p>
<h2 id="RunLoop对外的接口"><a href="#RunLoop对外的接口" class="headerlink" title="RunLoop对外的接口"></a>RunLoop对外的接口</h2><p>在CoreFoundation里面关于RunLoop有5个类：</p>
<ol>
<li>CFRunLoopRef </li>
<li>CFRunLoopModeRef </li>
<li>CFRunLoopSourceRef </li>
<li>CFRunLoopTimerRef </li>
<li>CFRunLoopObserverRef</li>
</ol>
<p>其中<strong>CFRunLoopModeRef</strong>类并没有对外暴露，只是通过<strong>CFRunLoopRef</strong>的接口进行了封装。他们的关系如下：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt=""></p>
<p>一个RunLoop包含若干个Mode，每个Mode又包含若干个<strong>Source/Timer/Observer</strong>。每次调用<strong>RunLoop</strong>的<strong>主函数</strong>时，只能指定其中一个<strong>Mode</strong>，这个<strong>Mode</strong>被称作<strong>CurrentMode</strong>。如果需要切换<strong>Mode</strong>，只能退出<strong>Loop</strong>，再重新指定一个<strong>Mode</strong>进入。这样做主要是为了分隔开不同组的<strong>Source/Timer/Observer</strong>，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef</strong>是事件产生的地方。Source有两个版本：Source0和Source1.</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用<br>CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件。</li>
<li>Source1包含了一个mach_port和一个回调（函数指针），被用于通过内核和其它线程互相发送消息。这种Source能主动唤醒RunLoop的线程，其原理下面会讲到。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong>是基于时间的触发器， 它和NSTimer是toll_free bridged（对象桥接）的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒已执行那个回调。</p>
<p><strong>CFRunLoopObserverRef</strong>是观察者，每个Observer都包含了一个回调（函数指针），当RunLoop的状态发生变化的时候，观察者就能通过回调接受这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry                = (1UL &lt;&lt; 0), //即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers         = (1UL &lt;&lt; 1), //即将处理Timer</span><br><span class="line">    kCFRunLoopBeforeSources        = (1UL &lt;&lt; 2), //即将处理Source</span><br><span class="line">    kCFRunLoopBeforeWaiting        = (1UL &lt;&lt; 5), //即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting         = (1UL &lt;&lt; 6), //刚冲休眠中唤醒</span><br><span class="line">    kCFRunLoopExit                 = (1UL &lt;&lt; 7), //即将退出Loop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<strong>Source/Timer/Observer</strong>被统称为mode item， 一个item可以被同时加入多个mode。但是一个item被重复加入同一个mode时是不会有效果的。如果一个mode中一个item都没有，则RunLoop会直接退出，不会进入循环。</p>
<h2 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a>RunLoop的Mode</h2><p>CFRunLoopMode和CFRunLoop的结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;                // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _source0;</span><br><span class="line">    CFMutableSetRef _source1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;  // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;     // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个概念叫<strong>“CommonModes”</strong>：一个Mode可以将自己标为<strong>“Common”</strong>属性（通过将其<strong>ModeName</strong>添加到RunLoop的<strong>“commonModes”</strong>中）。每当RunLoop的内容发生变化时，RunLoop都会自动将<strong>_commonModeItems</strong>里的<strong>Source/Timer/Observer</strong>同步到具有<strong>“Common”</strong>标记的所有Mode里。</p>
<p>应用场景举例：主线程的RunLoop里有两个预置的Mode：<strong>kCFRunLoopDefaultMode</strong>和<strong>UITrackingRunLoopMode</strong>。这两个Mode都已经被标记为<strong>“Common”</strong>属性。<strong>DefaultMode</strong>是APP平时所处的状态，<strong>TrackingRunLoopMode</strong>是追踪ScrollView滑动时的状态。当你创建一个Timer并追加到<strong>DefaultModel</strong>时，Timer会得到重复回调，但此时滑动一个TableView时，RunLoop会将mode切换为<strong>TrackingRunLoopMode</strong>，这时Timer就不会被调用，并且也不会影响滑动操作。</p>
<p>有时你需要一个Timer，在两个Mode中都能得到回调，一种办法就是将这个Timer分别加入这两个Mode。还有一种方式，就是将Timer加入到顶层的RunLoop的<strong>”commonModeItems“</strong>中。<strong>”commonModeItems“</strong>被RunLoop自动更新到所有具有<strong>“Common”</strong>属性的Mode里去。</p>
<ul>
<li>CFRunLoop对外暴露的管理Mode接口只有下面2个：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>
<ul>
<li>Mode暴露的管理mode item 的接口有下面几个：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef r1, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef r1, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef r1, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef r1, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef r1, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef r1, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure>
<p>你只能通过modeName来操作内部的mode，当你传入一个新的mode name但RunLoop内部没有对应的mode时，RunLoop会自动帮你创建对应的CFRunLoopModeRef。对于一个RunLoop来说，其内部的mode只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：<strong>kCFRunLoopDefaultMode (NSDefaultRunLoopMode)</strong> 和 <strong>UITrackingRunLoopMode</strong>，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：<strong>kCFRunLoopCommonModes (NSRunLoopCommonModes)</strong>，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="RunLoop的内部逻辑"><a href="#RunLoop的内部逻辑" class="headerlink" title="RunLoop的内部逻辑"></a>RunLoop的内部逻辑</h2><p>根据苹果<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">文档</a>里的说明，RunLoop内部逻辑大致如下：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png" alt=""><br>其内部代码整理如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">///用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), KCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///用指定的Mode启动， 允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopInMode(CFString modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    //首先根据modeName找到对应的mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    //如果mode里没有Source/Timer/Observer，直接返回</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">    </span><br><span class="line">    //1、通知Observer：RunLoop即将进入loop</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    //内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            //2、通知Observers：RunLoop即将触发Timer回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            //3、通知Observers：RunLoop即将触发Source0（非port）回调</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            //执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            //4、RunLoop触发Source0(非port)回调</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            //执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            //5、如果有Source1(基于port)处于ready状态，直接处理这个Source1然后跳转去处理消息</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatch, &amp;msg);</span><br><span class="line">                if (hasMsg) &#123;</span><br><span class="line">                    goto handle_msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //6、通知Observers： RunLoop的线程即将进入休眠(sleep)</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //7、调用mach_msg等待接受mach_port的消息。线程即将进入休眠，直接被下面某一个事件唤醒</span><br><span class="line">            //一个基于port的Source事件</span><br><span class="line">            //一个Timer到时间了</span><br><span class="line">            //RunLoop自身超时时间到了</span><br><span class="line">            //被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buff), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); //线程等待接收消息</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //8、通知Observers： RunLoop的线程刚刚被唤醒</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            //收到消息，处理消息</span><br><span class="line">            handle_msg:</span><br><span class="line">            </span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                //9.1 如果一个timer时间到了，触发这个timer的回调</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time());</span><br><span class="line">            &#125; else if（msg_is_dispatch）&#123;</span><br><span class="line">                //9.2 如果有dispatch到main_queue的block， 执行block</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //9.3 如果一个Source1(基于port)发出事件了，处理这个事件</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopSource1(runloop, current, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //执行加入到Loop的Block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                //进入loop时参数说处理完事件就返回</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                //超出传入参数标记的超市时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimeOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                //被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__kCFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //如果没超时， mode里没空，loop没有被停止， 那继续loop</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //10、通知Observers： RunLoop即将退出</span><br><span class="line">    __CFRunLoopDoObservers(r1, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上RunLoop就是这样一个函数，其内部是一个do-while循环。当你调用CFRunLoopRun()时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h2 id="RunLoop的底层实现"><a href="#RunLoop的底层实现" class="headerlink" title="RunLoop的底层实现"></a>RunLoop的底层实现</h2><p>从上面代码可以看到，RunLoop的核心是基于mach port的，其进入休眠时调用的函数是mach_msg()。为了解释这个逻辑，下面稍微介绍一下OSX/iOS的系统架构。<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_3.png" alt=""><br>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包含用户能接触到的图形应用，例如：Spotlight、Aqua、SpringBoard等。<br>应用框架层即开发人员接触到的Cocoa等框架。<br>核心框架层包含各种核心框架、OpenGL等内容。<br>Darwin即操作系统的核心，包含系统内核、驱动、Shell等内容，这一层是开源的，其所有源码都可以在<a href="opensource.apple.com">opensource.apple.com</a>里找到。</p>
<p>我们在深入看一下Darwin这个核心的架构：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_4.png" alt=""></p>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit（还包括一些上面没标注的内容），共同组成了XNU内核。</p>
<ul>
<li>XNU内核的内环被称作Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC（进程间通信）等非常少量的基础服务。</li>
<li>BSD层可以看作围绕Mach层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</li>
<li>IOKit层为设备驱动提供了一个面向对象（C++）的一个框架。</li>
</ul>
<p>Mach 本身提供的API非常有限，而且苹果也不鼓励使用Mach的API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在Mach中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为“对象”。和其他架构不同，Mach的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。“消息”是Mach中最基础的概念，消息在两个端口（port）之间传递，这就是Mach的IPC（进程通信）的核心。</p>
<p>Mach的消息定义是在&lt;mach/message.h&gt;头文件中，很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    mach_msg_header_t header;</span><br><span class="line">    mach_msg_body_t body;</span><br><span class="line">&#125; mach_msg_base_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    mach_msg_bits_t msgh_bits;</span><br><span class="line">    mach_msg_size_t msgh_size;</span><br><span class="line">    mach_port_t msgh_remote_port;</span><br><span class="line">    mach_port_t msgh_local_port;</span><br><span class="line">    mach_port_name_t msgh_voucher_port;</span><br><span class="line">    mach_msg_id_t msgh_id;</span><br><span class="line">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure>
<p>一条Mach消息实际上就是一个二进制数据包（BLOB），其头部定义了当前端口local_port和目标端口remote_port，发送和接收消息是通过同一个API进行的，其option标记了消息传递的方向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mach_msg_return_t mach_msg(</span><br><span class="line">    mach_msg_header_t *msg,</span><br><span class="line">    mach_msg_option_t *option,</span><br><span class="line">    mach_msg_size_t send_size,</span><br><span class="line">    mach_msg_size_t rcv_size,</span><br><span class="line">    mach_port_name_t rcv_name,</span><br><span class="line">    mach_msg_timeout_t timeout,</span><br><span class="line">    mach_port_name_t notify);</span><br></pre></td></tr></table></figure>
<p>为了实现消息的发送和接收，<strong>mach_msg()</strong> 函数实际上是调用一个Mach陷阱（trap），即函数 <strong>mach_msg_trap()</strong>,陷阱这个概念在Mach中等同于系统调用。当你在用户态调用<strong>mach_msg_trap()</strong>会触发陷阱机制，切换到内核态；内核态中内核实现的<strong>mach_msg()</strong>函数会完成实际的工作，如下图：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_5.png" alt=""><br>这些概念可以参考维基百科：<a href="http://en.wikipedia.org/wiki/System_call" target="_blank" rel="noopener">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing" target="_blank" rel="noopener">Trap_(computing)</a>)。</p>
<p><strong>RunLoop</strong> 的核心就是一个 <strong>mach_msg()</strong> (见上面代码的第7步)，<strong>RunLoop</strong>调用这个函数去接收消息， 如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个iOS的App，然后App静止时点击暂停，你会看到主线程调用栈是停留在mach_msg_trap() 这个地方。</p>
<p>关于具体的如何利用mach_port 发送消息，可以看看<a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="noopener">NSHipster这一篇文章</a>，或者<a href="http://segmentfault.com/a/1190000002400329" target="_blank" rel="noopener">这里</a>的中文翻译。</p>
<p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/" target="_blank" rel="noopener">Mac OS X 背后的故事（三） Mach 之父 Avie Tevanian</a>。</p>
<h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    common mode items = &#123;</span><br><span class="line">        //source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;</span><br><span class="line">            order = -1, &#123;</span><br><span class="line">                callout = _UIApplicationHandleEventQueue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRunLoopSource &#123;</span><br><span class="line">            order = -1, &#123;</span><br><span class="line">                callout = PurpleEventSignalCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRunLoopSource &#123;</span><br><span class="line">            order = 0, &#123;</span><br><span class="line">                callout = FBSSerialQueueRunLoopSourceHandler</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">            callout = PurpleEventCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;</span><br><span class="line">            port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // Observer</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = -2147483647, </span><br><span class="line">            activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = 0, </span><br><span class="line">            activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = 1999000, </span><br><span class="line">            activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = 2000000,</span><br><span class="line">            activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = 2147483647, </span><br><span class="line">            activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;</span><br><span class="line">            firing = No, </span><br><span class="line">            interval = 3.1536e+09, </span><br><span class="line">            tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;</span><br><span class="line">                    order = 0, &#123;</span><br><span class="line">                        callout = FBSSerialQueueRunLoopSourceHandler</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;</span><br><span class="line">                    activities = 0xa0, </span><br><span class="line">                    order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;</span><br><span class="line">                    order = -1, &#123;</span><br><span class="line">                        callout = PurpleEventSignalCallback</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;</span><br><span class="line">                    order = -1, &#123;</span><br><span class="line">                        callout = PurpleEventCallback</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到系统默认注册了5个Mode：</p>
<ol>
<li>kCFRunLoopDefaultMode: App的默认Mode，通常主线程是在这个Mode下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪Mode，用于scrollView追踪触摸滑动，保证界面滑动时不受其他mode影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动App时进入的第一个Mode，启动完成后就不在使用。</li>
<li>GSEventReceiveRunLoopMode: 接收系统事件的内部Mode，通常用不到</li>
<li>kCFRunLoopCommonModes: 这是一个占位的Mode，没有实际作用</li>
</ol>
<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="noopener">这里</a>看到更多的苹果内部的Mode，但那些Mode在开发中就很难遇到了。</p>
<p>当RunLoop进行回调时，一般都是通过一个很长的函数调用出去（call out），当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈上看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ///1、通知Observer，即将进入runloop</span><br><span class="line">    ///此处有Observer会创建AutoreleasePool：_objc_autoreleasePoolPush();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry)</span><br><span class="line">    do &#123;</span><br><span class="line">        ///2、通知Observers：即将触发timer回调</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNTION__(kCFRunLoopBeforeTimers)</span><br><span class="line">        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        /// 4. 触发 Source0 (非基于port的) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        /// 5. 通知Observers，即将进入休眠</span><br><span class="line">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line"> </span><br><span class="line">        /// 6. sleep to wait msg.</span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">    </span><br><span class="line">        /// 7. 通知Observers，线程被唤醒</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line"> </span><br><span class="line">        /// 8.1 如果是被Timer唤醒的，回调Timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line"> </span><br><span class="line">        /// 8.2 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        /// 8.3 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line">    &#125; while (...);</span><br><span class="line">    /// 9. 通知Observers，即将退出RunLoop</span><br><span class="line">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>App启动后，苹果会在主线程RunLoop里注册两个 Observer，其回调都是<strong>_wrapRunLoopWithAutoreleasePoolHandler()</strong>。</p>
<p>第一个Observer监视的事件是Entry(即将进入RunLoop)，其回调内会调用<strong>_objc_autoreleasePoolPush()</strong> 创建自动释放池。其order是-2147483647，优先级最高，保证创建释放池发生在其它所有回调之前。</p>
<p>第二个Observer监视了两个事件：BeforeWaiting（准备进入休眠）时调用<strong>_objc_autoreleasePoolPop()</strong> 和 <strong>_objc_autoreleasePoolPush()</strong>释放旧的池并创建新池；Exit(即将退出Loop)时调用<strong>_objc_autoreleasePoolPop()</strong>来释放自动释放池。这个Observer的Order是2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建Pool了。</p>
<h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><p>苹果注册了一个Source1（基于mach port的）用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallBack()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由IOKit.framework生成一个IOHIDEvent事件并由SpringBoard接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="noopener">这里</a>。<strong>SpringBoard</strong>只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种Event，随后用<strong>mach port</strong>转发给需要的App进程。随后苹果注册的那个Source1就会触发回调，并调用<strong>_UIApplicationHandleEventQueue()</strong>进行应用内部的分发。</p>
<p><strong>_UIApplicationHandleEventQueue()</strong>会把<strong>IOHIDEvent</strong>处理并包装成UIEvent进行处理或分发，其中包括识别<strong>UIGesture/处理屏幕旋转/发送给UIWindow</strong>等。通常事件比如 <strong>UIButton点击、touchesBegin/Move/End/Cancel</strong> 事件都是在这个回调中完成的。</p>
<h2 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h2><p>当上面的 <strong>_UIApplicationHandleEventQueue()</strong> 识别了一个手势时，其首先会调用Cancel将当前的 <strong>touchesBegin/Move/End</strong> 系列回调打断。随后系统将对应的 <strong>UIGestureRecognizer</strong> 标记为待处理。</p>
<p>苹果注册了一个<strong>Observer</strong>监测<strong>BeforeWaiting</strong>(Loop即将进入休眠)事件，这个<strong>Observer</strong>的回调函数是 <strong>_UIGestureRecognizerUpdateObserver()</strong>, 其内部会获取所有刚被标记为待处理的 <strong>GestureRecognizer</strong>，并执行<strong>GestureRecognizer</strong>的回调。</p>
<p>当有 <strong>UIGestureRecognizer</strong> 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h2 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h2><p>当在操作UI时，比如改变了Frame、更新了UIView/CALayer的层次时，或者手动调用了 <strong>UIView/CALayer</strong> 的 <strong>setNeedsLayout/setNeedsDisplay</strong> 方法后，这个 <strong>UIView/CALayer</strong> 方法后，这个 <strong>UIView/CALayer</strong> 就被标记为待处理，并提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit(即将退出Loop) 事件，回调去执行一个很长的函数：<strong>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</strong>。这个函数里会遍历所有待处理的 <strong>UIView/CALayer</strong> 以执行实际的绘制和调整，并更新UI界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>NSTimer 其实就是CFRunLoopTimerRef，他们之间是 toll-free bridged的。一个NSTimer注册到RunLoop后，RunLoop会为其重复的时间点注册好事件。例如 10:00,10:10,10:20这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer有个属性叫做Tolerance(宽容度), 标记了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果10:10时我忙着玩手机错过了那个点的公交车，那我只能等10:20这一趟了。</p>
<p>CADisplayLink是一个和屏幕刷新率一致的定时器(但实际实现原理更复杂，和NSTimer并不一样，其内部实际是操作了一个Source)。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去 (和NSTimer相似)，造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook开源的AsyncDisplayLink就是为了解决界面卡顿的问题，其内部也用到了RunLoop。</p>
<h2 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h2><p>当调用 NSObject 的 performSelecter:afterDelay:后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop中。所以如果当前线程没有RunLoop，则这个方法会失效。</p>
<p>当调用performSelector:onThread:时，实际上其会创建一个Timer加到对应的线程去，同样的，如果对应线程没有RunLoop该方法也会失效。</p>
<h2 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h2><p>实际上RunLoop底层也会用到GCD的东西，（NSTimer是用了XNU内核的mk_timer, 而非GCD驱动的）GCD提供的某些接口也用到了RunLoop，例如dispatch_async()。</p>
<p>当调用dispatch_async(dispatch_get_main_queue(), block)时，libDispatch会向主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中取的这个block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个block。但这个逻辑仅限于dispatch到主线程，dispatch到其他线程仍然是由libDispatch处理的。</p>
<h2 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h2><p>iOS中，关于网络请求的接口自下至上有如下几层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork        -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection  -&gt;AFNetworking</span><br><span class="line">NSURLSession     -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>CFSocket</strong> 是最底层的接口，只负责<strong>socket</strong>通信。</li>
<li><strong>CFNetwork</strong> 是基于<strong>CFSocket</strong>等接口的上层封装，<strong>ASIHttpRequest</strong>工作于这一层。</li>
<li><strong>NSURLConnection</strong> 是基于<strong>CFNetwork</strong>的更高层的封装，提供面向对象的接口，<strong>AFNetworking</strong>工作于这一层。</li>
<li><strong>NSURLSession</strong>是<strong>iOS7</strong>中新增的借口，表面上是和<strong>NSURLConnection</strong>并列的，但底层仍然用到了<strong>NSURLConnection</strong>的部分功能(比如<strong>com.apple.NEURLConnectionLoader</strong>线程)，<strong>AFNetworking2</strong>和<strong>Alamofire</strong>工作于这一层。</li>
</ul>
<p>下面主要介绍下NSURLConnnection的工作过程。</p>
<p>通常使用<strong>NSURLConnection</strong>时，你会传入一个<strong>Delegate</strong>，当调用了<strong>[connection start]</strong>后，这个<strong>Delegate</strong>就会不停收到事件回调。实际上，start这个函数的内部会获取<strong>CurrentRunLoop</strong>，然后在其中的<strong>DefaultMode</strong>添加了4个Source0(即需要手动触发的Source)。<strong>CFMultiplexerSource</strong>是负责各种Delegate回调的，<strong>CFHTTPCookieStorage</strong>是处理各种<strong>Cookie</strong>的。</p>
<p>当开始网络传输时，我们可以看到<strong>NSURLConnection</strong>创建了两个新线程：<strong>com.apple.NSURLConnectionLoader</strong>和<strong>com.apple.CFSocket.private</strong>。其中<strong>CFSocket</strong>线程是处理<strong>底层socket</strong>连接的。<strong>NSURLConnectionLoader</strong>这个线程内部会使用<strong>RunLoop</strong>来接收底层<strong>socket</strong>事件，并通过之前添加的<strong>Source0</strong>通知上层的<strong>Delegate</strong>。<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt=""><br><strong>NSURLConnectionLoader</strong>中的<strong>RunLoop</strong>通过一些基于<strong>mach port</strong>的<strong>Source</strong>接收来自底层<strong>CFSocket</strong>的通知。当收到通知后，其会在合适的时机向<strong>CFMultiplexerSource</strong>等<strong>Source0</strong>发送通知，同时唤醒<strong>Delegate</strong>线程的<strong>RunLoop</strong>来让其处理这些通知。<strong>CFMultiplexerSource</strong>会在<strong>Delegate</strong>线程的<strong>RunLoop</strong>对<strong>Delegate</strong>执行实际的回调。</p>
<h2 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h2><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p><strong>AFURLConnectionOperation</strong> 这个类是基于NSURLConnection构建的，其希望能在后台线程接收Delegate回调。为此AFNetworking单独创建了一个线程，并在这个线程中启动了一个RunLoop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+(void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runloop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runloop addPort:[NSMachPort port] forMode: NSDefaultRunLoopMode];</span><br><span class="line">        [runloop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(NSThread *)networkingRequestThread &#123;</span><br><span class="line">    static NSThread *_networkingRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkingRequestThread = [[NSThread alloc] initWithTarget: self selector: @selector(networkRequestThreadEntryPoint:) object: nil];</span><br><span class="line">        [_networkingRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return _networkingRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop启动前内部必须要有一个<strong>Timer/Observer/Source</strong>，所以<strong>AFNetWorking</strong>在<strong>[runloop run]</strong>之前先创建了一个新的<strong>NSMachPort</strong>添加进去了。通常情况下，调用者需要持有这个<strong>NSMachPort(mach port)</strong>并在外部线程通过这个<strong>port</strong>发送消息到<strong>loop</strong>内；但此处添加<strong>port</strong>只是为了让<strong>RunLoop</strong>不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector: @selector(cancelConnection) onThread: [[self class] networkRequestThread] withObject: nil waitUntilDone: NO modes: [self.runloopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector: @selector(operationDidStart) onThread: [[self class] networkRequestThread] withObject: nil waitUntilDone: NO modes: [self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要这个后台线程执行任务时，<strong>AFNetworking</strong>通过调用<strong>[NSObject performSelector:onThread:…]</strong>将这个任务扔到了后台线程的<strong>RunLoop</strong>中。</p>
<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a href="https://github.com/facebookarchive/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a>是Facebook推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版、绘制、UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子视图的排版等操作。</p>
<p>绘制一般有文本绘制(例如CoreText)、图片绘制(例如预先解压)、元素绘制(Quartz)等操作。UI对象操作通常包括UIView/CALayer等UI对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果(例如TextView创建时可能需要提前计算出文本的大小)。ASDK所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟(例如视图的创建、属性的调整)。</p>
<p>为此，ASDK创建了一个名为ASDisplayNode的对象，并在内部封装了<strong>UIView/CALayer</strong>，它具有和<strong>UIView/CALayer</strong>相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过Node来操作其内部的<strong>UIView/CALayer</strong>，这样就可以将排版和绘制放入了后台线程。但无论怎么操作，这些属性总需要在某个时刻同步到主线程的<strong>UIView/CALayer</strong>去。</p>
<p>ASDK仿照<strong>QuartzCore/UIKit</strong>框架的模式，实现了一套类似的界面更新机制：即在主线程的RunLoop中添加一个Observer，监听了<strong>kCFRunLoopBeforeWaiting</strong>和<strong>kCFRunLoopExit</strong>事件，在收到回调时，遍历所有之前放入到队列的待处理的任务，然后一一执行。</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/xiongzf/img/master/WechatIMG7.jpeg',
  alipayImage: 'https://raw.githubusercontent.com/xiongzf/img/master/WechatIMG9.jpeg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>菜鸟先生</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2017-10-9-runLoop/" target="_blank" title="iOS深入学习 - RunLoop">http://yoursite.com/2017-10-9-runLoop/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8zOTY2MC8xNjE4Nw==">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017-10-19-thread/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          iOS深入学习 - 多线程
        
      </div>
    </a>
  
  
    <a href="/2017-06-20-sum/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">总得停下来思考思考</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop概念："><span class="nav-number">1.</span> <span class="nav-text">RunLoop概念：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop与线程的关系"><span class="nav-number">2.</span> <span class="nav-text">RunLoop与线程的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop对外的接口"><span class="nav-number">3.</span> <span class="nav-text">RunLoop对外的接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop的Mode"><span class="nav-number">4.</span> <span class="nav-text">RunLoop的Mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop的内部逻辑"><span class="nav-number">5.</span> <span class="nav-text">RunLoop的内部逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop的底层实现"><span class="nav-number">6.</span> <span class="nav-text">RunLoop的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#苹果用-RunLoop-实现的功能"><span class="nav-number">7.</span> <span class="nav-text">苹果用 RunLoop 实现的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AutoreleasePool"><span class="nav-number">8.</span> <span class="nav-text">AutoreleasePool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件响应"><span class="nav-number">9.</span> <span class="nav-text">事件响应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手势识别"><span class="nav-number">10.</span> <span class="nav-text">手势识别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#界面更新"><span class="nav-number">11.</span> <span class="nav-text">界面更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时器"><span class="nav-number">12.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PerformSelecter"><span class="nav-number">13.</span> <span class="nav-text">PerformSelecter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于GCD"><span class="nav-number">14.</span> <span class="nav-text">关于GCD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于网络请求"><span class="nav-number">15.</span> <span class="nav-text">关于网络请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-的实际应用举例"><span class="nav-number">16.</span> <span class="nav-text">RunLoop 的实际应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFNetworking"><span class="nav-number">16.1.</span> <span class="nav-text">AFNetworking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncDisplayKit"><span class="nav-number">16.2.</span> <span class="nav-text">AsyncDisplayKit</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2020 KNOWLEDGE IS POWER All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            KNOWLEDGE IS POWER
          </div>
          <div class="panel-body">
            Copyright © 2020 菜鸟先生 All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>