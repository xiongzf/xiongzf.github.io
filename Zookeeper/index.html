<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zookeeper | KNOWLEDGE IS POWER</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="zookeeper" />
  
  
  
  
  <meta name="description" content="Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 ZooKeeper的由来随着大数据时代的到来，人们张口闭口都是 Hadoop、Hbase 与 Spark 等名词，似乎不懂这些都不好意思打招呼。但实际上，Hadoop 技术栈中略显低调的 Zoo">
<meta name="keywords" content="zookeeper">
<meta property="og:type" content="article">
<meta property="og:title" content="Zookeeper">
<meta property="og:url" content="http://yoursite.com/Zookeeper/index.html">
<meta property="og:site_name" content="KNOWLEDGE IS POWER">
<meta property="og:description" content="Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 ZooKeeper的由来随着大数据时代的到来，人们张口闭口都是 Hadoop、Hbase 与 Spark 等名词，似乎不懂这些都不好意思打招呼。但实际上，Hadoop 技术栈中略显低调的 Zoo">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/Zookeeper/1.png">
<meta property="og:image" content="http://yoursite.com/Zookeeper/2.png">
<meta property="og:image" content="http://yoursite.com/Zookeeper/3.png">
<meta property="og:image" content="http://yoursite.com/Zookeeper/4.png">
<meta property="og:image" content="http://yoursite.com/Zookeeper/5.png">
<meta property="og:image" content="http://yoursite.com/Zookeeper/6.png">
<meta property="og:image" content="http://yoursite.com/Zookeeper/7.jpg">
<meta property="og:image" content="http://yoursite.com/Zookeeper/8.png">
<meta property="og:image" content="http://yoursite.com/Zookeeper/9.png">
<meta property="og:image" content="http://yoursite.com/Zookeeper/10.jpg">
<meta property="og:image" content="http://yoursite.com/Zookeeper/11.png">
<meta property="og:image" content="http://yoursite.com/Zookeeper/12.png">
<meta property="og:updated_time" content="2019-07-28T07:44:10.102Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zookeeper">
<meta name="twitter:description" content="Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 ZooKeeper的由来随着大数据时代的到来，人们张口闭口都是 Hadoop、Hbase 与 Spark 等名词，似乎不懂这些都不好意思打招呼。但实际上，Hadoop 技术栈中略显低调的 Zoo">
<meta name="twitter:image" content="http://yoursite.com/Zookeeper/1.png">
  
    <link rel="alternate" href="/atom.xml" title="KNOWLEDGE IS POWER" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Zookeeper" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Zookeeper
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/Zookeeper/" class="article-date">
	  <time datetime="2019-04-11T02:36:02.000Z" itemprop="datePublished">2019-04-11</time>
	</a>

      
    <a class="article-category-link" href="/categories/java/">java</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/Zookeeper/1.png" alt=""><br><strong>Zookeeper</strong> 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<h1 id="ZooKeeper的由来"><a href="#ZooKeeper的由来" class="headerlink" title="ZooKeeper的由来"></a>ZooKeeper的由来</h1><p>随着大数据时代的到来，人们张口闭口都是 Hadoop、Hbase 与 Spark 等名词，似乎不懂这些都不好意思打招呼。但实际上，Hadoop 技术栈中略显低调的 ZooKeeper，对于开发人员来说是更加有用的项目。那么 ZooKeeper 是用干什么的呢？</p>
<p>ZooKeeper 是 Apache Hadoop 项目的组成部分，现在已发展成为 Apache 基金会的顶级项目。早期雅虎有许多分布式系统的项目都存在数据不一致的问题，于是雅虎的工程师开发了一套用来解决分布式环境下协调项目，使得开发人员能够专注于业务逻辑上，而不用去解决复杂的分布式问题。</p>
<p>由于雅虎内部有很多用动物命名的项目，例如 Pig、Hive 等，就像一个动物园一样。在ZooKeeper 发布之后，人们吐槽说动物名称的项目太多了，正好 ZooKeeper 是被开发来协调各个不同分布式服务，所以人们就用“动物园管理员”的名称来命名它。</p>
<h1 id="Zookeeper提供了什么"><a href="#Zookeeper提供了什么" class="headerlink" title="Zookeeper提供了什么"></a>Zookeeper提供了什么</h1><p>简单的说，zookeeper=文件系统+通知机制。</p>
<h2 id="1、-文件系统"><a href="#1、-文件系统" class="headerlink" title="1、 文件系统"></a>1、 文件系统</h2><p>Zookeeper维护一个类似文件系统的数据结构：<br><img src="/Zookeeper/2.png" alt=""></p>
<p>每个子目录项如 NameService 都被称作为 znode，和文件系统一样，我们能够自由的增加、删除 znode，在一个 znode 下增加、删除子 znode，唯一的不同在于znode是可以存储数据的。</p>
<p>有四种类型的 znode：</p>
<ol>
<li><p>PERSISTENT-持久化目录节点<br>客户端与 Zookeeper 断开连接后，该节点依旧存在</p>
</li>
<li><p>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点<br>客户端与 Zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号</p>
</li>
<li><p>EPHEMERAL-临时目录节点<br>客户端与 Zookeeper 断开连接后，该节点被删除</p>
</li>
<li><p>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点<br>客户端与 Zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号</p>
</li>
</ol>
<h2 id="2、-通知机制"><a href="#2、-通知机制" class="headerlink" title="2、 通知机制"></a>2、 通知机制</h2><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，Zookeeper 会通知客户端。 </p>
<p>就这么简单，下面我们看看能做点什么呢？</p>
<h1 id="Zookeeper-能解决哪些问题？"><a href="#Zookeeper-能解决哪些问题？" class="headerlink" title="Zookeeper 能解决哪些问题？"></a>Zookeeper 能解决哪些问题？</h1><p>分布式环境下，开发人员面临着以下的困难和挑战：</p>
<ol>
<li><p>节点故障。分布式环境中的每个节点都面临着崩溃的风险。根据分布式理论，随着运行时间和节点数量的增加，节点故障几乎是不可避免的。</p>
</li>
<li><p>通信异常。单机环境下调用另外一个程序，结果只有成功或者失败两种情况。但在分布式环境下调用别的程序，可能由于消息在网络中丢失，也有可能被调用方在执行中崩溃。总之，调用方无法等到结果的返回，调用发生超时。在这种情况下，被调用方的执行结果可能成功，也可能失败，调用方无法感知。</p>
</li>
<li><p>网络分区。由于采用网络传输信息，通信的延迟远大于单机环境。当通信延时不断增大，会出现部分节点之间可以通信，部分节点之间无法通信的情况，导致网络分区（脑裂）的出现。网络分区对分布式环境下的数据一致性有很大的影响。</p>
</li>
</ol>
<p>由于诸多问题，分布式环境下的服务的开发比单机环境下会更加困难。为了保证服务的可用性，开发人员不可避免的要解决以上问题。如果每一个项目都要去解决这些底层问题，必须去单独开发一套分布式协调的程序。不但造轮子的过程会十分低效而繁琐，往往会有很多 BUG 隐藏其中。ZooKeeper 就是为了解决上述问题而被开发，使得开发人员可以聚焦于业务逻辑。</p>
<p>ZooKeeper 是一个开源的分布式协调框架，是 Google 的 Chubby 项目的开源实现。ZooKeeper 提供了一套用来构建分布式系统的原语集合，解决了各种本需开发人员解决的分布式难题，包装成简单易用的接口，极大的简化了分布式环境下的开发工作。</p>
<h1 id="Zookeeper-主要作用"><a href="#Zookeeper-主要作用" class="headerlink" title="Zookeeper 主要作用"></a>Zookeeper 主要作用</h1><h2 id="1、-命名服务"><a href="#1、-命名服务" class="headerlink" title="1、 命名服务"></a>1、 命名服务</h2><p>这个似乎最简单，在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现，不见不散了。</p>
<h2 id="2、-配置管理"><a href="#2、-配置管理" class="headerlink" title="2、 配置管理"></a>2、 配置管理</h2><p>程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。好吧，现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好。<br><img src="/Zookeeper/3.png" alt=""></p>
<h2 id="3、-集群管理"><a href="#3、-集群管理" class="headerlink" title="3、 集群管理"></a>3、 集群管理</h2><p>所谓集群管理无在乎两点：是否有机器退出和加入、选举 master。</p>
<p>对于第一点，所有机器约定在父目录 GroupMembers 下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper 的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。新机器加入 也是类似，所有机器收到通知：新兄弟目录加入，highcount 又有了。</p>
<p>对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为 master 就好。<br><img src="/Zookeeper/4.png" alt=""></p>
<h2 id="4、-分布式锁"><a href="#4、-分布式锁" class="headerlink" title="4、  分布式锁"></a>4、  分布式锁</h2><p>有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p>
<p>对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过 createznode 的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。厕所有言：来也冲冲，去也冲冲，用完删除掉自己创建的 distribute_lock 节点就释放出锁。</p>
<p>对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次方便。<br><img src="/Zookeeper/5.png" alt=""></p>
<h2 id="5、队列管理"><a href="#5、队列管理" class="headerlink" title="5、队列管理"></a>5、队列管理</h2><p>两种类型的队列：</p>
<p>1、 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</p>
<p>2、队列按照 FIFO 方式进行入队和出队操作。</p>
<p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</p>
<p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。                 </p>
<p>终于了解完我们能用 zookeeper 做什么了，可是作为一个程序员，我们总是想狂热了解zookeeper 是如何做到这一点的，单点维护一个文件系统没有什么难度，可是如果是一个集群维护一个文件系统保持数据的一致性就非常困难了。</p>
<h1 id="分布式与数据复制"><a href="#分布式与数据复制" class="headerlink" title="分布式与数据复制"></a>分布式与数据复制</h1><p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：</p>
<pre><code>1、 容错
一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；

2、提高系统的扩展能力
把负载分布到多个节点上，或者增加节点来提高系统的负载能力；

3、提高性能
让客户端本地访问就近的节点，提高用户访问速度。
</code></pre><p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p>
<pre><code>1、写主(WriteMaster)
对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；

2、写任意(Write Any)
对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。
</code></pre><p> 对 zookeeper 来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这 也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p>
<p>我们关注的重点还是在如何保证数据在集群所有机器的一致性，这就涉及到 <strong>paxos</strong> 算法。</p>
<h1 id="数据一致性与paxos算法"><a href="#数据一致性与paxos算法" class="headerlink" title="数据一致性与paxos算法"></a>数据一致性与paxos算法</h1><p>据说 Paxos 算法的难理解与算法的知名度一样令人敬仰，所以我们先看如何保持数据的一致性，这里有个原则就是：</p>
<pre><code>在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。
</code></pre><blockquote>
<p>Paxos 算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master 维护一个全局写队列，所有写操作都必须 放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一致性。没错，就是这样，可是如果 master 挂了呢。</p>
</blockquote>
<blockquote>
<p>Paxos 算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，只有获得过半数选票的写操作才会被 批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排 序。编号严格递增，当一个节点接受了一个编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己 数据不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Zookeeper 作为 Hadoop 项目中的一个子项目，是 Hadoop 集群管理的一个必不可少的模块，它主要用来控制集群中的数据，如它管理 Hadoop 集群中的 NameNode，还有 Hbase 中 Master Election、Server 之间状态同步等。</p>
<h1 id="Zookeeper的基本概念"><a href="#Zookeeper的基本概念" class="headerlink" title="Zookeeper的基本概念"></a>Zookeeper的基本概念</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Zookeeper中的角色主要有以下三类，如下表所示：<br><img src="/Zookeeper/6.png" alt=""><br>系统模型如图所示：<br><img src="/Zookeeper/7.jpg" alt=""></p>
<h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><ol>
<li><p>最终一致性：client 不论连接到哪个 Server，展示给它都是同一个视图，这是zookeeper 最重要的性能。</p>
</li>
<li><p>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</p>
</li>
<li><p>实时性：Zookeeper 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper 不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用 sync()接口。</p>
</li>
<li><p>等待无关（wait-free）：慢的或者失效的 client 不得干预快速的 client 的请求，使得每个 client 都能有效的等待。</p>
</li>
<li><p>原子性：更新只能成功或者失败，没有中间状态。</p>
</li>
<li><p>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有 Server 上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</p>
</li>
</ol>
<h1 id="Zookeeper工作原理"><a href="#Zookeeper工作原理" class="headerlink" title="Zookeeper工作原理"></a>Zookeeper工作原理</h1><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和 命名服务等。Zookeeper 是 hadoop 的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调 机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper 的目的就在于此。</p>
<p> Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分 别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p>
<p>为了保证事务的顺序一致性，zookeeper 采用了递增的事务 id 号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了 zxid。实现中 zxid 是一个64位的数字，它高32位是 epoch 用来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个 新的 epoch，标识当前属于那个 leader 的统治时期。低32位用于递增计数。</p>
<p>每个Server在工作过程中有三种状态：</p>
<ul>
<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>
<li>LEADING：当前Server即为选举出来的leader</li>
<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>
</ul>
<h2 id="选主流程"><a href="#选主流程" class="headerlink" title="选主流程"></a>选主流程</h2><p> 当 leader 崩溃或者 leader 失去大多数的 follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 Server 都恢复到一个正确的状态。Zk 的选举算法有两种：一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的。系统默认的选举算法为 fast paxos。先介绍 basic paxos 流程：</p>
<ol>
<li>选举线程由当前 Server 发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的 Server；</li>
<li>选举线程首先向所有 Server 发起一次询问(包括自己)；</li>
<li>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>
<li>收到所有 Server 回复以后，就计算出 zxid 最大的那个 Server，并将这个 Server 相关信息设置成下一次要投票的 Server；</li>
<li><p>线程将当前 zxid 最大的 Server 设置为当前 Server 要推荐的 Leader，如果此时获胜的 Server获得 n/2 + 1 的 Server 票数， 设置当前推荐的 leader 为获胜的Server，将根据获胜的 Server 相关信息设置自己的状态，否则，继续这个过程，直到leader 被选举出来。</p>
<p> 通过流程分析我们可以得出：要使 Leader 获得多数 Server 的支持，则 Server 总数必须是奇数2n+1，且存活的 Server 的数目不得少于 n+1.</p>
<p> 每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 Server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：<br> <img src="/Zookeeper/8.png" alt=""></p>
<p>fast paxos 流程是在选举过程中，某 Server 首先向所有 Server 提议自己要成为leader，当其它 Server 收到提议以后，解决 epoch 和 zxid 的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出 Leader。其流程图如下所示：<br> <img src="/Zookeeper/9.png" alt=""></p>
</li>
</ol>
<h2 id="同步流程"><a href="#同步流程" class="headerlink" title="同步流程"></a>同步流程</h2><p>选完leader以后，zk就进入状态同步过程。</p>
<pre><code>1. leader 等待 server 连接；

2. Follower 连接 leader，将最大的 zxid 发送给 leader；

3. Leader 根据 follower 的 zxid 确定同步点；

4. 完成同步后通知 follower 已经成为 uptodate 状态；

5. Follower收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。
</code></pre><p><img src="/Zookeeper/10.jpg" alt=""></p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="Leader-工作流程"><a href="#Leader-工作流程" class="headerlink" title="Leader 工作流程"></a>Leader 工作流程</h3><p>Leader主要有三个功能：</p>
<pre><code>1. 恢复数据；

2. 维持与 Learner 的心跳，接收 Learner 请求并判断 Learner 的请求消息类型；

3. Learner 的消息类型主要有 PING 消息、REQUEST 消息、ACK 消息、REVALIDATE 消息，根据不同的消息类型，进行不同的处理。
</code></pre><p>PING 消息是指 Learner 的心跳信息；REQUEST 消息是 Follower 发送的提议信息，包括写请求及同步请求；ACK 消息是 Follower 的对提议的回复，超过半数的 Follower 通过，则 commit 该提议；REVALIDATE 消息是用来延长 SESSION 有效时间。<br>Leader 的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。<br><img src="/Zookeeper/11.png" alt=""></p>
<h3 id="Follower-工作流程"><a href="#Follower-工作流程" class="headerlink" title="Follower 工作流程"></a>Follower 工作流程</h3><p>Follower 主要有四个功能：</p>
<pre><code>1. 向 Leader 发送请求（PING 消息、REQUEST 消息、ACK 消息、REVALIDATE 消息）；

2. 接收 Leader 消息并进行处理；

3. 接收 Client 的请求，如果为写请求，发送给 Leader 进行投票；

4. 返回 Client 结果。
</code></pre><p>Follower 的消息循环处理如下几种来自 Leader 的消息：</p>
<pre><code>1. PING消息： 心跳消息；

2. PROPOSAL消息：Leader 发起的提案，要求 Follower 投票；

3. COMMIT消息：服务器端最新一次提案的信息；

4. UPTODATE消息：表明同步完成；

5. REVALIDATE消息：根据 Leader 的 REVALIDATE 结果，关闭待 revalidate 的 session 还是允许其接受消息；

6. SYNC消息：返回 SYNC 结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。
</code></pre><p>Follower 的工作流程简图如下所示，在实际实现中，Follower 是通过5个线程来实现功能的。<br><img src="/Zookeeper/12.png" alt=""></p>
<p>对于 observer 的流程不再叙述，observer 流程和 Follower 的唯一不同的地方就是observer 不会参加 leader 发起的投票。</p>
<h1 id="ZooKeeper典型使用场景一览"><a href="#ZooKeeper典型使用场景一览" class="headerlink" title="ZooKeeper典型使用场景一览"></a>ZooKeeper典型使用场景一览</h1><p>ZooKeeper 是一个高可用的分布式数据管理与系统协调框架。基于对 Paxos 算法的实现，使该框架保证了分布式环境中数据的强一致性，也正是基 于这样的特性，使得 zookeeper 能够应用于很多场景。网上对 zk 的使用场景也有不少介绍，本文将结合作者身边的项目例子，系统的对 zk 的使用场景进 行归类介绍。 值得注意的是，zk 并不是生来就为这些场景设计，都是后来众多开发者根据框架的特性，摸索出来的典型使用方法。因此，也非常欢迎你分享你在 ZK 使用上的奇技淫巧。</p>
<table>
<thead>
<tr>
<th>场景类别</th>
<th>典型场景描述（ZK特性，使用方法）</th>
<th>应用中的具体使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据发布与订阅</td>
<td>发布与订阅即所谓的配置管理，顾名思义就是将数据发布到 zk 节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，地址列表等就非常适合使用。</td>
<td>1. 索引信息和集群中机器节点状态存放在 zk 的一些指定节点，供各个客户端订阅使用。2. 系统日志（经过处理后的）存储，这些日志通常2-3天后被清除。3. 应用中用到的一些配置信息集中管理，在应用启动的时候主动来获取一次，并且在节点上注册一个 Watcher，以后每次配置有更新，实时通知到应用，获取最新配置信息。4. 业务逻辑中需要用到的一些全局变量，比如一些消息中间件的消息队列通常有个 offset，这个 offset 存放在 zk 上，这样集群中每个发送者都能知道当前的发送进度。5. 系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息。以前通常是暴露出接口，例如 JMX 接口，有了 zk 后，只要将这些信息存放到 zk 节点上即可。</td>
</tr>
<tr>
<td>Name Service</td>
<td>这个主要是作为分布式命名服务，通过调用 zk 的 create node api，能够很容易创建一个全局唯一的 path，这个 path 就可以作为一个名称。</td>
<td></td>
</tr>
<tr>
<td>分布通知/协调</td>
<td>ZooKeeper 中特有 watcher 注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对  ZK 上同一个 znode 进行注册，监听 znode 的变化（包括znode本身内容及子节点的），其中一个系统 update 了 znode ，那么另一个系统能 够收到通知，并作出相应处理。</td>
<td>1. 另一种心跳检测机制：检测系统和被检测系统之间并不直接关联起来，而是通过 zk 上某个节点关联，大大减少系统耦合。2. 另一种系统调度模式：某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改 了 ZK 上某些节点的状态，而zk就把这些变化通知给他们注册 Watcher 的客户端，即推送系统，于是，作出相应的推送任务。3. 另一种工作汇报模式：一些类似于任务分发系统，子任务启动后，到 zk 来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点），这样任务管理者就能够实时知道任务进度。总之，使用 zookeeper 来进行分布式通知和协调能够大大降低系统之间的耦合。</td>
</tr>
<tr>
<td>分布式锁</td>
<td>分布式锁，这个主要得益于 ZooKeeper 为我们保证了数据的强一致性，即用户只要完全相信每时每刻，zk 集群中任意节点（一个 zk server）上的相同 znode 的数据是一定是相同的。锁服务可以分为两类，一个是保持独占，另一个是控制时序。<strong>所谓保持独占</strong>，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把 zk 上的一个 znode 看作是一把锁，通过 create znode 的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。<strong>控制时序</strong>，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指 定）。Zk 的父节点（/distribute_lock）维持一份 sequence ,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</td>
</tr>
<tr>
<td>集群管理</td>
<td><strong>1. 集群机器监控：</strong>这通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群 机器是否存活。过去的做法通常是：监控系统通过某种手段（比如 ping ）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题：<strong>1. 集群中机器有变动的时候，牵连修改的东西比较多。2. 有一定的延时。</strong>利用 ZooKeeper 有两个特性，就可以实时另一种集群机器存活性监控系统：<strong>a. 客户端在节点 x 上注册一个 Watcher，那么如果 x 的子节点变化了，会通知该客户端。b. 创建 EPHEMERAL 类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。</strong>例如，监控系统在 /clusterServers 节点上注册一个 Watcher，以后每动态加机器，那么就往 /clusterServers 下创建一个 EPHEMERAL类型的节点：/clusterServers/{hostname}. 这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控系统的业务了。<strong>2.  Master 选举则是 zookeeper 中最为经典的使用场景了。</strong>在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行， 其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个 master 选举便是这种场景下的碰到的主要问题。利用 ZooKeeper 的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。另外，这种场景演化一下，就是动态 Master 选举。这就要用到 EPHEMERAL_SEQUENTIAL 类型节点的特性了。上文中提到，所有客户端创建请求，最终只有一个能够创建成功。在这里稍微变化下，就是允许所有请求都能够创建成功，但是得有个创建顺序，于是所有的请求最终 在 ZK 上创建结果的一种可能情况是这样： /currentMaster/{sessionId}-1 , /currentMaster/{sessionId}-2 , /currentMaster/{sessionId}-3 ….. 每次选取序列号最小的那个机器作为 Master，如果这个机器挂了，由于他创建的节点会马上小时，那么之后最小的那个机器就是 Master 了。</td>
<td>1. 在搜索系统中，如果集群中每个机器都生成一份全量索引，不仅耗时，而且不能保证彼此之间索引数据一致。因此让集群中的 Master 来进行全量索引的生成， 然后同步到集群中其它机器。2. 另外，Master 选举的容灾措施是，可以随时进行手动指定 master，就是说应用在zk在无法获取 master 信息时，可以通过比如 http 方式，向 一个地方获取 master。</td>
</tr>
<tr>
<td>分布式队列</td>
<td>队列方面，我目前感觉有两种，一种是常规的先进先出队列，另一种是要等到队列成员聚齐之后的才统一按序执行。对于第二种先进先出队列，和分布式锁服务中的控制时序场景基本原理一致，这里不再赘述。第二种队列其实是在FIFO队列的基础上作了一个增强。通常可以在 /queue 这个znode下预先建立一个/queue/num 节点，并且赋值为n（或者直接给/queue赋值n），表示队列大小，之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行 了。这种用法的典型场景是，分布式环境中，一个大任务Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。</td>
</tr>
</tbody>
</table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_25424545/article/details/81437080" target="_blank" rel="noopener">https://blog.csdn.net/qq_25424545/article/details/81437080</a><br><a href="https://blog.csdn.net/lingbo229/article/details/81052078" target="_blank" rel="noopener">https://blog.csdn.net/lingbo229/article/details/81052078</a></p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/xiongzf/img/master/WechatIMG7.jpeg',
  alipayImage: 'https://raw.githubusercontent.com/xiongzf/img/master/WechatIMG9.jpeg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>菜鸟先生</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/Zookeeper/" target="_blank" title="Zookeeper">http://yoursite.com/Zookeeper/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8zOTY2MC8xNjE4Nw==">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/Redis/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Redis
        
      </div>
    </a>
  
  
    <a href="/dubbo/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">dubbo</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ZooKeeper的由来"><span class="nav-number">1.</span> <span class="nav-text">ZooKeeper的由来</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper提供了什么"><span class="nav-number">2.</span> <span class="nav-text">Zookeeper提供了什么</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、-文件系统"><span class="nav-number">2.1.</span> <span class="nav-text">1、 文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、-通知机制"><span class="nav-number">2.2.</span> <span class="nav-text">2、 通知机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper-能解决哪些问题？"><span class="nav-number">3.</span> <span class="nav-text">Zookeeper 能解决哪些问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper-主要作用"><span class="nav-number">4.</span> <span class="nav-text">Zookeeper 主要作用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、-命名服务"><span class="nav-number">4.1.</span> <span class="nav-text">1、 命名服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、-配置管理"><span class="nav-number">4.2.</span> <span class="nav-text">2、 配置管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、-集群管理"><span class="nav-number">4.3.</span> <span class="nav-text">3、 集群管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、-分布式锁"><span class="nav-number">4.4.</span> <span class="nav-text">4、  分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、队列管理"><span class="nav-number">4.5.</span> <span class="nav-text">5、队列管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式与数据复制"><span class="nav-number">5.</span> <span class="nav-text">分布式与数据复制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据一致性与paxos算法"><span class="nav-number">6.</span> <span class="nav-text">数据一致性与paxos算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper的基本概念"><span class="nav-number">8.</span> <span class="nav-text">Zookeeper的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#角色"><span class="nav-number">8.1.</span> <span class="nav-text">角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计目的"><span class="nav-number">8.2.</span> <span class="nav-text">设计目的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper工作原理"><span class="nav-number">9.</span> <span class="nav-text">Zookeeper工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#选主流程"><span class="nav-number">9.1.</span> <span class="nav-text">选主流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步流程"><span class="nav-number">9.2.</span> <span class="nav-text">同步流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作流程"><span class="nav-number">9.3.</span> <span class="nav-text">工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-工作流程"><span class="nav-number">9.3.1.</span> <span class="nav-text">Leader 工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Follower-工作流程"><span class="nav-number">9.3.2.</span> <span class="nav-text">Follower 工作流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZooKeeper典型使用场景一览"><span class="nav-number">10.</span> <span class="nav-text">ZooKeeper典型使用场景一览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">11.</span> <span class="nav-text">参考</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2019 KNOWLEDGE IS POWER All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            KNOWLEDGE IS POWER
          </div>
          <div class="panel-body">
            Copyright © 2019 菜鸟先生 All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>