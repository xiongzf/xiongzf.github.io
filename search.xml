<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>NSHashTable 和 NSMapTable</title>
      <link href="/2018-04-27-hashTable/"/>
      <url>/2018-04-27-hashTable/</url>
      <content type="html"><![CDATA[<h1 id="NSHashTable-和-NSMapTable"><a href="#NSHashTable-和-NSMapTable" class="headerlink" title="NSHashTable 和 NSMapTable"></a>NSHashTable 和 NSMapTable</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们的开发之中不知道你是否留意过这两个类？在你的代码中，有没有使用过这两个类？（ ps：在我开发的过程中，居然没有用过。）<br>下面我们就来看看这两个类是用来干什么的。</p><h2 id="NSHashTable"><a href="#NSHashTable" class="headerlink" title="NSHashTable"></a>NSHashTable</h2><p>可能在今天的 ARC 的内存管理下，我们不太注重对于一个对象的内存管理，不太注重是不是会产生强引用，所以对于 <strong>NSHashTable</strong> 这个类不太关注，至少在我的开发过程中，没有去使用这个类。</p><p>NSHashTable 效仿了 NSSet(NSMutableSet) ，但是提供了比 NSSet 更多的操作选择。特别是在弱引用的支持上，NSHashTable 在对象以及内存处理上更加灵活。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><pre><code>1. NSHashTable 是可变的，它没有不可变版本。2. 它可以持有元素的弱引用，而且对象被销毁之后能正确的将其移除。而这一点在 NSSet 是做不到的。3. 它的成员可以在添加时被拷贝。4. 它的成员可以使用指针来标识是否相等及做 hash 检测5. 它可以包含任意指针，其成员没有限制为对象。我们可以配置一个 NSHashTable 实例来操作任意的指针，而不仅仅是对象。</code></pre><p>初始化 NSHashTable 时，我们可以设置一个初始选项，这个选项确定了 NSHashTable 对象后面所有的行为。这个选项是有 NSHashTableOptions 枚举来定义的，枚举类型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 默认行为，强引用集合中的对象，等同于 NSSet </span><br><span class="line">NSHashTableStrongMemory = 0, </span><br><span class="line"></span><br><span class="line">// 在将对象添加到集合之前，会拷贝对象 </span><br><span class="line">NSHashTableCopyIn = NSPointerFunctionsCopyIn, </span><br><span class="line"></span><br><span class="line">// 使用移位指针 (shifted pointer) 来做 hash 检测及确定两个对象是否相等； </span><br><span class="line">// 同时使用 description 方法来做描述字符串 </span><br><span class="line">NSHashTableObjectPointerPersonality = NSPointerFunctionsObjectPointerPersonality, </span><br><span class="line"></span><br><span class="line">// 弱引用集合中的对象，且在对象被释放后，会被正确的移除。 </span><br><span class="line">NSHashTableWeakMemory = NSPointerFunctionsWeakMemory</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们来看一下，关于弱引用的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController () &#123;</span><br><span class="line">    NSHashTable *_hashTable;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">     </span><br><span class="line">    [self test];</span><br><span class="line">    NSLog(@&quot;调用之后的 hashTable：%@&quot;, _hashTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    if (!_hashTable) &#123;</span><br><span class="line">        _hashTable = [NSHashTable weakObjectsHashTable];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSObject *objc = [[NSObject alloc] init];</span><br><span class="line">    [_hashTable addObject:objc];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;添加之后的 hashTable ：%@&quot;, _hashTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2018-07-12 21:32:42.401083+0800 HashTableAndMapDemo[73674:2559037] 添加之后的 hashTable ：NSHashTable &#123;</span><br><span class="line">[4] &lt;NSObject: 0x60000001f9f0&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2018-07-12 21:32:42.401264+0800 HashTableAndMapDemo[73674:2559037] 调用之后的 hashTable：NSHashTable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，在出了作用域之后，obj 立刻被释放了。集合里的引用也被安全的删除了。</p><h2 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h2><p><strong>NSMapTable</strong> 对象类似与 <strong>NSDictionary</strong> 的数据结构，但是 <strong>NSMapTable</strong> 功能比 <strong>NSDictionary</strong> 对象要多的功能就是可以设置 <strong>key</strong> 和 <strong>value</strong> 的 <strong>NSPointerFunctionsOptions</strong> 特性,其他的用法与 <strong>NSDictionary</strong> 相同。</p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><pre><code>1. NSDictionary/NSMutableDictionary 会复制 keys 并且通过强引用 values 来实现存储。2. NSMapTable 是可变的。3. NSMapTable 可以通过弱引用来持有 keys 和 values，所以当 key 或者 value 被deallocated 的时候，所存储的实体也会被移除。4. NSMapTable 可以在添加 value 的时候对 value 进行复制。</code></pre><p>和 NSHashTable 类似，NSMapTable 可以随意的存储指针，并且利用指针的唯一性来进行对比和重复检查。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>来看看简单的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)testMap &#123;</span><br><span class="line">    if (!_mapTable) &#123;</span><br><span class="line">        _mapTable = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableStrongMemory];</span><br><span class="line">        </span><br><span class="line">        NSObject *objc = [[NSObject alloc] init];</span><br><span class="line">        [_mapTable setObject:objc forKey:@&quot;123&quot;];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;keys: %@&quot;, [[_mapTable keyEnumerator] allObjects]);</span><br><span class="line">        NSLog(@&quot;_map: %@&quot;, _mapTable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打断点调试，断点1 放在 set 位置，断点2 放在 NSLog 位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po CFGetRetainCount((__bridge  CFTypeRef)(objc));</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">(lldb) po CFGetRetainCount((__bridge  CFTypeRef)(objc));</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>可以看到当 value 使用 <strong>NSMapTableStrongMemory</strong> 修饰时，objc 的引用计数为2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po CFGetRetainCount((__bridge  CFTypeRef)(objc));</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">(lldb) po CFGetRetainCount((__bridge  CFTypeRef)(objc));</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>当 value 使用 <strong>NSMapTableWeakMemory</strong> 修饰时， objc 的引用计数为1.</p><p>可以看得出来，类似于 NSHashTable 选择，不同的模式，对于对象的引用持有是不同的。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上就是关于 NSHashTable 和 NSMapTable 相关的一些记载，其实，在开中 NSSet 和 NSDictionary 能解决大多数的问题，当然了解更多的知识点，对于自己的思路也是扩展的。所以，想了解更多的内容可以参考 <a href="https://www.jianshu.com/p/dcd222900fa9" target="_blank" rel="noopener">这篇文章</a> 以及 <a href="http://www.isaced.com/post-235.html" target="_blank" rel="noopener">这篇文章</a>，或者去问度娘。</p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>NSProxy</title>
      <link href="/2018-04-25-NSProxy/"/>
      <url>/2018-04-25-NSProxy/</url>
      <content type="html"><![CDATA[<h1 id="NSProxy"><a href="#NSProxy" class="headerlink" title="NSProxy"></a>NSProxy</h1><p>前两天被问到有没有接触过<strong>NSHashTable</strong> and <strong>NSMapTable</strong>，由于项目中没用到过，所以之前也没有去了解过。然后，就在网上查了一下，结果在一篇<a href="https://blog.csdn.net/liangliang2727/article/details/46856099" target="_blank" rel="noopener">文章</a>中看到了一段话如下：</p><pre><code>如果一个开发者想要存储一个weak类型的值或者使用一个没有实现NSCopying协议的object作为NSDictionary的key，他可能会很聪明的想到NSValue +valueWithNonretainedObject。</code></pre><p>于是乎又去看看了<strong>valueWithNonretainedObject</strong>相关的内容，然后在这<a href="https://www.jianshu.com/p/51156d4ae885" target="_blank" rel="noopener">一篇文章</a>中看到了本文的主角<strong>NSProxy</strong>。</p><h2 id="偷窥NSProxy"><a href="#偷窥NSProxy" class="headerlink" title="偷窥NSProxy"></a>偷窥NSProxy</h2><p><strong>NSProxy</strong>是和<strong>NSObject</strong>同级的一个类，可以说他是一个虚拟类，它只是实现了<strong>NSObject</strong>的协议。它的作用有点类似于一个复制的类。<br>我们可以看一下<strong>NSProxy</strong>里包含哪些内容：<br><img src="https://github.com/xiongzf/img/blob/master/NSProxy.png?raw=true" alt="NSProxy"><br>可以看得出来，它确实遵守了<strong>NSObject</strong>协议，而且第一个Ivr是一个isa指针，所以我们可以把它当作一个NSObject或者派生类来使用。</p><h2 id="通过代码加深偷窥"><a href="#通过代码加深偷窥" class="headerlink" title="通过代码加深偷窥"></a>通过代码加深偷窥</h2><p>我们可以通过代码来看看，我么可以做哪些操作，可以用来做些什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//  XZFProxy.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface XZFProxy : NSProxy</span><br><span class="line">@property (nonatomic, copy) NSString *className; //类名，用来过滤类</span><br><span class="line">- (void)initWithFromObjc:(NSObject *)objc; //初始化方法</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  XZFProxy.m</span><br><span class="line">#import &quot;XZFProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@interface XZFProxy()</span><br><span class="line">@property (nonatomic, strong) NSObject *objc;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation XZFProxy</span><br><span class="line"></span><br><span class="line">+ (id)proxyWithObjc:(NSObject *)objc &#123;</span><br><span class="line">    XZFProxy *xzfProxy = [XZFProxy alloc];</span><br><span class="line">    xzfProxy.objc = objc;</span><br><span class="line">    return xzfProxy;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> 初始化</span><br><span class="line"></span><br><span class="line"> @param objc 传入一个objc</span><br><span class="line"> */</span><br><span class="line">- (void)changeObjc:(NSObject *)objc &#123;</span><br><span class="line">    self.objc = objc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 需要实现的方法</span><br><span class="line">///1.查询该方法的方法签名,用来生成 NSInvocation</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    NSMethodSignature * mSignature = nil;</span><br><span class="line">    if ([self.objc methodSignatureForSelector:sel]) &#123;</span><br><span class="line">        mSignature = [self.objc methodSignatureForSelector:sel];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mSignature = [super methodSignatureForSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return mSignature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///2.有了方法签名，调用方法实现</span><br><span class="line">-(void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    //在这里我们可以实现对任意对象的行为进行拦截</span><br><span class="line">    if (self.objc) &#123;</span><br><span class="line">        //拦截方法的执行者为复制的对象</span><br><span class="line">        [invocation setTarget:self.objc];</span><br><span class="line">        </span><br><span class="line">        if ([self.objc isKindOfClass:[NSClassFromString(self.className) class]]) &#123;</span><br><span class="line">            //拦截参数 argument：表示的是方法的参数 index：表示的是方法参数的下标</span><br><span class="line">            NSString *str = @&quot;不爱学习，只想玩。。。&quot;;</span><br><span class="line">            [invocation setArgument:&amp;str atIndex:3];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //开始调用方法</span><br><span class="line">        [invocation invoke];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>代码的调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    XZFTeacher *teacher = [[XZFTeacher alloc] init];</span><br><span class="line">    XZFProxy *xzfProxy = [XZFProxy proxyWithObjc:teacher];</span><br><span class="line">    xzfProxy.className = @&quot;XZFTeacher&quot;;</span><br><span class="line">    [xzfProxy performSelector:@selector(callStudentWithName:toLearnProject:) withObject:@&quot;张三&quot; withObject:@&quot;英语&quot;];</span><br><span class="line">    </span><br><span class="line">    XZFStudent *student = [[XZFStudent alloc] initWithName:@&quot;李四&quot;];</span><br><span class="line">    [xzfProxy changeObjc:student];</span><br><span class="line">    [xzfProxy performSelector:@selector(startLearnProject:) withObject:@&quot;数学&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在控制台查看打印的结果：<br><img src="https://github.com/xiongzf/img/blob/master/NSProxy%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png?raw=true" alt="输出结果"><br>我们很轻松的改变了Teacher的执行内容。<br>当然我们还可以通过下面两个方法，处理一个方法的返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)getReturnValue:(void *)retLoc;</span><br><span class="line">- (void)setReturnValue:(void *)retLoc;</span><br></pre></td></tr></table></figure><p>我们可以用下面的代码来获取被代理对象的方法返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *str;</span><br><span class="line">[invocation setReturnValue:&amp;str];</span><br></pre></td></tr></table></figure><p>通过下面的代码来修改被代理对象的方法的返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;迎娶白富美，出任CEO&quot;;</span><br><span class="line">[invocation setReturnValue:&amp;str];</span><br></pre></td></tr></table></figure><p>值得注意的是：<strong>上述方法是拷贝指针所指向的数据，所以要传递str指针的指针，这样才能把str设置为返回值的地址，切记不要弄混淆了。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<strong>NSProxy</strong>，不仅可以修改方法的执行结果，还可以实现埋点计数等功能。你可以开动你的大脑去想想怎么利用NSProxy实现更多你想实现的效果。本文代码地址<a href="https://github.com/xzf1993/iOSLearning.git" target="_blank" rel="noopener">请戳这里</a>。想了解更多的内容你可以参考下面的几篇文章：</p><ol><li><a href="https://www.jianshu.com/p/a7187e014c03" target="_blank" rel="noopener">https://www.jianshu.com/p/a7187e014c03</a></li><li><a href="https://www.jianshu.com/p/923f119333d8" target="_blank" rel="noopener">https://www.jianshu.com/p/923f119333d8</a></li><li><a href="https://blog.csdn.net/ssirreplaceable/article/details/53375972" target="_blank" rel="noopener">https://blog.csdn.net/ssirreplaceable/article/details/53375972</a></li></ol>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据结构算法之 二叉树</title>
      <link href="/2018-04-05-binary-tree/"/>
      <url>/2018-04-05-binary-tree/</url>
      <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><p>树（tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n(n &gt; 1)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为看起来像一颗倒挂的树，也就是说他是根朝上，而叶朝下的。它具有以下特点：</p><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li></ul><p><img src="https://raw.githubusercontent.com/xiongzf/img/master/Treedatastructure.png" alt=""></p><h2 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h2><ul><li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li><li><strong>树的度</strong>：一棵树中，最大的节点称为树的度；</li><li><strong>叶节点或终端节点</strong>：度为0的节点；</li><li><strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li><strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li><li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li><li><strong>节点的层次</strong>：从根开始定义起，根为第一层，根的子节点为第二层，以此类推；</li><li><strong>树的高度或深度</strong>：树中节点的最大层次；</li><li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li><li><strong>节点的祖先</strong>：从跟到该节点所经分支上的所有节点；</li><li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙；</li><li><strong>森林</strong>：由m(m &gt;= 0)颗互不相交的树的集合称为森林；</li></ul><h2 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h2><ul><li><strong>无序树：</strong>树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li><li><p><strong>有序树：</strong>树中任意节点的子节点之间有顺序关系，这种树称为有序树；</p><p>  <strong>1、二叉树：</strong>每个节点最多含有两个子树的树称为二叉树；</p><pre><code>**a、完全二叉树：**对于一棵二叉树，假设其深度为d（d &gt; 1）。除了第d层外，其他各层的节点数目均已达到最大值，且第d层所有节点从左向右连续的紧密的排列，这样的二叉树被称为完全二叉树，其中**满二叉树**的定义是所有叶节点都在最底层的完全二叉树；**b、平衡二叉树：**当且仅当任何节点的两颗子树的高度差不大于1的二叉树；**c、排序二叉树：**也称二叉搜索树，有序二叉树；</code></pre><p>  <strong>2、霍夫曼树（用于信息编码）：</strong>带权路径最短的二叉树称为哈夫曼树或最优二叉树；<br>  <strong>3、B树：</strong>一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</p></li></ul><h2 id="树的存储与表示"><a href="#树的存储与表示" class="headerlink" title="树的存储与表示"></a>树的存储与表示</h2><p><strong>顺序存储：</strong>将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。<br><img src="https://raw.githubusercontent.com/xiongzf/img/master/%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt=""><br><strong>链式存储：</strong><br><img src="https://raw.githubusercontent.com/xiongzf/img/master/%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt=""><br>由于对节点的个数无法掌握，常见树的存储表示都转换成二叉树进行处理，子节点个数最多为2。</p><h2 id="常见的一些树的应用场景"><a href="#常见的一些树的应用场景" class="headerlink" title="常见的一些树的应用场景"></a>常见的一些树的应用场景</h2><ol><li>xml，html等，那么编写这些东西的解析器的时候，不可避免用到树</li><li>路由协议就是使用了树的算法</li><li>mysql数据库索引</li><li>文件系统的目录结构</li><li>所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构<br><img src="https://raw.githubusercontent.com/xiongzf/img/master/%E7%BD%91%E9%A1%B5%E7%BB%93%E6%9E%84.jpg" alt=""></li></ol><h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h3><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”和“右子树”。</p><h3 id="二叉树的性质（特性）"><a href="#二叉树的性质（特性）" class="headerlink" title="二叉树的性质（特性）"></a>二叉树的性质（特性）</h3><p><strong>性质1:</strong>在二叉树的第i层上至多有2^(i-1)个节点（i &gt; 0）；<br><strong>性质2:</strong>深度为k的二叉树至多2^k -1个节点；<br><strong>性质3:</strong>对于任意一棵二叉树，如果其叶节点数为N0，而度数为2的节点总数为N1，则N0 = N1 + 1；<br><strong>性质4:</strong>具有n个节点的完全二叉树的深度必为log2(n + 1)；<br><strong>性质5:</strong>对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</p><p>(1)完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。<br><img src="https://raw.githubusercontent.com/xiongzf/img/master/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p><p>(2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。<br><img src="https://raw.githubusercontent.com/xiongzf/img/master/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p><h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><p><strong>创建节点：</strong><br>通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 二叉树节点</span><br><span class="line">@interface Binary_Tree_Node()</span><br><span class="line">@property(nonatomic, assign) int elem;</span><br><span class="line">@property(nonatomic, strong) Binary_Tree_Node *lChild;</span><br><span class="line">@property(nonatomic, strong) Binary_Tree_Node *rChild;</span><br><span class="line">- (instancetype)initWithItem:(int)item;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Binary_Tree_Node</span><br><span class="line">/**</span><br><span class="line"> 初始化节点</span><br><span class="line"> </span><br><span class="line"> @param item 节点的值</span><br><span class="line"> @return 返回节点</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithItem:(int)item &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.elem = item;</span><br><span class="line">        self.lChild = nil;</span><br><span class="line">        self.rChild = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>创建树：</strong><br>树的创建,创建一个树的类，并给一个root根节点，一开始为空，随后添加节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 二叉树</span><br><span class="line">@interface Binary_Tree()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Binary_Tree</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.root_Node = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 添加节点</span><br><span class="line">/**</span><br><span class="line"> 添加节点</span><br><span class="line"></span><br><span class="line"> @param item 节点的值</span><br><span class="line"> */</span><br><span class="line">- (void)add:(int)item &#123;</span><br><span class="line">    Binary_Tree_Node *node = [[Binary_Tree_Node alloc] initWithItem:item];</span><br><span class="line">    </span><br><span class="line">    if (self.root_Node == nil) &#123;</span><br><span class="line">        self.root_Node = node;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray &lt;Binary_Tree_Node *&gt;*nodeArray = [NSMutableArray array];</span><br><span class="line">    [nodeArray addObject:self.root_Node];</span><br><span class="line">    </span><br><span class="line">    while (nodeArray.count) &#123;</span><br><span class="line">        Binary_Tree_Node *cur_node = nodeArray[0];</span><br><span class="line">        </span><br><span class="line">        if (cur_node.lChild == nil) &#123;</span><br><span class="line">            cur_node.lChild = node;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [nodeArray addObject:cur_node.lChild];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (cur_node.rChild == nil) &#123;</span><br><span class="line">            cur_node.rChild = node;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [nodeArray addObject:cur_node.rChild];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [nodeArray removeObjectAtIndex:0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>树的遍历是一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）。那么树的两种重要的遍历模式是<strong>深度优先遍历</strong>和<strong>广度优先遍历</strong>,<strong>深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现</strong>。</p><p><strong>广度优先遍历：（层次遍历）</strong><br>从树的root开始，从上到下从左到右遍历整个树的节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 广度遍历</span><br><span class="line">/**</span><br><span class="line"> 遍历二叉树的每一个节点</span><br><span class="line"> */</span><br><span class="line">- (void)breadth_travel &#123;</span><br><span class="line">    if (self.root_Node == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray &lt;Binary_Tree_Node *&gt;*nodeArray = [NSMutableArray array];</span><br><span class="line">    [nodeArray addObject:self.root_Node];</span><br><span class="line">    </span><br><span class="line">    while (nodeArray.count) &#123;</span><br><span class="line">        Binary_Tree_Node *cur_node = nodeArray[0];</span><br><span class="line">        NSLog(@&quot;%d&quot;, cur_node.elem);</span><br><span class="line">        </span><br><span class="line">        if (cur_node.lChild != nil) &#123;</span><br><span class="line">            [nodeArray addObject:cur_node.lChild];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (cur_node.rChild != nil) &#123;</span><br><span class="line">            [nodeArray addObject:cur_node.rChild];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [nodeArray removeObjectAtIndex:0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深度优先遍历：</strong><br>对于一棵二叉树，深度优先搜索是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。<br>那么深度遍历有三种方法，这三种方式常被用于访问树的节点，他们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做先序遍历(preorder)，中序遍历(inorder)和后序遍历(postorder)。</p><ul><li>先序遍历，我们先访问根节点，然后递归使用先序遍历访左问子树，再递归使用先序遍历访问右子树</li></ul><p>根节点-&gt;左节点-&gt;右节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 1.前序遍历 根节点-&gt;左子树-&gt;右子树</span><br><span class="line">/**</span><br><span class="line"> 前序遍历 根节点-&gt;左子树-&gt;右子树</span><br><span class="line"></span><br><span class="line"> @param node 传进来的节点</span><br><span class="line"> */</span><br><span class="line">- (void)preOrder:(Binary_Tree_Node *)node &#123;</span><br><span class="line">    if (node == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%d&quot;, node.elem);</span><br><span class="line">    [self preOrder:node.lChild];</span><br><span class="line">    [self preOrder:node.rChild];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树</li></ul><p>左子树-&gt;根节点-&gt;右子树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 2.中序遍历 左子树-&gt;根节点-&gt;右子树</span><br><span class="line">/**</span><br><span class="line"> 中序遍历 左子树-&gt;根节点-&gt;右子树</span><br><span class="line"></span><br><span class="line"> @param node 传进来的节点</span><br><span class="line"> */</span><br><span class="line">- (void)inOrder:(Binary_Tree_Node *)node &#123;</span><br><span class="line">    if (node == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self inOrder:node.lChild];</span><br><span class="line">    NSLog(@&quot;%d&quot;, node.elem);</span><br><span class="line">    [self inOrder:node.rChild];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点</li></ul><p>左子树-&gt;右子树-&gt;根节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 3.前序遍历 左子树-&gt;右子树-&gt;根节点</span><br><span class="line">/**</span><br><span class="line"> 左子树-&gt;右子树-&gt;根节点</span><br><span class="line"></span><br><span class="line"> @param node 传进来的节点</span><br><span class="line"> */</span><br><span class="line">- (void)postOrder:(Binary_Tree_Node *)node &#123;</span><br><span class="line">    if (node == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self postOrder:node.lChild];</span><br><span class="line">    [self postOrder:node.rChild];</span><br><span class="line">    NSLog(@&quot;%d&quot;, node.elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiongzf/img/master/%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C.jpg" alt=""></p><p>本文代码地址<a href="https://github.com/xzf1993/Arithmetic.git" target="_blank" rel="noopener">请点我</a></p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据结构算法之 常见算法</title>
      <link href="/2018-03-31-arithmetic/"/>
      <url>/2018-03-31-arithmetic/</url>
      <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><h3 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h3><p>算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般的，当算法在处理信息时，会从输入设备或者数据的存储地址读取数据，把结果写入输出设备或者某个存储地址供以后调用。<br><strong>算法是独立存在的一种解决问题的方法和思想。</strong><br>对于算法而言，实现的语言并不重要，重要的是思想。<br>算法可以有不同的语言描述实现版本（Objective-C，Swift，Python，Java描述等），而本文主要用OC，Swift，Python语言进行描述。</p><h3 id="算法的5大特性"><a href="#算法的5大特性" class="headerlink" title="算法的5大特性"></a>算法的5大特性</h3><ol><li><strong>输入：</strong>算法具有0个或多个输入</li><li><strong>输出：</strong>算法至少有1个或多个输出</li><li><strong>有穷性：</strong>算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在接受的时间内完成</li><li><strong>确定性：</strong>算法中的每一步都有确切的含义，不会出现二义性</li><li><strong>可行性：</strong>算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成</li></ol><h3 id="数据结构的概念"><a href="#数据结构的概念" class="headerlink" title="数据结构的概念"></a>数据结构的概念</h3><p>数据是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型。如：int，float，char等。数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。</p><h3 id="算法与数据结构的区别"><a href="#算法与数据结构的区别" class="headerlink" title="算法与数据结构的区别"></a>算法与数据结构的区别</h3><p>数据结构只是静态的描述了数据元素之间的关系。高效的程序需要在数据结构的基础上设计和选择算法。<br><strong>程序 = 数据结构 + 算法</strong><br><strong>总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题的载体。</strong></p><h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>冒泡排序</strong>（bubble sort）是一种简单的排序算法。它重复的遍历要排序的数组，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数组的工作是重复的进行直到没有再需要交换的元素，也就是说该数组已经排序完成。这个算法名字的由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><strong>图解如下：</strong><br><img src="https://raw.githubusercontent.com/xiongzf/img/master/bubble.gif" alt=""></p><p><strong>原理如下：</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大（升序），就交换它们两个。</li><li>对每一对相邻的元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，最后一个除外。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><strong>代码实现如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// OC实现</span><br><span class="line">- (NSArray *)bubble_sort:(NSMutableArray &lt;NSNumber *&gt;*)array &#123;</span><br><span class="line">    if (array.count == 0) &#123;</span><br><span class="line">        return @[];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; array.count - 1; i ++) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int j = 0; j &lt; array.count - 1 - i; j ++) &#123;</span><br><span class="line">            if (array[j].intValue &gt; array[j + 1].intValue) &#123;</span><br><span class="line">                NSNumber *temp = array[j];</span><br><span class="line">                [array replaceObjectAtIndex:j withObject:array[j + 1]];</span><br><span class="line">                [array replaceObjectAtIndex:(j + 1) withObject:temp];</span><br><span class="line">                </span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            return array;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// swift实现</span><br><span class="line">//MARK: - 冒泡排序</span><br><span class="line">func bubble_sort(array: [Int]) -&gt; [Int] &#123;</span><br><span class="line">    if array.count == 0 &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var newArray = array</span><br><span class="line">    for i in 0..&lt;(newArray.count - 1) &#123;</span><br><span class="line">        var count = 0</span><br><span class="line">        </span><br><span class="line">        for j in 0..&lt;(newArray.count - 1 - i) &#123;</span><br><span class="line">            if newArray[j] &gt; newArray[j + 1] &#123;</span><br><span class="line">                let temp = newArray[j]</span><br><span class="line">                newArray[j] = newArray[j + 1]</span><br><span class="line">                newArray[j + 1] = temp</span><br><span class="line">                count += 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if count == 0 &#123;</span><br><span class="line">            return newArray</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><strong>选择排序</strong>（selection-sort）是一种简单直观的排序算法。</p><p><strong>原理如下：</strong></p><ul><li>首先在未排序的数组中找到最小（大）的元素，存放到排序序列的起始位置。</li><li>然后在从剩余未排序的元素中继续寻找最小（大）元素，放到已排序序列的末尾。</li><li>以此类推，直到所有元素排序完毕。</li></ul><p><strong>图解如下：</strong><br><img src="https://raw.githubusercontent.com/xiongzf/img/master/selection.gif" alt=""></p><p><strong>动画示例：</strong><br><img src="https://raw.githubusercontent.com/xiongzf/img/master/Selection-Sort-Animation.gif" alt=""><br>红色的表示当前最小值，黄色表示已排序元素，蓝色表示当前位置。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，他们当中至少有一个将被移到其最终位置上，因此对n个元素的数组进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序是非常好的一种。</p><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//OC实现</span><br><span class="line">- (NSArray *)select_sort:(NSMutableArray &lt;NSNumber *&gt;*)array &#123;</span><br><span class="line">    if (array.count == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; array.count; i ++) &#123;</span><br><span class="line">        int mix_index = i;</span><br><span class="line">        for (int j = i + 1; j &lt; array.count; j ++) &#123;</span><br><span class="line">            if (array[j].intValue &lt; array[mix_index].intValue) &#123;</span><br><span class="line">                mix_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        NSNumber *temp = array[i];</span><br><span class="line">        [array replaceObjectAtIndex:i withObject:array[mix_index]];</span><br><span class="line">        [array replaceObjectAtIndex:mix_index withObject:temp];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//swift实现</span><br><span class="line">//MARK: - 选择排序</span><br><span class="line">func select_sort(array: [Int]) -&gt; [Int] &#123;</span><br><span class="line">    if array.count == 0 &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var newArray = array</span><br><span class="line">    </span><br><span class="line">    for i in (0..&lt;newArray.count) &#123;</span><br><span class="line">        var min_index = i</span><br><span class="line">        </span><br><span class="line">        for j in (i + 1)..&lt;newArray.count &#123;</span><br><span class="line">            if newArray[j] &lt; newArray[min_index] &#123;</span><br><span class="line">                min_index = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let temp = newArray[i]</span><br><span class="line">        newArray[i] = newArray[min_index]</span><br><span class="line">        newArray[min_index] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><strong>插入排序：</strong>（insertion-sort）是一种简单直观的排序算法。它的工作原理是通过构建有序的序列。对于未排序的元素，在已排序的元素中从后向前扫描，找到相应的位置并插入。插入排序在实现上，在从后向前的扫描过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。</p><p><strong>图解如下：</strong><br><img src="https://raw.githubusercontent.com/xiongzf/img/master/insert.gif" alt=""></p><p><strong>示例动画如下：</strong><br><img src="https://raw.githubusercontent.com/xiongzf/img/master/Insertion-sort-example.gif" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// OC实现</span><br><span class="line">- (NSArray *)insert_sort:(NSMutableArray &lt;NSNumber *&gt;*)array &#123;</span><br><span class="line">    if (array.count == 0) &#123;</span><br><span class="line">        return @[];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; array.count; i ++) &#123;</span><br><span class="line">        for (int j = i; j &gt; 0; j --) &#123;</span><br><span class="line">            if (array[j - 1].intValue &gt; array [j].intValue) &#123;</span><br><span class="line">                NSNumber *temp = array[j - 1];</span><br><span class="line">                [array replaceObjectAtIndex:j - 1 withObject:array[j]];</span><br><span class="line">                [array replaceObjectAtIndex:j withObject:temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// swift实现</span><br><span class="line">//MARK: - 插入排序</span><br><span class="line">func insert_sort(array: [Int]) -&gt; [Int] &#123;</span><br><span class="line">    if array.count == 0 &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var newArray = array</span><br><span class="line">    </span><br><span class="line">    for i in (1..&lt;newArray.count) &#123;</span><br><span class="line">        for j in (1...i).reversed() &#123;</span><br><span class="line">            if newArray[j - 1] &gt; newArray[j] &#123;</span><br><span class="line">                let temp = newArray[j - 1]</span><br><span class="line">                newArray[j - 1] = newArray[j]</span><br><span class="line">                newArray[j] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>快速排序：</strong>（quickSort）又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割为独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达成整个数据变成有序数组。</p><p><strong>步骤如下：</strong> </p><ol><li>从数列中挑出一个元素，称为“基准”(pivot)。</li><li>重新排列数列，所有元素比基准值小的摆放在基准前面，所有的元素比基准值大的摆在基准的后面（相同的数可以到任意一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归的把小于基准元素的子数组和大于基准元素的子数组排序。</li></ol><p>递归的最底部情形是，数列的大小是0或者1，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，他至少会把一个元素摆到他最后的位置上。</p><p><strong>图解如下：</strong><br><img src="https://raw.githubusercontent.com/xiongzf/img/master/quicksort.gif" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//OC代码</span><br><span class="line">/**</span><br><span class="line"> 快速选择</span><br><span class="line"></span><br><span class="line"> @param array 快排之前的数组</span><br><span class="line"> @param start 开始的下标</span><br><span class="line"> @param end 结束的下标</span><br><span class="line"> @return 排序后的数组</span><br><span class="line"> */</span><br><span class="line">- (NSArray *)quick_sort:(NSMutableArray &lt;NSNumber *&gt;*)array startIndex:(int)start endIndex:(int)end &#123;</span><br><span class="line">    if (start &gt;= end) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int left = start;</span><br><span class="line">    int right = end;</span><br><span class="line">    </span><br><span class="line">    NSNumber *temp = array[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; array[right].intValue &gt;= temp.intValue) &#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        array[left] = array[right];</span><br><span class="line">        </span><br><span class="line">        while (left &lt; right &amp;&amp; array[left].intValue &lt; temp.intValue) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        array[right] = array[left];</span><br><span class="line">    &#125;</span><br><span class="line">    array[left] = temp;</span><br><span class="line">    </span><br><span class="line">    [self quick_sort:array startIndex:0 endIndex:left - 1];</span><br><span class="line">    [self quick_sort:array startIndex:left + 1 endIndex:end];</span><br><span class="line">    </span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Swift代码</span><br><span class="line">//MARK: - 快速排序</span><br><span class="line">func quick_sort(array: inout [Int], start: Int, end: Int) -&gt; [Int] &#123;</span><br><span class="line">    if array.count == 0 &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if start &gt;= end &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var left = start</span><br><span class="line">    var right = end</span><br><span class="line">    </span><br><span class="line">    let mid_value = array[left]</span><br><span class="line">    while left &lt; right &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; array[right] &gt;= mid_value) &#123;</span><br><span class="line">            right -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        array[left] = array[right]</span><br><span class="line">        </span><br><span class="line">        while (left &lt; right &amp;&amp; array[left] &lt; mid_value) &#123;</span><br><span class="line">            left += 1</span><br><span class="line">        &#125;</span><br><span class="line">        array[right] = array[left]</span><br><span class="line">    &#125;</span><br><span class="line">    array[left] = mid_value</span><br><span class="line">    </span><br><span class="line">    quick_sort(array: &amp;array, start: start, end: left - 1)</span><br><span class="line">    quick_sort(array: &amp;array, start: left + 1, end: end)</span><br><span class="line">    return array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><strong>希尔排序</strong>（shell sort）是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非常稳定的排序算法。该方法因DL. Shell于1959年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p><strong>排序过程：</strong><br>将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p><p><strong>图解如下：</strong><br><img src="https://raw.githubusercontent.com/xiongzf/img/master/shellsort.gif" alt=""></p><p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样(竖着的元素是步长组成)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>然后我们对每列进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>排序之后变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure><p>最后以1步长进行排序（此时就是简单的插入排序了）</p><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//OC代码</span><br><span class="line">- (NSArray *)shell_sort:(NSMutableArray &lt;NSNumber *&gt;*)array &#123;</span><br><span class="line">    if (array.count == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int T = @(array.count / 2).intValue;</span><br><span class="line">    while (T) &#123;</span><br><span class="line">        for (int i = T; i &lt; array.count; i ++) &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            while (j &gt;= T &amp;&amp; array[j - T].intValue &gt; array[j].intValue) &#123;</span><br><span class="line">                NSNumber *temp = array[j - T];</span><br><span class="line">                [array replaceObjectAtIndex:j - T withObject:array[j]];</span><br><span class="line">                [array replaceObjectAtIndex:j withObject:temp];</span><br><span class="line">                j -= T;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        T /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Swift代码</span><br><span class="line">func shell_sort(array: inout [Int]) -&gt; [Int] &#123;</span><br><span class="line">    if array.count == 0 &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var T: Int = array.count / 2</span><br><span class="line">    while T &gt; 0 &#123;</span><br><span class="line">        for i in (T..&lt;array.count) &#123;</span><br><span class="line">            var j = i</span><br><span class="line">            </span><br><span class="line">            while j &gt;= T &amp;&amp; (array[j - T] &gt; array[j]) &#123;</span><br><span class="line">                let temp = array[j - T]</span><br><span class="line">                array[j - T] = array[j]</span><br><span class="line">                array[j] = temp</span><br><span class="line">                j -= T</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        T /= 2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>归并排序</strong>是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了之后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另外一个数组的剩余部分复制过来即可。</p><p><strong>归并排序分析图解：</strong><br><img src="https://raw.githubusercontent.com/xiongzf/img/master/Merge-sort-example.gif" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">//OC代码</span><br><span class="line">- (NSMutableArray &lt;NSNumber *&gt;*)merge_sort:(NSMutableArray &lt;NSNumber *&gt;*)array &#123;</span><br><span class="line">    if (array.count &lt;= 1) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int mid_index = @(array.count / 2).intValue;</span><br><span class="line">    NSMutableArray &lt;NSNumber *&gt;*left_array = [NSMutableArray array];</span><br><span class="line">    NSMutableArray &lt;NSNumber *&gt;*right_array = [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; mid_index; i ++) &#123;</span><br><span class="line">        [left_array addObject:array[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = mid_index; i &lt; array.count; i ++) &#123;</span><br><span class="line">        [right_array addObject:array[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left_array = [self merge_sort:left_array];</span><br><span class="line">    right_array = [self merge_sort:right_array];</span><br><span class="line">    </span><br><span class="line">    NSMutableArray &lt;NSNumber *&gt;*result = [NSMutableArray array];</span><br><span class="line">    int left_index = 0;</span><br><span class="line">    int right_index = 0;</span><br><span class="line">    </span><br><span class="line">    while (left_index &lt; left_array.count &amp;&amp; right_index &lt; right_array.count) &#123;</span><br><span class="line">        if (left_array[left_index].intValue &gt; right_array[right_index].intValue) &#123;</span><br><span class="line">            [result addObject:right_array[right_index]];</span><br><span class="line">            right_index ++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [result addObject:left_array[left_index]];</span><br><span class="line">            left_index ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = left_index; i &lt; left_array.count; i ++) &#123;</span><br><span class="line">        [result addObject:left_array[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = right_index; i &lt; right_array.count; i ++) &#123;</span><br><span class="line">        [result addObject:right_array[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//swift代码</span><br><span class="line">//MARK: - 归并排序</span><br><span class="line">func merge_sort(array: inout [Int]) -&gt; [Int] &#123;</span><br><span class="line">    if array.count &lt;= 1 &#123;</span><br><span class="line">        return array</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let mid = array.count / 2</span><br><span class="line">    var left_array: [Int] = []</span><br><span class="line">    for i in (0..&lt;mid) &#123;</span><br><span class="line">        left_array.append(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var right_array: [Int] = []</span><br><span class="line">    for i in (mid..&lt;array.count) &#123;</span><br><span class="line">        right_array.append(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left_array = merge_sort(array: &amp;left_array)</span><br><span class="line">    right_array = merge_sort(array: &amp;right_array)</span><br><span class="line">    </span><br><span class="line">    var result: [Int] = []</span><br><span class="line">    var left_p = 0</span><br><span class="line">    var right_p = 0</span><br><span class="line">    </span><br><span class="line">    while left_p &lt; left_array.count &amp;&amp; right_p &lt; right_array.count &#123;</span><br><span class="line">        if left_array[left_p] &lt; right_array[right_p] &#123;</span><br><span class="line">            result.append(left_array[left_p])</span><br><span class="line">            left_p += 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.append(right_array[right_p])</span><br><span class="line">            right_p += 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for i in (left_p..&lt;left_array.count) &#123;</span><br><span class="line">        result.append(left_array[i])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for i in (right_p..&lt;right_array.count) &#123;</span><br><span class="line">        result.append(right_array[i])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的算法这么多，想了解更多的算法和数据结构的可以去看看相关的书籍比如《算法导论》、《数据结构与算法python语言描述》等。本文代码地址<a href="https://github.com/xzf1993/Arithmetic.git" target="_blank" rel="noopener">点这里</a></p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据结构算法之 链表</title>
      <link href="/2018-03-15-linkList/"/>
      <url>/2018-03-15-linkList/</url>
      <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表概念"><a href="#链表概念" class="headerlink" title="链表概念"></a>链表概念</h2><p><strong>链表</strong>是一种<strong>数据结构</strong>，和数组同级。比如，java中我们使用的ArrayList，其实现原理是数组。而LinkedList的实现原理就是链表了。链表在进行循环遍历的效率不高，但是插入和删除时优势明显。<br><strong>链表</strong>就是<strong>链式存储的线性表</strong>。根据指针域的不同，链表分为<strong>单向链表</strong>，<strong>双向链表</strong>，<strong>循环链表</strong>等等。</p><h3 id="单向节点"><a href="#单向节点" class="headerlink" title="单向节点"></a>单向节点</h3><p>链表中最简单的一种就是单向链表，它包含两个域，一个信息域和一个指针域。这个链表指向链表中的下一个节点，而最后一个节点则指向一个空值。<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png" alt=""><br>单向链表是一种线性表，实际上是由节点(Node)组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个节点只能也只有它能知道下一个节点的存储位置。由N个节点(Node)组成单向链表，每一个节点记录本节点的数据和下一个节点。向外暴露的只有一个头节点(Head)，我们对联标的所有操作，都是直接或者间接的通过其头节点来进行的。<br><img src="http://img.blog.csdn.net/20160420141138723" alt=""><br>上图中最左边的节点即为头节点(Head)，但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一节点而非下一个节点的对象。因为有着不断地引用，所以头节点就可以操作所有的节点了。<br>下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成一个单向链表。<br><img src="http://img.blog.csdn.net/20160420134010570" alt=""><br>节点是由一个需要存储的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：存储的对象、对下一个节点的引用。如下图：<br><img src="http://img.blog.csdn.net/20160420134000174" alt=""></p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表是一种更复杂的链表。每个节点有两个连接：一个指向前一个节点，(当此”连接”为第一个”连接”时，指向空值或者空列表)；而当另一个指向下一个节点，(当此“连接”为最后一个“连接”时，指向空值或者空列表)<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Doubly-linked-list.svg/610px-Doubly-linked-list.svg.png" alt=""><br>一个双向链表有三个整数值：<strong>数值</strong>，<strong>向后的节点链接</strong>，<strong>向前的节点链接</strong>。<br>双向链表也叫双链表。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样就可以从任何一个节点访问前一个节点，当然也可以访问后一个节点么，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。<br>由于另外储存了指向链表内容的指针，并且可能会修改相邻的节点，有的时候第一个节点可能会被删除或者在之前添加一个新的节点。这时候就要修改指向首个节点的指针。有一种方便的可以消除这种特殊情况的方法是在最后一个节点之后、第一个节点之前储存一个永远不会被删除或者移动的虚拟节点，形成一个下面说的循环链表。这个虚拟节点之后的节点就是真正的第一个节点。这种情况通常可以用这个虚拟节点直接表示这个链表，对于把链表单独的存在数组里的情况，也可以直接用这个数组表示链表并用第0个或者第-1个(如果编译器支持)节点固定的表示这个虚拟节点。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>在一个循环链表中，首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向知道返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存，假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。<br>指向整个列表的指针可以被称作存储指针。<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Circularly-linked-list.svg/350px-Circularly-linked-list.svg.png" alt=""><br>如上图用单向链表构建的循环链表。<br>循环链表中第一个节点就是最后一个节点，反之亦然。循环链表的无边界使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大。当然，如果只会在最后插入数据(或者只会在之前)，处理也很容易。<br>另外一种模拟的循环链表，就是在访问到最后一个节点之后的时候，手动跳转到第一个节点。访问到第一个节点之前的时候，也一样。这样也可以实现循环链表的功能，在直接用循环链表比较麻烦或者可能会出现问题的时候可以用。</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>链表中的节点不需要以特定的方式存储，但是集中存储也是可以的，主要分下面几种具体的存储方法：</p><ul><li><p><strong>共用存储空间：</strong><br>链表的节点和其他的数据共用存储空间，优点是可以存储无限多的内容(不过要处理器支持这个大小，并且存储空间足够的情况下)，不需要提前分配内存；缺点是由于内容分散，有时候可能不方便调试。   </p></li><li><p><strong>独立存储空间：</strong><br>一个链表或者多个链表使用独立的存储空间，一般用数组或者类似结构实现，优点是可以自动获得一个附加数据：唯一的编号，并且方便调试；缺点是不能动态的分配内存。当然，另外的在上面加一层块状链表用来分配内存也是可以的，这样就解决了这个问题。这种方法有时候被叫做<strong>数组模拟链表</strong>，但是事实上只是用表示在数组中的位置的下标索引代替了指向内存地址的指针，这种下标索引其实也是逻辑上的指针，整个结构还是链表，并不算是被模拟的(但是可以说成是用<strong>数组实现的链表</strong>)。</p></li></ul><h2 id="链表的几大特性"><a href="#链表的几大特性" class="headerlink" title="链表的几大特性"></a>链表的几大特性</h2><h3 id="链表主要有以下几个特性："><a href="#链表主要有以下几个特性：" class="headerlink" title="链表主要有以下几个特性："></a>链表主要有以下几个特性：</h3><ol><li>解决数组无法存储多种数据类型的问题</li><li>解决数组中，元素个数无法改变的限制</li><li>数组移动元素的过程中，要对元素进行大范围的移动，很耗时间，效率也不高。</li></ol><h3 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h3><p>连表用来构建许多其他的数据结构，如堆栈，行列和他们的衍生。<br>节点的数据域，也可以成为另一个链表。通过这种手段，我们可以用列表来构建许多链性数据结构；这个实例产生于Lisp编程语言，在Lisp中链表是初级数据结构，并且成为了常见的基础编程模式。有时候，链表用来生成联合数组，在这种情况下我们称之为联合数列。这种情况下用链表会优于其他数据结构，如自平衡二叉查找树(self-balancing binary search trees)甚至是一些小的数据集合。不管怎样，一些时候一个链表在这样一个树中建立一个节点子集，并且以此来更有效率的转换这个集合。</p><h3 id="C代码实例"><a href="#C代码实例" class="headerlink" title="C代码实例"></a>C代码实例</h3><p>链表的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct list_node &#123;</span><br><span class="line">    int data; //数据域，用于存储数据</span><br><span class="line">    struct list_node *next; //指针，可以用来访问节点数据，也可以遍历，指向下一个节点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建一个链表的一个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">struct list_node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct list_node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct list_node list_single;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    list_single *node = NULL; //1、首先定义一个头指针</span><br><span class="line">    node = (list_single *)malloc(sizeof(list_single)); //2、然后分配内存空间</span><br><span class="line">    </span><br><span class="line">    if (node == NULL) &#123;</span><br><span class="line">        printf(&quot;malloc fair!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    memset(node, 0, sizeof(list_single)); //3、清一下</span><br><span class="line">    node-&gt;data = 100; //4、给链表节点的数据赋值</span><br><span class="line">    node-&gt;next = NULL; //5、将链表的指针域指向空</span><br><span class="line">    printf(&quot;%d\n&quot;, node-&gt;data);</span><br><span class="line">    free(node);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把创建节点封装成一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">list_single *create_list_node(int data) &#123;</span><br><span class="line">    list_single *node = NULL; //1、首先定义一个头指针</span><br><span class="line">    node = (list_single *)malloc(sizeof(list_single)); //2、然后分配内存空间</span><br><span class="line">    </span><br><span class="line">    if (node == NULL) &#123;</span><br><span class="line">        printf(&quot;malloc fair!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    memset(node, 0, sizeof(list_single)); //3、清一下</span><br><span class="line">    node-&gt;data = data; //4、给链表节点的数据赋值</span><br><span class="line">    node-&gt;next = NULL; //5、将链表的指针域指向空</span><br><span class="line">    printf(&quot;%d\n&quot;, node-&gt;data);</span><br><span class="line">    free(node);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着完成上面的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">struct list_node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct list_node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct list_node list_single;</span><br><span class="line"></span><br><span class="line">list_single *create_list_node(int data) &#123;</span><br><span class="line">    list_single *node = NULL; //1、首先定义一个头指针</span><br><span class="line">    node = (list_single *)malloc(sizeof(list_single)); //2、然后分配内存空间</span><br><span class="line">    </span><br><span class="line">    if (node == NULL) &#123;</span><br><span class="line">        printf(&quot;malloc fair!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    memset(node, 0, sizeof(list_single)); //3、清一下</span><br><span class="line">    node-&gt;data = data; //4、给链表节点的数据赋值</span><br><span class="line">    node-&gt;next = NULL; //5、将链表的指针域指向空</span><br><span class="line">    printf(&quot;%d\n&quot;, node-&gt;data);</span><br><span class="line">    free(node);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int data = 100;</span><br><span class="line">    list_single *node = create_list_node(data);</span><br><span class="line">    printf(&quot;node-&gt;data = %d\n&quot;, node-&gt;data);</span><br><span class="line">    printf(&quot;node-&gt;next = %d\n&quot;, node-&gt;next);</span><br><span class="line">    free(node);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果<br><img src="http://img.blog.csdn.net/20170402142807766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW9yaXhpbmd1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含线程安全机制），全部遵从ANSI C标准，由User:JohnBull贡献，代码遵从GPL版权许可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">//声明接口</span><br><span class="line">#ifndef LLIST_H</span><br><span class="line">#define LLIST_H</span><br><span class="line"></span><br><span class="line">typedef void node_proc_fun_t(void *);</span><br><span class="line">typedef int node_comp_fun_t(const void*, const void*);</span><br><span class="line"></span><br><span class="line">typedef void LLIST_T;</span><br><span class="line"></span><br><span class="line">LLIST_T *llist_new(int elmsize);</span><br><span class="line">int llist_delete(LLIST_T *);</span><br><span class="line"></span><br><span class="line">int llist_node_append(LLIST_T *, const void *);</span><br><span class="line">int llist_node_prepend(LLIST_T *, const void *);</span><br><span class="line"></span><br><span class="line">int llist_travel(LLIST_T *, node_proc_fun_t*);</span><br><span class="line">int llist_sort(LLIST_T *, node_comp_fun_t*);</span><br><span class="line"></span><br><span class="line">void *llist_node_delete(LLIST_T *, node_comp_fun_t *, const void *key);</span><br><span class="line">void *llist_node_find(LLIST_T *, node_comp_fun_t *, const void *key);</span><br><span class="line"></span><br><span class="line">//类型确定</span><br><span class="line">struct node_st&#123;</span><br><span class="line">    void *datap;</span><br><span class="line">    struct node_st *next, *prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct llist_st&#123;</span><br><span class="line">    struct node_st head;</span><br><span class="line">    int elmsize;</span><br><span class="line">    int elmnr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//初始化和销毁</span><br><span class="line">LLIST_T *llist_new(int elmsize)&#123;</span><br><span class="line">    struct llist_st *newlist;</span><br><span class="line">    newlist = malloc(sizeof(struct llist_st));</span><br><span class="line">    </span><br><span class="line">    if (newlist == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    newlist -&gt; head.datap = NULL;</span><br><span class="line">    newlist -&gt; head.next = &amp;newlist -&gt; head;</span><br><span class="line">    newlist -&gt; head.prev = &amp;newlist -&gt; head;</span><br><span class="line">    </span><br><span class="line">    newlist -&gt; elmsize = elmsize;</span><br><span class="line">    </span><br><span class="line">    return (void *)newlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int llist_delete(LLIST_T *ptr) &#123;</span><br><span class="line">    struct llist_st *me = ptr;</span><br><span class="line">    struct node_st *curr, *save;</span><br><span class="line">    </span><br><span class="line">    for (curr = me -&gt; head.next; curr != &amp;me -&gt; head; curr = save) &#123;</span><br><span class="line">        save = curr -&gt; next;</span><br><span class="line">        free(curr -&gt; datap);</span><br><span class="line">        free(curr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(me);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//节点插入</span><br><span class="line">int llist_node_append(LLIST_T *ptr, const void *datap) &#123;</span><br><span class="line">    struct llist_st *me = ptr;</span><br><span class="line">    struct node_st *newnodep;</span><br><span class="line">    </span><br><span class="line">    newnodep = malloc(sizeof(struct node_st));</span><br><span class="line">    </span><br><span class="line">    if (newnodep == NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    newnodep -&gt; datap = malloc(me -&gt; elmsize);</span><br><span class="line">    </span><br><span class="line">    if (newnodep -&gt; datap == NULL) &#123;</span><br><span class="line">        free(newnodep);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    memcpy(newnodep -&gt; datap, datap, me -&gt; elmsize);</span><br><span class="line">    </span><br><span class="line">    me -&gt; head.prev -&gt; next = newnodep;</span><br><span class="line">    newnodep -&gt; prev = me -&gt; head.prev;</span><br><span class="line">    me -&gt; head.prev = newnodep;</span><br><span class="line">    newnodep -&gt; next = &amp;me -&gt; head;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class ChainIterator &#123;</span><br><span class="line">    public: T* Initialize(const Chain&lt;T&gt; &amp;c) &#123;</span><br><span class="line">        location = c.first;</span><br><span class="line">        if (!location) return &amp;location -&gt; data;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T *Next() &#123;</span><br><span class="line">        if (!location) return 0;</span><br><span class="line">        location = location -&gt; link;</span><br><span class="line">        if (location) return &amp;location -&gt; data;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private: ChainNode&lt;T&gt; *location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码摘自Linux内核2.6.21.5源码(部分)，展示了链表的另一种实现思路，未采用ANSI C标准，采用GNU C标准，遵从GPL版权许可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">struct list_head &#123;</span><br><span class="line">    struct list_head *next, *prev;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span><br><span class="line"> </span><br><span class="line">#define LIST_HEAD(name) /</span><br><span class="line">    struct list_head name = LIST_HEAD_INIT(name)</span><br><span class="line"> </span><br><span class="line">static inline void INIT_LIST_HEAD(struct list_head *list) &#123;</span><br><span class="line">    list-&gt;next = list;</span><br><span class="line">    list-&gt;prev = list;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static inline void __list_add(struct list_head *new, </span><br><span class="line">                        struct list_head *prev, </span><br><span class="line">                        struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = new;</span><br><span class="line">    new-&gt;next = next;</span><br><span class="line">    new-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = new;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static inline void list_add(struct list_head *new, struct list_head *head) &#123;</span><br><span class="line">    __list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static inline void __list_del(struct list_head * prev, struct list_head * next) &#123;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static inline void list_del(struct list_head *entry) &#123;</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">    entry-&gt;next = NULL;</span><br><span class="line">    entry-&gt;prev = NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#define __list_for_each(pos, head) /</span><br><span class="line">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span><br><span class="line"> </span><br><span class="line">#define list_for_each_entry(pos, head, member)                          /</span><br><span class="line">    for (pos = list_entry((head)-&gt;next, typeof(*pos), member);      /</span><br><span class="line">    prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);        /</span><br><span class="line">    pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</span><br></pre></td></tr></table></figure><h3 id="python代码的实现"><a href="#python代码的实现" class="headerlink" title="python代码的实现"></a>python代码的实现</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a><strong>单向链表</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">class SingleNode(object):</span><br><span class="line">    &quot;&quot;&quot;单链表的节点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, element):</span><br><span class="line">        self.elem = element</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingleLinkedList(object):</span><br><span class="line">    &quot;&quot;&quot;单链表&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, node = None):</span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断是否为空&quot;&quot;&quot;</span><br><span class="line">        return self._head == None</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span><br><span class="line">        # cur游标 用来遍历节点</span><br><span class="line">        cur = self._head</span><br><span class="line">        # count 记录数量</span><br><span class="line">        count = 0</span><br><span class="line"></span><br><span class="line">        while cur != None:</span><br><span class="line">            count += 1</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span><br><span class="line">        # cur游标 用来遍历节点</span><br><span class="line">        cur = self._head</span><br><span class="line"></span><br><span class="line">        while cur != None:</span><br><span class="line">            print (cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表头部添加元素&quot;&quot;&quot;</span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        node.next = self._head</span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">    def append(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br><span class="line">        node = SingleNode(item)</span><br><span class="line"></span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">        else:</span><br><span class="line">            cur = self._head</span><br><span class="line">            while cur.next != None:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    def insert(self, pos, item):</span><br><span class="line">        &quot;&quot;&quot;指定位置添加元素&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        if pos &lt;= 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">        elif pos &gt; (self.length() - 1):</span><br><span class="line">            self.append(item)</span><br><span class="line">        else:</span><br><span class="line">            pre = self._head</span><br><span class="line">            count = 0</span><br><span class="line"></span><br><span class="line">            while count &lt;= (pos - 1):</span><br><span class="line">                count += 1</span><br><span class="line">                pre = pre.next</span><br><span class="line">            # 当循环结束后，pre指向pos-1的位置</span><br><span class="line">            node = SingleNode(item)</span><br><span class="line">            node.next = pre.next</span><br><span class="line">            pre.next = node</span><br><span class="line"></span><br><span class="line">    def remove(self, item):</span><br><span class="line">        &quot;&quot;&quot;删除节点&quot;&quot;&quot;</span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = None</span><br><span class="line">        while cur != None:</span><br><span class="line">            if cur.elem == item:</span><br><span class="line">                if cur == self._head:</span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                else:</span><br><span class="line">                     pre.next = cur.next</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def search(self, item):</span><br><span class="line">        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span><br><span class="line">        cur = self._head</span><br><span class="line">        while cur != None:</span><br><span class="line">            if cur.elem == item:</span><br><span class="line">                return True</span><br><span class="line">            else:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h4 id="双向链表-1"><a href="#双向链表-1" class="headerlink" title="双向链表"></a><strong>双向链表</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    &quot;&quot;&quot;结点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, item):</span><br><span class="line">        self.elem = item</span><br><span class="line">        self.next = None</span><br><span class="line">        self.prev = None</span><br><span class="line"></span><br><span class="line">class DoubleLinkedList(object):</span><br><span class="line">    &quot;&quot;&quot;双链表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, node=None):</span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断是否为空&quot;&quot;&quot;</span><br><span class="line">        return self._head == None</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span><br><span class="line">        # cur游标 用来遍历节点</span><br><span class="line">        cur = self._head</span><br><span class="line">        # count 记录数量</span><br><span class="line">        count = 0</span><br><span class="line"></span><br><span class="line">        while cur != None:</span><br><span class="line">            count += 1</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span><br><span class="line">        # cur游标 用来遍历节点</span><br><span class="line">        cur = self._head</span><br><span class="line"></span><br><span class="line">        while cur != None:</span><br><span class="line">            print (cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表头部添加元素&quot;&quot;&quot;</span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self._head</span><br><span class="line">        self._head = node</span><br><span class="line">        node.next.prev = node</span><br><span class="line"></span><br><span class="line">    def append(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br><span class="line">        node = Node(item)</span><br><span class="line"></span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">        else:</span><br><span class="line">            cur = self._head</span><br><span class="line">            while cur.next != None:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            node.prev = cur</span><br><span class="line"></span><br><span class="line">    def insert(self, pos, item):</span><br><span class="line">        &quot;&quot;&quot;指定位置添加元素&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        if pos &lt;= 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">        elif pos &gt; (self.length() - 1):</span><br><span class="line">            self.append(item)</span><br><span class="line">        else:</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = 0</span><br><span class="line"></span><br><span class="line">            while count &lt;= pos:</span><br><span class="line">                count += 1</span><br><span class="line">                cur = cur.next</span><br><span class="line">            # 当循环结束后，pre指向pos-1的位置</span><br><span class="line">            node = Node (item)</span><br><span class="line">            node.next = cur</span><br><span class="line">            node.prev = cur.prev</span><br><span class="line">            cur.prev.next = node</span><br><span class="line">            cur.prev = node</span><br><span class="line"></span><br><span class="line">    def remove(self, item):</span><br><span class="line">        &quot;&quot;&quot;删除节点&quot;&quot;&quot;</span><br><span class="line">        cur = self._head</span><br><span class="line">        while cur != None:</span><br><span class="line">            if cur.elem == item:</span><br><span class="line">                if cur == self._head:</span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                    if cur.next:</span><br><span class="line">                        #判断链表是否只有一个节点</span><br><span class="line">                        cur.next.prev = None</span><br><span class="line">                else:</span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    if cur.prev.next:</span><br><span class="line">                        cur.next.prev = cur.prev</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">    def search(self, item):</span><br><span class="line">        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span><br><span class="line">        cur = self._head</span><br><span class="line">        while cur != None:</span><br><span class="line">            if cur.elem == item:</span><br><span class="line">                return True</span><br><span class="line">            else:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h4 id="单向链表实现的循环链表"><a href="#单向链表实现的循环链表" class="headerlink" title="单向链表实现的循环链表"></a><strong>单向链表实现的循环链表</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">class SingleNode(object):</span><br><span class="line">    &quot;&quot;&quot;单链表的节点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, element):</span><br><span class="line">        self.elem = element</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingleCycleLinkedList(object):</span><br><span class="line">    &quot;&quot;&quot;单向循环链表&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, node = None):</span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">        if node:</span><br><span class="line">            node.next = node</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断是否为空&quot;&quot;&quot;</span><br><span class="line">        return self._head == None</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return 0</span><br><span class="line">        # cur游标 用来遍历节点</span><br><span class="line">        cur = self._head</span><br><span class="line">        # count 记录数量</span><br><span class="line">        count = 1</span><br><span class="line"></span><br><span class="line">        while cur.next != self._head:</span><br><span class="line">            count += 1</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span><br><span class="line">        # cur游标 用来遍历节点</span><br><span class="line">        cur = self._head</span><br><span class="line"></span><br><span class="line">        while cur.next != self._head:</span><br><span class="line">            print (cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        # 退出循环，打印尾节点</span><br><span class="line">        print (cur.elem)</span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表头部添加元素&quot;&quot;&quot;</span><br><span class="line">        node = SingleNode(item)</span><br><span class="line"></span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = node</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        cur = self._head</span><br><span class="line"></span><br><span class="line">        while cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        node.next = self._head</span><br><span class="line">        self._head = node</span><br><span class="line">        cur.next = node</span><br><span class="line"></span><br><span class="line">    def append(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br><span class="line">        node = SingleNode(item)</span><br><span class="line"></span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = node</span><br><span class="line">        else:</span><br><span class="line">            cur = self._head</span><br><span class="line"></span><br><span class="line">            while cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">            cur.next = node</span><br><span class="line">            node.next = self._head</span><br><span class="line"></span><br><span class="line">    def insert(self, pos, item):</span><br><span class="line">        &quot;&quot;&quot;指定位置添加元素&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        if pos &lt;= 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">        elif pos &gt; (self.length() - 1):</span><br><span class="line">            self.append(item)</span><br><span class="line">        else:</span><br><span class="line">            pre = self._head</span><br><span class="line">            count = 0</span><br><span class="line"></span><br><span class="line">            while count &lt;= (pos - 1):</span><br><span class="line">                count += 1</span><br><span class="line">                pre = pre.next</span><br><span class="line">            # 当循环结束后，pre指向pos-1的位置</span><br><span class="line">            node = SingleNode(item)</span><br><span class="line">            node.next = pre.next</span><br><span class="line">            pre.next = node</span><br><span class="line"></span><br><span class="line">    def remove(self, item):</span><br><span class="line">        &quot;&quot;&quot;删除节点&quot;&quot;&quot;</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = None</span><br><span class="line">        while cur.next != self._head:</span><br><span class="line">            if cur.elem == item:</span><br><span class="line">                if cur == self._head:</span><br><span class="line">                    # 头节点情况</span><br><span class="line">                    # 找尾节点</span><br><span class="line">                    rear = self._head</span><br><span class="line">                    while rear.next != self._head:</span><br><span class="line">                        rear = rear.next</span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                    rear.next = self._head</span><br><span class="line">                else:</span><br><span class="line">                     pre.next = cur.next</span><br><span class="line">                return</span><br><span class="line">            else:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">        # 退出循环，cur指向尾节点</span><br><span class="line">        if cur.elem == item:</span><br><span class="line">            if cur == self._head:</span><br><span class="line">                # 链表只有一个节点</span><br><span class="line">                self._head = None</span><br><span class="line">            else:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def search(self, item):</span><br><span class="line">        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        cur = self._head</span><br><span class="line">        while cur.next != self._head:</span><br><span class="line">            if cur.elem == item:</span><br><span class="line">                return True</span><br><span class="line">            else:</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">        if cur.elem == item:</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><p>只要弄懂了链表的原理，其实不管用什么语言实现，只不过是一种描述方式而已。</p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>记录Photos框架的使用</title>
      <link href="/2018-01-30-new/"/>
      <url>/2018-01-30-new/</url>
      <content type="html"><![CDATA[<h1 id="记录Photos框架的使用"><a href="#记录Photos框架的使用" class="headerlink" title="记录Photos框架的使用"></a>记录Photos框架的使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天项目里用到了图片选择器，就想把之前项目里用<strong>ALAssetsLibrary</strong>框架封装的图片选择器拿过来用，但是<strong>ALAssetsLibrary</strong>框架在9.0之后就被弃用了。所以，就要试试<strong>Photos</strong>框架了。<br>在网上找了几篇blog研究了一下，就搞了起来。期间也踩了几个坑，所以开篇记录一下。</p><h2 id="第一波-获取用户相册"><a href="#第一波-获取用户相册" class="headerlink" title="第一波 获取用户相册"></a>第一波 获取用户相册</h2><p>先介绍一些概念，大家可以参考一下<a href="http://kayosite.com/ios-development-and-detail-of-photo-framework.html" target="_blank" rel="noopener">这篇blog</a></p><ul><li><strong>PHAsset：</strong>代表照片库中的一个资源，跟 ALAsset 类似，通过 PHAsset 可以获取和保存资源</li><li><strong>PHFetchOptions：</strong>获取资源时的参数，可以传 nil，即使用系统默认值</li><li><strong>PHFetchResult：</strong>表示一系列的资源集合，也可以是相册的集合</li><li><strong>PHAssetCollection：</strong>表示一个相册或者一个时刻，或者是一个「智能相册（系统提供的特定的一系列相册，例如：最近删除，视频列表，收藏等等，如下图所示）</li><li><strong>PHImageManager：</strong>用于处理资源的加载，加载图片的过程带有缓存处理，可以通过传入一个 PHImageRequestOptions 控制资源的输出尺寸等规格</li><li><strong>PHImageRequestOptions：</strong>如上面所说，控制加载图片时的一系列参数</li></ul><p>先上一段获取相册的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//所有智能相册</span><br><span class="line">        let smartAlbums = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .albumRegular, options: nil)</span><br><span class="line"></span><br><span class="line">         weak var weakSelf = self</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            smartAlbums.enumerateObjects(&#123; (collection, index, stop) in</span><br><span class="line">                if (collection.isKind(of: PHAssetCollection.self)) &#123;</span><br><span class="line">                    if (collection.localizedTitle == &quot;Recently Added&quot; || collection.localizedTitle == &quot;All Photos&quot;) &#123;</span><br><span class="line">                        weakSelf?.allAlbums.append(collection)</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            DispatchQueue.main.async &#123;</span><br><span class="line">                weakSelf?.tableView?.reloadData()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述方法中的第一第二个参数的类型介绍：</p><ol><li><p><strong>PHAssetCollectionType</strong>有三个值：</p><ul><li><strong>album：</strong>自定义相册，例如：QQ</li><li><strong>smartAlbum：</strong>相机胶卷、我的照片流、屏幕截图、全景照片等</li><li><strong>moment：</strong>时刻</li></ul></li><li><p><strong>PHAssetCollectionSubtype</strong>一些值：</p><ul><li><strong>albumRegular：</strong>用户在Photos中创建的相册，也就是我所谓的逻辑相册</li><li><strong>albumSyncedEvent：</strong>使用iTunes从Photos照片库或者iPhoto照片库同步过来的事件。然而，在iTunes 12以及iOS 9.0 beta4上，选用该类型没法获取同步的事件相册，而必须使用AlbumSyncedAlbum。</li><li><strong>albumSyncedFaces：</strong>使用iTunes从Photos照片库或者iPhoto照片库同步的人物相册。</li><li><strong>albumSyncedAlbum：</strong>做了AlbumSyncedEvent应该做的事</li><li><strong>albumImported：</strong>从相机或是外部存储导入的相册，完全没有这方面的使用经验，没法验证。</li></ul></li></ol><!--PHAssetCollectionSubtypeAlbumRegular//用户在Photos中创建的相册，也就是我所谓的逻辑相册PHAssetCollectionSubtypeAlbumSyncedEvent//使用iTunes从Photos照片库或者iPhoto照片库同步过来的事件。然而，在iTunes 12以及iOS 9.0 beta4上，选用该类型没法获取同步的事件相册，而必须使用AlbumSyncedAlbum。PHAssetCollectionSubtypeAlbumSyncedFaces//使用iTunes从    Photos照片库或者iPhoto照片库同步的人物相册。PHAssetCollectionSubtypeAlbumSyncedAlbum//做了AlbumSyncedEvent应该做的事PHAssetCollectionSubtypeAlbumImported//从相机或是外部存储导入的相册，完全没有这方面的使用经验，没法验证。PHAssetCollectionSubtypeAlbumMyPhotoStream//用户的iCloud照片流PHAssetCollectionSubtypeAlbumCloudShared//用户使用iCloud共享的相册PHAssetCollectionSubtypeSmartAlbumGeneric//文档解释为非特殊类型的相册，主要包括从iPhoto同步过来的相册。由于本人的iPhoto已被Photos替代，无法验证。不过，在我的iPad mini上是无法获取的，而下面类型的相册，尽管没有包含照片或视频，但能够获取到。PHAssetCollectionSubtypeSmartAlbumPanoramas//相机拍摄的全景照片PHAssetCollectionSubtypeSmartAlbumVideos//相机拍摄的视频PHAssetCollectionSubtypeSmartAlbumFavorites//收藏文件夹PHAssetCollectionSubtypeSmartAlbumTimelapses//延时视频文件夹，同时也会出现在视频文件夹中PHAssetCollectionSubtypeSmartAlbumAllHidden//包含隐藏照片或视频的文件夹PHAssetCollectionSubtypeSmartAlbumRecentlyAdded//相机近期拍摄的照片或视频PHAssetCollectionSubtypeSmartAlbumBursts//连拍模式拍摄的照片，在iPad mini上按住快门不放就可以了，但是照片依然没有存放在这个文件夹下，而是在相机相册里。PHAssetCollectionSubtypeSmartAlbumSlomoVideos//Slomo是slow motion的缩写，高速摄影慢动作解析，在该模式下，iOS设备以120帧拍摄。不过我的iPad mini不支持，没法验证。PHAssetCollectionSubtypeSmartAlbumUserLibrary//这个命名最神奇了，就是相机相册，所有相机拍摄的照片或视频都会出现在该相册中，而且使用其他应用保存的照片也会出现在这里。PHAssetCollectionSubtypeAny//包含所有类型--><p>从上面的方法中我们可以获取到用户相关的相册，<code>collection.localizedTitle</code>获取相册名字，对应的中英文对照如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&quot;Slo-mo&quot; : &quot;慢动作&quot;, </span><br><span class="line">&quot;Recently Added&quot; : &quot;最近添加&quot;, </span><br><span class="line">&quot;Favorites&quot; : &quot;个人收藏&quot;, </span><br><span class="line">&quot;Recently Deleted&quot; : &quot;最近删除&quot;,</span><br><span class="line">&quot;Videos&quot; : &quot;视频&quot;,</span><br><span class="line">&quot;All Photos&quot; : &quot;所有照片&quot;,</span><br><span class="line">&quot;Selfies&quot; : &quot;自拍&quot;,</span><br><span class="line">&quot;Screenshots&quot; : &quot;屏幕快照&quot;,</span><br><span class="line">&quot;Camera Roll&quot; : &quot;相机胶卷&quot;,</span><br><span class="line">&quot;Panoramas&quot; : &quot;全景照片&quot;,</span><br><span class="line">&quot;Hidden&quot; : &quot;已隐藏&quot;,</span><br><span class="line">&quot;Time-lapse&quot; : &quot;延时拍摄&quot;,</span><br><span class="line">&quot;Bursts&quot; : &quot;连拍快照&quot;.</span><br><span class="line">&quot;Depth Effect&quot; : &quot;景深效果&quot;]</span><br></pre></td></tr></table></figure><h2 id="第二波-获取相册中的资源"><a href="#第二波-获取相册中的资源" class="headerlink" title="第二波 获取相册中的资源"></a>第二波 获取相册中的资源</h2><p>先来一波代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let options = PHFetchOptions()</span><br><span class="line">options.sortDescriptors = [NSSortDescriptor.init(key: &quot;creationDate&quot;, ascending: true)]</span><br><span class="line">options.predicate = NSPredicate.init(format: &quot;mediaType == %ld&quot;, PHAssetMediaType.image.rawValue)</span><br><span class="line">let fetchResult = PHAsset.fetchAssets(in: phCollection!, options: options)</span><br><span class="line">        </span><br><span class="line">weak var weakSelf = self</span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    fetchResult.enumerateObjects &#123; (asset, index, stop) in</span><br><span class="line">        weakSelf?.dataSource.append(asset)</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，通过谓词<strong>NSPredicate</strong>筛选出所有的照片资源。<br><strong>PHAssetMediaType</strong>有四个值：</p><ul><li>unknown：未知</li><li>image：图片</li><li>video：视频</li><li>audio：音频</li></ul><p><strong>PHAsset</strong>代表照片库中的一个资源，跟<strong>ALAsset</strong>类似，通过<strong>PHAsset</strong>我们可以获取和保存资源。<br>打印asset显示包含如下信息：<br><img src="https://github.com/xiongzf/img/blob/master/Snip20180129_1.png?raw=true" alt=""></p><h2 id="第三波-获取相册里的图片"><a href="#第三波-获取相册里的图片" class="headerlink" title="第三波 获取相册里的图片"></a>第三波 获取相册里的图片</h2><p>废话不多说，直接上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    let requestOptions = PHImageRequestOptions()</span><br><span class="line">    requestOptions.resizeMode = .fast</span><br><span class="line">            </span><br><span class="line">    weak var weakSelf = self</span><br><span class="line">    let manager = PHImageManager.default()</span><br><span class="line">    manager.requestImage(for: asset, targetSize: self.getTargetSize(), contentMode: .aspectFit, options: requestOptions, resultHandler: &#123; (image, dic) in</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            if image != nil &#123;</span><br><span class="line">                weakSelf?.imgView.image = image</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>图片的获取是通过<strong>PHImageManager</strong>来获得，在这里遇到了一个坑，在网上普遍看到的写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    let requestOptions = PHImageRequestOptions()</span><br><span class="line">    requestOptions.deliveryMode = .highQualityFormat</span><br><span class="line">    requestOptions.isSynchronous = true</span><br><span class="line">    //requestOptions.isNetworkAccessAllowed = true</span><br><span class="line">    weak var weakSelf = self</span><br><span class="line">    let manager = PHImageManager.default()</span><br><span class="line">    manager.requestImage(for: asset, targetSize: PHImageManagerMaximumSize, contentMode: .aspectFit, options: requestOptions, resultHandler: &#123; (image, dic) in</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            if image != nil &#123;</span><br><span class="line">                weakSelf?.imgView.image = image</span><br><span class="line">                weakSelf?.kXZFImage = image</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中不包含<code>requestOptions.isNetworkAccessAllowed = true</code>此句代码，在模拟器上获取到了图片，但是在真机上调试的时候，打印出来的<strong>image = nil</strong>，很是纳闷，然后各种搜索查代码，然后把<strong>targetSize</strong>，给替换成了一个固定的值，结果打印出来的图片尺寸全部都是一样，并不是原图。最后又是各种尝试，查找资料，发现一篇文章里的代码包含这一句<code>requestOptions.isNetworkAccessAllowed = true</code>代码，然后再去尝试，发现获取原图成功了。应该是<strong>PHImageManager</strong>需要从Apple方获取原图。<br>如果想获取自定义的图片尺寸，就按照第一种写法，可以快速的获取到图片。如果想获取原图，就需要按照第二种写法，获取，把注释掉的代码释放出来，这样有一个问题就是，相册图片比较多，图片比较大的时候，加载会比较慢。</p><p>第一种写法的<strong>requestOptions.resizeMode</strong>有三个可选项</p><ul><li><strong>none</strong> // no resize 不重设size</li><li><strong>fast</strong> // use targetSize as a hint for optimal decoding when the source image is a compressed format (i.e. subsampling), the delivered image may be larger than targetSize  （当源图像是压缩格式(即次采样)时，使用Target Size作为最佳解码提示时，交付的图像可能大于Target Size）</li><li><strong>exact</strong> // same as above but also guarantees the delivered image is exactly targetSize (must be set when a normalizedCropRect is specified) （与上面相同，但也保证交付的图像是准确的目标大小(必须在指定了规范化的CropRect时设置)）</li></ul><p>第二种写法的<strong>requestOptions.deliveryMode</strong></p><ul><li><strong>opportunistic</strong> // client may get several image results when the call is asynchronous or will get one result when the call is synchronous （当调用是异步的时，客户端可能会得到多个映像结果，或者在调用是同步的时候会得到一个结果。）</li><li><strong>highQualityFormat</strong> // client will get one result only and it will be as asked or better than asked (sync requests are automatically processed this way regardless of the specified mode)（客户端将只获得一个结果，并且它将被问到或者比被请求的结果更好(同步请求将以这种方式自动处理，而不管指定的模式如何)。）</li><li><strong>fastFormat</strong> // client will get one result only and it may be degraded （客户端只会得到一个结果，并且可能会降级。）</li></ul><p>具体的详解，可以看开篇提到的这篇blog，有系列的介绍。本次遇到的坑就是这些，记录一下，以防下次再踩。结尾，谢谢网上各位的分享，让知识传播起来。本文源码<a href="https://github.com/xiongzf/code.git" target="_blank" rel="noopener">请戳这里</a></p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS深入学习 - Socket</title>
      <link href="/2017-11-14-socket/"/>
      <url>/2017-11-14-socket/</url>
      <content type="html"><![CDATA[<h2 id="网络各个协议：TCP-IP、socket、Http等"><a href="#网络各个协议：TCP-IP、socket、Http等" class="headerlink" title="网络各个协议：TCP/IP、socket、Http等"></a>网络各个协议：TCP/IP、socket、Http等</h2><p>网络七层由上而下分别为<strong>物理层</strong>、<strong>数据链路层</strong>、<strong>网络层</strong>、<strong>传输层</strong>、<strong>会话层</strong>、<strong>表示层</strong>和<strong>应用层</strong>。<br><img src="http://upload-images.jianshu.io/upload_images/1170656-df46648a7fadfa42.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>其中<strong>物理层</strong>、<strong>数据链路层</strong>和<strong>网络层</strong>通常被称作<strong>媒体层</strong>，是网络工程师所研究的对象；<br><strong>传输层</strong>、<strong>会话层</strong>、<strong>表示层</strong>和<strong>应用层</strong>被称为<strong>主机层</strong>，是用户所面向和关心的内容。</p><ul><li>http协议对应于应用层</li><li>TCP协议对应于传输层</li><li>ip协议对应于网络层</li></ul><p>三者本质上没有可比性，何况Http协议是基于TCP连接的。</p><blockquote><p>TCP/IP是传输层协议，主要解决数据如何在网络中传输的；而Http是应用层协议，主要解决如何包装数据。</p></blockquote><p>我们在传输数据时，可以使用传输层(TCP/IP)，但是那样的话，由于没有应用层，便无法识别数据内容，如果想要使传输数据有意义，则必须使用应用层协议。应用层协议很多，有HTTP，<a href="https://baike.baidu.com/item/ftp/13839?fr=aladdin" target="_blank" rel="noopener">FTP</a>，<a href="https://baike.baidu.com/item/Telnet/810597?fr=aladdin" target="_blank" rel="noopener">TELNET</a>等等，也可以自己定义应用层协议。WEB使用HTTP作应用层协议，以封装HTTP文本信息。然后使用TCP/IP做传输层协议将它发送到网络上。<strong>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)，通过Socket，我们才能使用TCP/IP协议。</strong><br><img src="http://upload-images.jianshu.io/upload_images/1170656-fe177ff611c71d76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="Http和Socket连接区别"><a href="#Http和Socket连接区别" class="headerlink" title="Http和Socket连接区别"></a>Http和Socket连接区别</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>要想明白Socket连接，先要明白TCP连接。手机能够使用互联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。建立一个TCP连接需要经过“三次握手”：</p><ol><li>第一次握手：客户端发送syn包(syn = j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器接收syn包，必须确认客户的SYN(ack = j + 1)，同时自己也发送一个SYN包(syn = k)，即SYN + ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN + ACK包，向服务器发送确认包ACK(ack = k + 1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1170656-a3120a20b9393a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>握手过程中传送的包里不包含数据，三次握手结束后，客户端与服务器才正式开始传输数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”。</p><p>TCP连接的拆除需要发送四个包，因此称为四次握手(four-way handshake)。在socket编程中，任何一方执行close()操作即可产生握手（有地方称为“挥手”）操作。<br><img src="http://upload-images.jianshu.io/upload_images/1170656-26cc9a86da3d9a68.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>之所以有“三次握手”和“四次握手”的区别，是因为连接时当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>http协议即超文本传输协议(Hypertext Transfer Protocol)，是web联网的基础，也是手机联网常用的协议之一，http协议是建立在TCP协议之上的一种应用。<br>http连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p><ol><li>在http 1.0中，客户端每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</li><li>在http 1.1中，则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</li></ol><p>由于http在每次请求结束后都会主动释放连接，因此http连接是一种“短连接”，要保持客户端程序的在线状态，需要不断的向服务器发起连接请求。通常的做法是即使不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端在线。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p><h2 id="Socket原理"><a href="#Socket原理" class="headerlink" title="Socket原理"></a>Socket原理</h2><h3 id="套接字-socket-概念"><a href="#套接字-socket-概念" class="headerlink" title="套接字(socket)概念"></a>套接字(socket)概念</h3><p>套接字(socket)是通信的基石，是支持TCP/IP协议的网络通信的基本单元。<br>通讯示意图：<br><img src="http://img.blog.csdn.net/20161129011241557" alt="通讯示意图"></p><p>通讯原理图：<br><img src="http://img.blog.csdn.net/20161129011308292" alt="通讯原理图"></p><p>它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：<strong>连接使用的协议</strong>、<strong>本地主机的IP地址</strong>、<strong>本地进程的协议端口</strong>、<strong>远地主机的IP地址</strong>、<strong>远地进程的协议端口</strong>。</p><p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了套接字(socket)接口。应用层和传输层通过socket接口，区分来自不同应用程序进程或者网络连接的通信，实现数据传输的并发服务。</p><h3 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h3><p>建立socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。<br>套接字之间的连接分为三个步骤：</p><ol><li>服务器监听</li><li>客户端请求</li><li>连接确认</li></ol><p><strong>服务器监听：</strong>服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。<br><strong>客户端请求：</strong>指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述他要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后向服务器端套接字提出连接请求。<br><strong>连接确认：</strong>当服务器端套接字监听或者说接受到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接受其他客户端套接的连接请求。</p><h3 id="socket连接与TCP连接"><a href="#socket连接与TCP连接" class="headerlink" title="socket连接与TCP连接"></a>socket连接与TCP连接</h3><p>创建socket连接时，可以指定使用的传输层协议，socket可以支持不同的传输层协议(TCP或UDP),当使用TCP协议进行连接时，该socket连接就是一个TCP连接。</p><h3 id="socket连接与http连接"><a href="#socket连接与http连接" class="headerlink" title="socket连接与http连接"></a>socket连接与http连接</h3><p>由于通常情况下socket连接就是TCP连接，因此socket连接一旦建立，通信双方即可开始相互发送数据内容，知道双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致socket连接断开，因此需要通过轮询告诉网络，该连接处于活跃状态。</p><p>而http连接使用的是“请求-响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务端才能回复数据。</p><p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是http连接，则服务器需要等到客户端发送一次请求后才能将数据传回客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p><pre><code>注意：1、服务器返回数据不一定是一次性就返回完的，可能是一点一点的返回的，所以我们接收数据时需要创建一个循环，循环的去接收服务器每次返回到客户端的数据。2、当最后一次返回数据为0时，说明数据已经返回完成了。3、使用socket就不需要设置ATS。因为socket是底层实现的。</code></pre><h3 id="socket使用步骤"><a href="#socket使用步骤" class="headerlink" title="socket使用步骤"></a>socket使用步骤</h3><ol><li>创建客户端socket</li><li>连接到服务器socket</li><li>客户端socket发送数据到服务器socket</li><li>客户端socket接收服务器返回的数据</li><li>关闭客户端socket</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;sys/socket.h&gt;</span><br><span class="line">#import &lt;netinet/in.h&gt;</span><br><span class="line">#import &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //1、创建客户端socket</span><br><span class="line">    /**</span><br><span class="line">    参数</span><br><span class="line">    参数1:domain，协议域/协议簇，AF_INET(IPV4的网络开发)</span><br><span class="line">    参数2:type，socket类型，SOCK_STREAM(TCP)/SOCK_DGRAM(UDP，报文)</span><br><span class="line">    参数3:protocol，IPPROTO_TCP,协议，如果输入0，可以根据第二个参数，自动选择协议</span><br><span class="line">    </span><br><span class="line">    返回值 int类型，如果&gt;0,就表示创建客户端socket成功，返回socket</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    int clientSocket = socket(AF_INET, SOCKET_STREAM, 0);</span><br><span class="line">    if (clientSocket &gt; 0) &#123;</span><br><span class="line">        NSLog(@&quot;创建客户端socket成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //2、客户端socket连接到服务器的socket</span><br><span class="line">    /**</span><br><span class="line">    参数：</span><br><span class="line">    参数1:客户端socket</span><br><span class="line">    参数2:指向数据结构sockaddr的指针，其中包括目的端口和IP地址，服务器的“结构体”地址。提示：C语言中没有对象。</span><br><span class="line">    参数3:结构体数据长度</span><br><span class="line">    </span><br><span class="line">    返回值 0 成功/其他  错误代码，(不是非0即真)</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    struct sockaddr_in addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(80);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(&quot;119.75.217.109&quot;);</span><br><span class="line">    </span><br><span class="line">    int isConnected = connect(clientSocket, (const struct sockaddr *)&amp;addr, sizeof(addr));</span><br><span class="line">    if (isConnected == 0) &#123;</span><br><span class="line">        NSLog(@&quot;连接到服务器成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //3、客户端socket向服务器socket发送请求</span><br><span class="line">    /**</span><br><span class="line">    参数：</span><br><span class="line">    参数1:客户端socket</span><br><span class="line">    参数2:发送内容地址 void * == id</span><br><span class="line">    参数3:发送内容长度</span><br><span class="line">    参数4:发送方式标志，一般为0</span><br><span class="line">    </span><br><span class="line">    返回值 如果成功，则返回发送的字节数，失败则返回SOCKET_ERROR</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    NSString *sendMsg = @&quot;GET / HTTP/1.1\r\n&quot;</span><br><span class="line">                        &quot;Host: www.baidu.com\r\n&quot;</span><br><span class="line">                        &quot;User-Agent: iphone\r\n&quot;</span><br><span class="line">                        &quot;Connection: close\r\n\r\n&quot;</span><br><span class="line">                        ;</span><br><span class="line">                        </span><br><span class="line">    ssize_t sendCount = send(clientSocket, sendMsg.UTF8String, strlen(sendMsg.UTF8String), 0);</span><br><span class="line">    NSLog(@&quot;发送字符数 %ld&quot;,sendCount);</span><br><span class="line">    </span><br><span class="line">    //4、客户端socket接收服务器socket发送的数据(响应)</span><br><span class="line">    /**</span><br><span class="line">    参数：</span><br><span class="line">    参数1：客户端socket</span><br><span class="line">    参数2：接收内容缓存区地址</span><br><span class="line">    参数3：接收内容缓存区长度</span><br><span class="line">    参数4：接收方式，0表示阻塞，必须等待服务器返回数据</span><br><span class="line">    </span><br><span class="line">    返回值 如果返回成功，则返回读入的字节数，失败则返回SOCKET_ERROR</span><br><span class="line">    </span><br><span class="line">    提示：服务器发送给客户端数据时，是一点一点发送的</span><br><span class="line">    提示：当服务器把数据都发送完了以后，再次发送时，只发送0字节</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //创建接收服务器发送的数据的容器 / 缓冲区，并且指定了容器</span><br><span class="line">    uint8_t buffer[1024];</span><br><span class="line">    //需要创建一个容器</span><br><span class="line">    NSMutableData *dataM = [NSMutableData data];</span><br><span class="line">    </span><br><span class="line">    //循环的接收服务器发送的数据</span><br><span class="line">    ssize_t recvCount = -1;</span><br><span class="line">    while (recvCount != 0) &#123;</span><br><span class="line">        //只接收了一次</span><br><span class="line">        recvCount = recv(clientSocket, buffer, sizeof(buffer), 0);</span><br><span class="line">        NSLog(@&quot;接收的内容数 %ld&quot;, recvCount);</span><br><span class="line">        [dataM appendBytes: buffer, length: recvCount];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *html = [[NSString alloc] initWithData: dataM encoding: NSUTF8StringEncoding];</span><br><span class="line">    NSLog(@&quot;%@&quot;, html);</span><br><span class="line">    </span><br><span class="line">    //5、关闭socket</span><br><span class="line">    close(clientSocket[]());</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS深入学习 - Runtime</title>
      <link href="/2017-10-20-runtime/"/>
      <url>/2017-10-20-runtime/</url>
      <content type="html"><![CDATA[<h2 id="SmallTalk-与-C-的融合–Objective-C"><a href="#SmallTalk-与-C-的融合–Objective-C" class="headerlink" title="SmallTalk 与 C 的融合–Objective-C"></a>SmallTalk 与 C 的融合–Objective-C</h2><p>三十几年前，Brad Cox 和 Tom Love在主流且高效的C语言基础上，借鉴Smalltalk的面向对象与消息机制，想要搞出一个易用且轻量的C语言扩展，但C和Smalltalk的思想和语法格格不入，比如在Smalltalk中一切皆对象，一切调用都是消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">233 log</span><br></pre></td></tr></table></figure><p>再比如用一个工厂方法来实例化一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := Person name: &apos;sunnyxx&apos; age: 26</span><br></pre></td></tr></table></figure><p>在当时来看，一个具有面向对象功能的C语言真的是非常有吸引力，但必须得解决消息语法的转换，于是乎他们开发了一个Preprocessor(预编译程序)，去解析Smalltalk风格的语法，再转换成C语言的代码，进而和其他C代码一起编译。想法很美好，但Smalltalk语法里又是空格、又是冒号的，万一遇到个什么复杂嵌套调用，语法解析多难写呀，于是乎他们想，把消息两边加个中括号吧，这样Parser写起来简单多了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Person name: &quot;sunnyxx&quot; age: 26];</span><br></pre></td></tr></table></figure><p>这就造就了Objective-C奇怪的中括号、冒号四不像语法，这怎么看都是个临时的方案，但当时可能是唯一的方法，借用已有的C的编译器比重造一个成本低多了，而且完全兼容C语言。随着这几年Apple开发的火热，Objective-C越来越成为Apple不爽的地方，先是恨透了在GCC上给Objective-C加支持，自己重建了个Clang，后是干脆重新发明了Swift来彻底代替，用了30年的时间终于还完了技术债。</p><p>虽然有了个<strong>Preprocessor</strong>，但只能做到把<strong>Smalltalk</strong>风格的代码分析并转译成C，还需要解决两个问题：</p><ol><li>C语言上实现一个<strong>OOP</strong>对象模型</li><li>将<strong>Smalltalk</strong>风格的<strong>Message</strong>机制转换成C函数调用</li></ol><p><strong>对象模型</strong>的设计倒很省事，直接搬照<strong>Smalltalk</strong>的就好了：如<strong>Class/Meta Class/Instance Method/Class Method</strong>这些概念，还有一些关键字如<strong>self/super/nil</strong>等全都是<strong>Smalltalk</strong>的。这步转换在<strong>Preprocessing</strong>过程中就可以完成，因为重写后的<strong>Class</strong>就是原原本本的C语言的<strong>Struct</strong>，只需要按<strong>Smalltalk</strong>中“类-元类”的模型设置好即可，无需额外的支持。<br><strong>消息机制</strong>就不一样了，要实现向一个<strong>target(class/instance)</strong>发送消息名<strong>(selector)</strong>动态寻找到函数实现地址<strong>(IMP)</strong>并调用的过程，还要处理消息向父类传递、消息转发(Smallltalk中叫<strong>“Message-Not-Understood”</strong>)等，这些行为无法在<strong>Preprocessing</strong>或<strong>Build Time</strong>实现，需要提供若干运行时的C函数进行支持，所有这些函数打个包，便形成了最原始的Runtime。</p><p>所以最初的<strong>Objective-C = C + Preprocessor + Runtime</strong></p><p><strong>注：GCC中一开始用预处理器来支持Objective-C，之后作为一个编译器模块，再后来都交给了Clang实现。</strong></p><p>作为单纯的C语言扩展，Runtime中只要实现几个最基础的函数(如objc_msgSend)即可，但为了构建整套Objective-C面向对象的基础库(如Foundation)，Runtime还需要提供像NSObject这样的Root Class作为面向对象的起点、提供运行时反射机制以及运行时对Class结构修改的API等。再后来，即便是Objective-C语言本身的不断发展，新语言特性的加入，也不在乎是扩展Clang和扩展Runtime，比如：</p><ul><li>ARC：编译器分析对象引用关系，在合适的位置插入内存管理的函数，并需要把这些函数打包加到Runtime中，如 ==objc_storeStrong==,==objc_storeWeak==等。同时还要处理dealloc函数，自动加入对super的调用等，具体可以看<a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="noopener">这篇文章</a>。</li><li>Lightweight Generics：叫做“轻量泛型”是因为只增加了编译器检查支持，而泛型信息并未影响到运行时，所以Runtime库无需改动。</li><li>Syntax Sugars：比如Boxed Expr(<code>@123</code>)、Array Literal(<code>@[...]</code>)、Dictionary Literal(<code>@{...}</code>)和轻量泛型一样，只是把如<code>@123</code>在编译rewrite成<code>[NSNumber numberWithInt: 123]</code>而已，无需改动Runtime。</li><li>Non Fragile Ivars: 类实例变量的动态调整技术，用于实现Objective-C Binary的兼容性，随着Objective-C 2.0出现，需要编译器和Runtime的共同配合，感兴趣的可以看<a href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html" target="_blank" rel="noopener">这篇文章</a>。</li></ul><p>因此，Runtime的精髓并非在于平日里很少接触的那些所谓的“黑魔法”Runtime API、也并非各种Swizzle大法，而是Objective-C语言层面如何处理Type、处理Value、如何设计OOP数据结构和消息机制、如何设计ABI等，去了解这么一个小而精美的C语言运行时扩展是怎么设计出来的。</p><p>相关的文章：<br><a href="https://zh.wikipedia.org/wiki/Objective-C" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Objective-C</a><br><a href="http://web.cecs.pdx.edu/~harry/musings/SmalltalkOverview.html" target="_blank" rel="noopener">http://web.cecs.pdx.edu/~harry/musings/SmalltalkOverview.html</a></p><h2 id="Runtime简介"><a href="#Runtime简介" class="headerlink" title="Runtime简介"></a>Runtime简介</h2><p>作为一门动态语言，Objective-C会尽可能的将编译和链接时要做的事情推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译环境，同时也需要一个运行时系统来执行编译好的代码。运行时系统(runtime)扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作的。因此，runtime好比Objective-C的灵魂，很多东西都是在这个基础上出现的。所以它是值得你花功夫去理解的。</p><h3 id="与静态语言编译后的区别"><a href="#与静态语言编译后的区别" class="headerlink" title="与静态语言编译后的区别"></a>与静态语言编译后的区别</h3><h4 id="1、静态语言"><a href="#1、静态语言" class="headerlink" title="1、静态语言"></a>1、静态语言</h4><p>一个静态语言程序，如下所示的C程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc, const char **argv[]) &#123;</span><br><span class="line">    printf(&quot;Hello World&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会经过编译器的语法分析，优化然后将你最佳化的代码编译成汇编语言，然后完全按照你设计的逻辑和你的代码自上而下执行。</p><h4 id="2、Objective-C-动态语言"><a href="#2、Objective-C-动态语言" class="headerlink" title="2、Objective-C 动态语言"></a>2、Objective-C 动态语言</h4><p>很常见的一个消息发送语句：</p><blockquote><p>[receiver message]</p></blockquote><p>会被编译器转化成</p><blockquote><p>objc_msgSend(receiver, selector)</p></blockquote><p>如果有参数则为</p><blockquote><p>objc_msgSend(receiver, selector, arg1, arg2, …)</p></blockquote><p>消息只有到运行时才会和函数实现绑定起来，而不是按照编译好的逻辑一成不变的执行。按照作者的理解，<strong>编译阶段只是确定了要去向receiver对象发送message消息，但是却没有发送，真正发送是等到运行的时候进行。因此，编译阶段完全不知道message方法的具体实现，甚至，该方法到底有没有被实现也不知道</strong>。这就有可能导致运行时奔溃问题。</p><h3 id="Objective-C-Runtime的几点说明"><a href="#Objective-C-Runtime的几点说明" class="headerlink" title="Objective-C Runtime的几点说明"></a>Objective-C Runtime的几点说明</h3><p> <strong>1、runtime是开源的</strong></p><p>目前Apple公司和GNU公司各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。其中Apple的版本可以在工程中引用<br><code>#import &lt;objc/runtime.h&gt; 点击右键jump to definition，进去查看</code></p><p><strong>2、runtime是由<a href="http://lib.csdn.net/base/c" target="_blank" rel="noopener">C语言</a>实现的</strong></p><p>runtime作为Objective-C最核心的部分，几乎全部由C语言实现。这里的“几乎”所指的例外就包含有的方法(比如下面要说到的objc_msgSend方法)甚至是用汇编实现的</p><p><strong>3、runtime的两个版本</strong></p><p>Objective-C运行时系统有两个已知版本：早期版本(Legacy)和现行版本(Modern)。<br>在现行版本中，最显著的新特性就是实例变量是“健壮”(non-fragile)的：</p><blockquote><p>在早期版本中，如果你改变类中实例变量的布局，你必须重新编译该类的所有子类。<br>在现行版本中，如果你改变类中实例变量的布局，你无需重新编译该类的任何子类。<br>此外，现行版本支持声明property的synthesis属性器。</p></blockquote><h3 id="和Runtime-system交互的三种方式"><a href="#和Runtime-system交互的三种方式" class="headerlink" title="和Runtime system交互的三种方式"></a>和Runtime system交互的三种方式</h3><p><strong>1、通过Objective-C源代码</strong></p><p>大部分情况下，运行时系统在后台自动运行，我们只需要编写和编译Objective-C源代码。<br>当编译Objective-C类和方法时，编译器为实现语言动态特性将自动创建一些<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a>和函数。这些数据结构包含类定义和协议定义中的信息，如在Objective-C 2.0 程序设计语言中定义类和协议类一节所讨论的<strong>类的对象</strong>和<strong>协议类的对象</strong>，方法选标，实例变量模板，以及其他来自于源代码的信息。运行时系统的主要功能就是根据源代码中的表达式发送消息。</p><p><strong>2、通过类NSObject的方法</strong></p><p>Cocoa程序中绝大部分类都是NSObject类的子类，所以大部分都继承了NSObject类的方法，因而继承了NSObject的行为(NSProxy类是个例外)。然而，某些情况下，NSObject类仅仅定义了完成某件事情的模板，而没有提供所有需要的代码。</p><p>例如，NSObject类定义了description方法，返回该类内容的字符串表示。这主要是用来调试程序–GDB中的print-object方法就是直接打印出该方法返回的字符串。NSObject类中该方法的实现并不知道子类中的内容，所以它只是返回类的名字和对象的地址。NSObject的子类可以重新实现该方法以提供更多的信息。</p><p>某些NSObject的方法只是简单的从运行时系统中获取信息，从而允许对象进行一定程度的自我检查。</p><p>例如，<strong>class返回对象的类；isKindOfClass:和isMemberOfClass:则检查对象是否在指定的类继承体系中；respondsToSelector:检查对象能否响应指定的消息；conformsToProtocol:检查对象是否实现了指定协议类的方法；methodForSelector:则返回指定方法实现的地址</strong>。</p><p><strong>3、通过运行时系统的函数</strong></p><p>运行时系统是一个有公开接口的动态库，由一些数据接口和函数的集合组成，这些数据结构和函数的声明头文件在<strong>/usr/include/objc</strong>中。这些函数支持用纯C的函数来实现和Objective-C同样的功能。还有一些函数构成了NSObject类方法的基础。这些函数使得访问运行时系统接口和提供开发工具成为可能。尽管大部分情况下它们在Objective-C程序不是必须的，但是有时候对于Objective-C程序来说某些函数是非常有用的。这些函数的文档参见Objective-C 2.0运行时系统参考库。</p><h2 id="Runtime的几个概念"><a href="#Runtime的几个概念" class="headerlink" title="Runtime的几个概念"></a>Runtime的几个概念</h2><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>SEL又叫方法选择器，这到底是个什么玩意呢？在objc.h中是这样定义的：</p><blockquote><p>typedef struct objc_selector *SEL;</p></blockquote><p>这个SEL表示什么？首先，说白了，方法选择器仅仅是一个char*指针，仅仅表示它所代表的方法名字罢了。Objective-C在编译的时候，会根据方法的名字，生成一个用来区分这个方法的唯一的一个ID，这个ID就是SEL类型的。我们需要注意的是，只要方法的名字相同，那么它们的ID都是相同的。就是说，不管是超类还是子类，不管有没有超类和子类的关系，只要名字相同那么ID就是一样的。</p><p>而这也就导致了Objective-C在处理有相同函数名和参数个数但参数类型不同的函数的能力非常的弱，比如当你想在程序中实现下面两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(void)setWidth: (int)width;</span><br><span class="line">-(void)setWidth: (double)width;</span><br></pre></td></tr></table></figure><p>这样的函数则被认为是一种编译错误，而这最终导致了一个非常非常奇怪的Objective-C特色的函数命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(void)setWidthIntValue: (int)width;</span><br><span class="line">-(void)setWidthDoubleValue: (double)width;</span><br></pre></td></tr></table></figure><p>可能有人会问，runtime费了老半天劲，究竟想做什么？</p><p>刚才我们说道，编译器会根据每个方法的方法名为那个方法生成唯一的SEL，这些SEL组成一个Set集合，这个Set简单的说就是一个经过了优化过的hash表。而Set的特点就是唯一，也就是SEL是唯一的，因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，犀利，速度上无与伦比。但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降(或是没有冲突，因为也可能用的是perfect hash)。但是不管使用什么样的方法加速，如果能够将总量减少(多个方法可能对应同一个SEL),那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。</p><p>到这里，我们明白了，本质上，SEL只是一个指向方法的指针(准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法)，它的存在只是为了加快方法的查询速度。</p><p>通过下面三种方法可以获取SEL：</p><ol><li>sel_registerName函数</li><li>Objective-C 编译器提供的@selector()</li><li>NSSelectorFromString()方法</li></ol><h3 id="IMP，方法实现的指针"><a href="#IMP，方法实现的指针" class="headerlink" title="IMP，方法实现的指针"></a>IMP，方法实现的指针</h3><p>IMP在objc.h中是如此定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id(*IMP)(id, SEL, ...);</span><br></pre></td></tr></table></figure><p>第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，这个比SEL要好理解多了，熟悉C语言的同学都知道，这其实是一个函数指针。<br>第二个参数：是方法选择器(selector)</p><p>接下来的参数：方法的参数列表</p><p>前面介绍过的SEL就是为了查找方法的最终实现IMP的，由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确的获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们可以像调用普通的C语言函数一样来使用这个函数指针了。</p><p>下面的例子，介绍了取得函数指针，即函数指针的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void(* performMessage)(id, SEL);//定义一个IMP(函数指针)</span><br><span class="line">performMessage = (void)(*)(id, SEL)[self methodForSelector: @selector(message)];//通过methodForSelector方法根据SEL获取对应的函数指针</span><br><span class="line">performMessage(self, @selector(message));//通过取到的IMP（函数指针）跳过runtime消息传递机制，直接执行message方法</span><br></pre></td></tr></table></figure><p>用IMP的方式，省去了runtime消息传递过程中所做的一系列动作，比直接向对象发送消息效率高效一些。</p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>Method用于表示类定义中的方法，则定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Methodstructobjc_method &#123;</span><br><span class="line">    SEL method_name   OBJC2_UNAVAILABLE; //方法名</span><br><span class="line">    char *method_types OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp OBJC2_UNAVAILABLE; //方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调节方法的实现代码</p><h3 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h3><p>meta-class是一个类对象的类(注意是类对象)。<br>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。<br>既然是对象，那么它也是一个objc_object指针，它包含了一个指向其类的一个isa指针。那么，这个isa指针指向什么呢？<br>为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，meta-class中存储着一个类的所有类方法。</p><p>所以，调用类方法的这个类对象的isa指针指向的就是meta-class。</p><p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p><p>再深入一下，meta-class也是一个类，也可以向他发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无线延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为他们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。</p><p>通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相对应meta-class类的一个继承体系，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/1975901-c24b99d58f101b85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>Category是表示一个指向分类的结构体的指针，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_category* Category &#123;</span><br><span class="line">    char *category_name OBJC2_UNAVAILABLE; //分类名char *cla</span><br><span class="line">    ss_name OBJC2_UNAVAILABLE; //分类所属的类名structobjc</span><br><span class="line">    _method_list *instance_methods OBJC2_UNAVAILABLE; //实例方法列表struc</span><br><span class="line">    tobjc_method_list *class_methods OBJC2_UNAVAILABLE; //类方法列表str</span><br><span class="line">    uctobjc_protocol_list *protocols OBJC2_UNAVAILABLE; //分类所实现的协议列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods列表是objc_class中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。</p><p>可发现，类别中没有ivar成员变量指针，也就意味着：类别中不能够添加实例变量和属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_ivar_list *ivars  OBJC2_UNAVAILABLE; //该类的成员变量链表</span><br></pre></td></tr></table></figure><h3 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h3><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct object_class *Class</span><br></pre></td></tr></table></figure><p>它的定义如下：</p><p>查看objc/runtime.h中objc_class结构体的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct object_class &#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">    #if!__OBJC2__</span><br><span class="line">    Class super_class  OBJC2_UNAVAILABLE; //父类</span><br><span class="line">    const char *name  OBJC2_UNAVAILABLE; //类名</span><br><span class="line">    long version  OBJC2_UNAVAILABLE; //类的版本信息，默认0 </span><br><span class="line">    long info  OBJC2_UNAVAILABLE; //类信息，供运行期使用的一些位标识</span><br><span class="line">    long  instance_size  OBJC2_UNAVAILABLE; //该类的实例变量大小</span><br><span class="line">    struct objc_ivar_list *ivars  OBJC2_UNAVAILABLE; //该类的成员变量链表</span><br><span class="line">    struct objc_method_list *methodLists  OBJC2_UNAVAILABLE; //方法定义的链表</span><br><span class="line">    struct objc_cache *cache  OBJC2_UNAVAILABLE; //方法缓存</span><br><span class="line">    struct objc_protocol_list *protocol  OBJC2_UNAVAILABLE; //协议链表</span><br><span class="line">    #endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><h3 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h3><p>objc_object是表示一个类的实例的结构体</p><blockquote><p>它的定义如下(objc/objc.h):<br>struct objc_object { Class isa OBJC_ISA_AVAILABILITY;};<br>typedef struct objc_object *id;</p></blockquote><p>可以看到，这个结构体只有指向类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。runtime库会在类的方法列表及父类的的方法列表中去寻找与消息对应的selector指向的方法，找到后即运行这个方法。</p><h2 id="消息调用流程"><a href="#消息调用流程" class="headerlink" title="消息调用流程"></a>消息调用流程</h2><h3 id="传递消息所用的几个runtime方法"><a href="#传递消息所用的几个runtime方法" class="headerlink" title="传递消息所用的几个runtime方法"></a>传递消息所用的几个runtime方法</h3><p>前面我们说过，下面的方法：</p><blockquote><p><code>[receiver message]</code><br><code>objc_msgSend(receiver, selector)</code></p></blockquote><p>实际上，同objc_msgSend方法类似的还有几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend_stret (返回值是结构体)</span><br><span class="line">objc_msgSend_fpret (返回值是浮点型)</span><br><span class="line">objc_msgSendSuper (调用父类方法)</span><br><span class="line">objc_msgSendSuper_stret (调用父类方法，返回值是结构体)</span><br></pre></td></tr></table></figure><p>它们的作用都是类似的，为了简单起见，后续介绍消息和消息传递机制都以objc_msgSend方法为例。</p><h3 id="消息调用"><a href="#消息调用" class="headerlink" title="消息调用"></a>消息调用</h3><p>一切还是从消息表达式[receiver message]开始，在被转换成objc_msgSend(receiver, SEL)后，在运行时，runtime system会做以下事情：</p><ol><li>检查忽略的Selector，比如当我们运行在有垃圾回收机制的环境中，将会忽略retain和release消息。</li><li>检查receiver是否为nil。不像其他语言，nil在Objective-C中是完全合法的，并且这里有很多原因你也愿意这样，比如，至少我们省去了给一个对象发送消息前检查对象是否为空的操作。如果receiver为空，则会将selector也设置为空，并且直接返回到消息调用的地方。如果对象非空，就继续下一步。</li><li>接下来会根据SEL到当前类中查找对应的IMP，首先会在cache中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。</li><li>检索当前类对象中的方法表(method list)，如果找到了，加入cache中，并且跳转到这个函数执行，否则进行下一步。</li><li>从父类中寻找，直到根类：NSObject类。找到了就将方法加入对应类的cache表中，如果仍未找到，则要进入后文介绍的内容：<strong>动态方法决议</strong>。</li><li>如果动态方法决议仍不能解决问题，只能进行最后一次尝试，进入<strong>消息转发流程</strong>。</li><li>如果还不行，会奔溃。</li></ol><p>这里的调用可以分成两部分<br><strong>1、调用的方法可以找到（执行步骤1-4）</strong><br>下面的图部分展示了这个调用过程：<br>当消息发送给一个对象时，首先从运行时系统缓存使用过的方法中寻找。如果找到，执行方法，如果没有找到继续执行下面的步骤。objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector， objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现，并将该方法添加进入缓存中，如果最后没有定位到selector，则会走动态解析流程。<br><img src="http://upload-images.jianshu.io/upload_images/1975901-b605d548fb60ef79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>2、调用的方法找不到（消息转发机制）</strong><br>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以[objc message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，此时编译器不会报错，需要等到运行时才能确定object是否能接收message消息。如果不能，则程序奔溃。</p><p>通常，我们不能确定一个对象是否能接受某个消息时，会先调用respondsToSelector: 来判断一下。如下代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (self respondsToSelector: @selector(method)) &#123;</span><br><span class="line">    [self performSelector: @selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我们这边想讨论下不使用respondsToSelector: 判断的情况。<br>当一个对象无法接收某一消息时，就会启动所谓”消息转发(message forwarding)”机制，通过这一机制，我们可以告诉对象如何处理位置消息。默认情况下，对象接收到未知的消息，会导致程序奔溃，通过控制台，我么可以看到以下异常信息：<br>这段异常信息实际上是由NSObject的“doesNotRecongnizeSelector”方法抛出的。不过，我们可以采取一些措施，在程序奔溃前执行特定的逻辑，而避免程序奔溃。<br>消息转发机制基本上分为三个步骤：</p><ol><li>动态方法解析</li><li>备用接收者</li><li>完整转发</li></ol><p>消息的转发流程图：<br><img src="http://upload-images.jianshu.io/upload_images/1975901-628a7025a37e51c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>动态方法解析</strong><br>对象在接收到未知消息时，首先会调用所属类的类方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ resolveInstanceMethod: (实例方法) 或者</span><br><span class="line">+ resolveClassMethod: (类方法)</span><br></pre></td></tr></table></figure><p>让我们可以在程序运行时动态的为一个selector提供实现，如果我们添加了函数的实现，并返回YES，运行时系统会重启一次消息的放松过程，调用动态添加的方法。例如，下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod: (SEL)sel &#123;</span><br><span class="line">    if (sel == @selector(foo)) &#123;</span><br><span class="line">        class_addMethod([self class], sel, (IMP)dynamicMethodIMP, &quot;V@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod: sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，我们有机会为该未知消息新增一个“处理方法”，通过运行时class_addMethod函数动态的添加到类里面就可以了。</p><p>这种方案更多的是为了实现@dynamic属性。<strong>注：@dynamic 关键字就是告诉编译器不要做这些事，同时在使用了存储方法时也不要报错，即让编译器相信存储方法会在运行时找到。</strong></p><p><strong>备用接收者</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector: (SEL)aSelector</span><br></pre></td></tr></table></figure><p>如果在上一步无法处理消息，则runtime会继续调用以下方法：<br>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p><p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p><p><strong>完整消息转发</strong><br>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制。我们首先要通过，指定方法签名，若返回nil，则表示不处理。<br>如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector: (SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString: @&quot;testInstanceMethod&quot;]) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjcTypes: &quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super methodSignatureForSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若返回方法签名，则会进入下一步调用以下方法，对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在Invocation中，包括selector，目标(target)和参数。<br>我们可以在forwardInvocation方法中选择将消息转发给其它对象。我们可以通过Invocation做很多处理，比如修改实现方法，修改响应对象等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvaocation: (NSInvocation)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget: _helper];</span><br><span class="line">    [anInvocation setSelector: @selector(run)];</span><br><span class="line">    [anInvocation invokeWithTarget: self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数检索优化措施"><a href="#函数检索优化措施" class="headerlink" title="函数检索优化措施"></a>函数检索优化措施</h2><h3 id="通过SEL进行IMP匹配"><a href="#通过SEL进行IMP匹配" class="headerlink" title="通过SEL进行IMP匹配"></a>通过SEL进行IMP匹配</h3><p>先来看看类对象中保存的方法列表和方法的<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct method_list_t &#123;</span><br><span class="line">    uint32_t entsize_NEVER_USE;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    struct method_t first; </span><br><span class="line">&#125; method_list_t;</span><br><span class="line"></span><br><span class="line">typedef struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types; //参数类型和返回值类型</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125; method_t;</span><br></pre></td></tr></table></figure><p>在前面介绍SEL的时候，我们已经说过了苹果在通过SEL检索IMP时做的努力，这里不再累述。</p><h3 id="cache缓存"><a href="#cache缓存" class="headerlink" title="cache缓存"></a>cache缓存</h3><p>cache的原则就是缓存那些可能要执行的函数地址，那么下次调用的时候，速度就可以快速很多。这个和CPU的各种缓存原理相同。说了这么多，再来认识几个名词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct objc_cache &#123;</span><br><span class="line">    uintptr_tmask;</span><br><span class="line">    uintptr_toccupied;</span><br><span class="line">    cache_entry *buckets[1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    void *unused;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125; cache_entry;</span><br></pre></td></tr></table></figure><p>看这个结构，还是hash table。<br>objc_msgSend 首先在cache list中找SEL，没有找到就在class method中找，super class method中找（当然super class 也有cache list）。而cache的缓存机制则非常复杂了，由于Objective-C是动态语言。所以，这里面还有很多的多线程同步问题，而这些锁又是效率的大敌，相关的内容已经远远超过文本讨论的范围。<br>如果在缓存中已经有了需要的方法选标，则消息仅仅比函数调用慢一点。如果程序运行了足够长的时间，几乎每个消息都能在缓存中找到方法实现。程序运行时，缓存也讲随着新的消息的增加而增加。据牛人说(没有亲测过)，苹果通过这些优化，在消息传递和直接的函数调用上的差距已经相当的小了。</p><h2 id="方法调用中的隐藏参数"><a href="#方法调用中的隐藏参数" class="headerlink" title="方法调用中的隐藏参数"></a>方法调用中的隐藏参数</h2><p>在进行面向对象编程的时候，在实例方法中都是用过self关键字，可是你有没有想过，<strong>为什么在一个实例方法中，通过self关键字就能调取到当前方法的对象呢？</strong>这就要归功于runtime system消息的隐藏参数了。<br>当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，它还将传递两个隐藏的参数：</p><ul><li>接收消息的对象（也就是self指向的内容）</li><li>方法选标（_cmd指向的内容）</li></ul><p>这些参数帮助方法实现获得了消息表达式的信息。它们被认为是“隐藏”的，是因为它们并没有在在定义方法的源码中声明，而是在代码编译时是插入方法的实现中的。尽管这些参数没有被显示声明，但在源码中仍然可以引用它们（就像可以引用消息接收者对象的实例变量一样）。在方法中可以通过self来引用消息接收者，通过标选_cmd来引用方法本身。下面的例子很好的说明了这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)message &#123;</span><br><span class="line">    self.name = @&quot;James&quot;; //通过self关键字给当前对象的属性赋值</span><br><span class="line">    SEL currentSel = _cmd; //通过_cmd关键字取到当前函数对应的SEL</span><br><span class="line">    NSLog(@&quot;currentSel is: %s&quot;, (char *)currentSel);</span><br><span class="line">&#125;</span><br><span class="line">打印结果：ObjcRuntime[693:403] currentSel is: message</span><br></pre></td></tr></table></figure><p>当然，在这两参数中，self更有用，更常用一些。实际上，它是在方法实现中访问消息接收者对象的实例变量的途径。</p><h2 id="方法交换Swizzling"><a href="#方法交换Swizzling" class="headerlink" title="方法交换Swizzling"></a>方法交换Swizzling</h2><p>使用场景：系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。<br>方式一：继承系统的类，重写方法。<br>方式二：使用runtime，交换方法。<br>在Objective-C中调用一个方法，其实是向一个对象发送消息，而查找消息的唯一依据是selector的名字。所以，我们可以利用Objective-C的runtime机制，实现在运行时交换selector对应的方法实现以达到我们的目的。每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。我们先看看SEL与IMP之间的关系图：<br><img src="http://upload-images.jianshu.io/upload_images/1975901-b1d3cdf3d638b6c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>从上图可以看出来，每一个SEL与一个IMP一一对应，正常情况下通过SEL可以查找到对应消息的IMP实现。但是，现在我们要做的就是把链接线解开，然后链接到我们自定义的函数的IMP上。当然，交换了两个SEL的IMP，还是可以再次交换回来了。交换后变成这样的，如下图<br><img src="http://upload-images.jianshu.io/upload_images/1975901-e8f7ee567dfff051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>从图中可以看出，我们通过swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当我们调用selectorC，也就是给对象发送selectorC消息时，所查找到的对应的方法实现就是IMPn而不是IMPc了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIViewController+swizzling.h&quot;</span><br><span class="line">@implementation UIViewController(swizzling)</span><br><span class="line">//load方法会在类第一次加载的时候被调用，调用的时间比较靠前，适合在这个方法里做方法交换</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    //方法交换应该被保证，在程序中只会执行一次</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        //获得viewController的生命周期方法的selector</span><br><span class="line">        SEL systemSel = @selector(viewWillAppear:);</span><br><span class="line">        //自己实现的将要被交换的方法的selector</span><br><span class="line">        SEL swizzSel = @selector(swiz_viewWillAppear:);</span><br><span class="line">        //两个方法的Method</span><br><span class="line">        Method systemMethod = class_getInstanceMethod([self class], systemSel);</span><br><span class="line">        Method swizzMethod = class_getInstanceMethod([self class], swizzSel);</span><br><span class="line">        //首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败</span><br><span class="line">        BOOL isAdd = class_addMethod(self, swizzMethod, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));</span><br><span class="line">        </span><br><span class="line">        if (isAdd) &#123;</span><br><span class="line">            //如果成功，说明类中不存在这个方法的实现</span><br><span class="line">            //将被交换方法的实现替换到这个并不存在的实现</span><br><span class="line">            class_replaceMethod(self, swizzMethod, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //否则，交换两个方法的实现</span><br><span class="line">            method_exchangeImplementations(systemMethod, swizzMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)swiz_viewWillApper: (BOOL)animated &#123;</span><br><span class="line">    //这时候调用自己，看起来像死循环</span><br><span class="line">    //但是其实自己的实现已经被替换了</span><br><span class="line">    [self swiz_ViewWillAppear: animated];</span><br><span class="line">    NSLog(@&quot;swizzle&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在一个自己定义的viewController中重写viewWillAppear</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillAppear: (BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear: animated];</span><br><span class="line">    NSLog(@&quot;viewWillAppear&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置关联值"><a href="#设置关联值" class="headerlink" title="设置关联值"></a>设置关联值</h2><p>使用场景：现在你准备一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。给一个类声明属性，其实本质就是给这个类添加关联，并不会直接把这个值的内存空间添加到类存储空间。分类只能添加方法。<br><strong>设置关联值</strong><br>这种情况的一般解决办法就是继承。但是只增加一个属性，就去继承一个类，总觉得太麻烦。这个时候，runtime的关联属性就发挥它的作用了。<br><strong>添加关联对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)addAssociatedObject: (id)object &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">&#125;</span><br><span class="line">//获取关联对象</span><br><span class="line">- (id)getAssociatedObject &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，这里面我们把getAssociatedObject方法的地址作为唯一的key，_cmd代表当前调用方法的地址。</strong><br>参数说明：<br>object：与谁关联，通常是传self<br>key：唯一键，在获取值时通过该键获取，通常是使用static const void * 来声明<br>value：关联所设置的值<br>policy：内存管理策略，比如使用copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure><p><strong>获取关联值</strong><br>参数说明：<br>object：与谁关联，通常是传self，在设置关联时所指定的与哪个对象关联的那个对象<br>key：唯一键，在设置关联时所指定的键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br></pre></td></tr></table></figure><p><strong>取消关联</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure><p><strong>关联策略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0, //表示弱引用关联，通常是基本数据类型</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, //表示强引用关联对象，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3, //表示关联对象copy，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401, //表示强引用关联对象，不是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403 //表示关联对象copy，不是线程安全的</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //给系统NSObject类动态添加属性name</span><br><span class="line">    NSObject *objc = [[NSObject alloc] init];</span><br><span class="line">    objc.name = @&quot;123&quot;;</span><br><span class="line">    NSLog(@&quot;%@&quot;, objc.name);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//定义关联的key </span><br><span class="line">static const char *key = &quot;name&quot;; </span><br><span class="line"></span><br><span class="line">@implementation NSObject(Property)</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    //根据关联的key，获取关联的值。</span><br><span class="line">    return objc_getAssociatedObject(self, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName: (NSString *)name &#123;</span><br><span class="line">    //第一个参数：给对象添加关联</span><br><span class="line">    //第二个参数：关联的key，通过这个key获取</span><br><span class="line">    //第三个参数：关联的value</span><br><span class="line">    //第四个参数：关联的策略</span><br><span class="line">    objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h2><p>使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    Person *p = [[Person alloc] init]; //默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span><br><span class="line">    //动态添加方法就不会报错</span><br><span class="line">    [p performSelector: @selector(eat)];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person </span><br><span class="line"></span><br><span class="line">void(*)() </span><br><span class="line">//默认方法都有两个隐式参数</span><br><span class="line">void eat(id self, SEL sel) &#123;</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;, self, NSStringFromSelector(sel));</span><br><span class="line">&#125;</span><br><span class="line">// 当一个对象调用未实现的方法，会调用这个方法处理，并且会吧对应的方法列表传过来</span><br><span class="line">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod: (SEL)sel &#123;</span><br><span class="line">    if (sel == @selector(eat)) &#123;</span><br><span class="line">        //动态添加eat方法</span><br><span class="line">        //第一个参数：给哪个类添加方法</span><br><span class="line">        //第二个参数：添加方法的方法编号</span><br><span class="line">        //第三个参数：添加方法的函数实现（函数地址）</span><br><span class="line">        //第四个参数：函数的类型（返回值+参数类型）v:void  @:对象-&gt;self  :表示SEL-&gt;_cmd</span><br><span class="line">        class_addMethod(self, @selector(eat), eat, &quot;v@:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>模型属性，通常需要跟字典中的key一一对应<br>问题：一个一个的生成模型属性，很慢？<br>需求：能不能自动根据一个字典，生成对应的属性。<br>解决：提供一个分类，专门根据字典生成对应的属性字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject(Log)</span><br><span class="line">//自动打印属性字符串</span><br><span class="line">+ (void)resolveDict: (NSDictionary *)dict &#123;</span><br><span class="line">    //拼接属性字符串代码</span><br><span class="line">    NSMutableString *strM = [NSMutableString string];</span><br><span class="line">    //1、遍历字典，把字典中的所有key取出来，生成对应的属性代码</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id_Nonnull key, id_Nonnull obj, BOOL_Nonnull stop)&#123;</span><br><span class="line">    //类型经常变，抽出来</span><br><span class="line">        NSString *type;</span><br><span class="line">        if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123;</span><br><span class="line">            type = @&quot;NSString&quot;;</span><br><span class="line">        &#125; else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)]) &#123;</span><br><span class="line">            type = @&quot;NSArray&quot;;</span><br><span class="line">        &#125; else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)]) &#123;</span><br><span class="line">            type = @&quot;NSNumber&quot;;</span><br><span class="line">        &#125; else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)]) &#123;</span><br><span class="line">            type = @&quot;NSDictionary&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //属性字符串</span><br><span class="line">        NSString *str;</span><br><span class="line">        if ([type containsString: @&quot;NS&quot;]) &#123;</span><br><span class="line">            str = [NSString stringWithFormat: @&quot;@property(nonatomic, strong) %@ *%@;&quot;, type, key];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            str = [NSString stringWithFormat: @&quot;@property(nonatomic, assign) %@ %@;&quot;, type, key];</span><br><span class="line">        &#125;</span><br><span class="line">          //每生成属性字符串，就自动换行。</span><br><span class="line">          [strM appendFormat: @&quot;\n%@\n&quot;, str];</span><br><span class="line">          </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //把拼接好的字符串打印出来</span><br><span class="line">    NSLog(@&quot;%@&quot;, strM);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>字典转模型的方式一：KVC</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation Status</span><br><span class="line">+ (instancetype)statusWithDict: (NSDictionary *)dict &#123;</span><br><span class="line">    Status *status = [[self alloc] init];</span><br><span class="line">    [status setValuesForKeysWithDictionary: dict];</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>KVC字典转模型的弊端：必须保证，模型中的属性和字典中的key一一对应。如果不一致，就会调用<strong>[setValue:forUndefinedKey:]</strong>,报key找不到的错。<br>分析：模型中的属性和字典的ke不一一对应，系统就会调用<strong>[setValue:forUndefinedKey:]</strong>报错。<br>解决：重写对象的<strong>[setValue:forUndefinedKey:]</strong>，把系统方法覆盖，就能继续使用KVC，字典转模型了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue: (id)Value forUndefinedKey:(NSString *)key&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>字典转模型的方式二：Runtime</strong><br>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。<br>步骤：提供一个NSObject类，专门字典转模型，以后所有的模型都可以通过这个分类转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //解析plist文件</span><br><span class="line">    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil];</span><br><span class="line">    NSDictionary *statusDic = [NSDictionary dictionaryWithContentsOfFile:filePath];</span><br><span class="line">    //获取字典数组</span><br><span class="line">    NSArray *dictArr = statusDict[@&quot;statuses&quot;];</span><br><span class="line">    //自动生成模型的属性字符串</span><br><span class="line">    [NSObject resolveDict:dictArr[0][@&quot;user&quot;]];</span><br><span class="line">    _statuses = [NSMutableArray array];</span><br><span class="line">    //遍历字典数组</span><br><span class="line">    for(NSDictionary *dict in dictArr) &#123;</span><br><span class="line">        Status *status = [Status modelWithDict: dict];</span><br><span class="line">        [_statuses addObject:status];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSObject(Model)</span><br><span class="line">+ (instancetype)modelWithDict:(NSDictionary *)dict &#123;</span><br><span class="line">    // 思路：遍历模型中所有属性 -&gt;使用运行时</span><br><span class="line">    // 0、创建对应的对象</span><br><span class="line">    id objc = [[self alloc] init];</span><br><span class="line">    // 1、利用runtime给对象中成员属性赋值</span><br><span class="line">    // class_copyIvarList: 获取类中的所有成员属性</span><br><span class="line">    // Ivar: 成员属性的意思</span><br><span class="line">    // 第一个参数：表示获取哪个类中的成员属性</span><br><span class="line">    // 第二个参数：表示这个类有多少成员属性，传入一个int变量地址，会自动给这个变量赋值</span><br><span class="line">    // 返回值Ivar *：指的是一个ivar数组，会把所有的成员属性放在一个数组中，通过返回的数组就能全部获取到。</span><br><span class="line">    /*</span><br><span class="line">    Ivar ivar;</span><br><span class="line">    Ivar ivar1;</span><br><span class="line">    Ivar ivar2;</span><br><span class="line">    //定义一个ivar的数组a</span><br><span class="line">    Ivar a[] = &#123;ivar, ivar1, ivar2&#125;;</span><br><span class="line">    //用一个Ivar *指针指向数组的第一个元素</span><br><span class="line">    Ivar *ivarList = a;</span><br><span class="line">    //根据指针访问数组的第一个元素</span><br><span class="line">    ivarList[0];</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    unsigned int count;</span><br><span class="line">    //获取类中的所有成员属性 </span><br><span class="line">    Ivar *ivarList = class_copyIvarList(self, &amp;count);</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        //根据角标，从数组取出对应的成员属性</span><br><span class="line">        Ivar ivar = ivarList[i];</span><br><span class="line">        //获取成员属性名</span><br><span class="line">        NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        //处理成员属性名-&gt;字典中的key</span><br><span class="line">        //从第一个角标开始截取</span><br><span class="line">        NSString *key = [name substringFromIndex: 1];</span><br><span class="line">        //根据成员属性名去字典中查找对应的value</span><br><span class="line">        id value = dict[key];</span><br><span class="line">        //二级转换：如果字典中还有字典，也需要把对应的字典转成模型</span><br><span class="line">        //判断下value是否是字典</span><br><span class="line">        if ([value isKindOfClass: [NSDictionary class]]) &#123;</span><br><span class="line">            //字典转模型</span><br><span class="line">            //获取模型的类对象，调用modelWithDict</span><br><span class="line">            //模型的类名已知，就是成员属性的类型</span><br><span class="line">            //获取成员属性类型</span><br><span class="line">            NSString *type = [NSString stringWithUTF8String: ivar_getTypeEncoding(ivar)];</span><br><span class="line">            //生成的是这种&quot;@\&quot;User\&quot;&quot;类型 -&gt; @&quot;User&quot;  在OC字符串中\&quot; -&gt; \是转义的意思，不占用字符串</span><br><span class="line">            //裁剪类型字符串</span><br><span class="line">            NSRanger ranger = [type rangeOfString:@&quot;\&quot;&quot;];</span><br><span class="line">            type = [type substringFromIndex:ranger.location + ranger.length];</span><br><span class="line">            range = [type rangeOfString:@&quot;\&quot;&quot;];</span><br><span class="line">            //裁剪到哪个角标，不包括当前角标</span><br><span class="line">            type = [type substringToIndex:range.location];</span><br><span class="line">            //根据字符串类名生成类对象</span><br><span class="line">            Class modelClass = NSClassFromString(type);</span><br><span class="line">            if (modelClass) &#123;</span><br><span class="line">                //有对应的模型才需要转</span><br><span class="line">                //把字典转模型</span><br><span class="line">                value = [modelClass modelWithDict:value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //三级转换：NSArray中也是字典，把数组中的字典转换成模型</span><br><span class="line">        //判断值是否是数组</span><br><span class="line">        if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            //判断对应类有没有实现字典数组转模型数组的协议</span><br><span class="line">            if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</span><br><span class="line">                //转换成id类型，就能调用任何对象的方法id</span><br><span class="line">                id Self = self;</span><br><span class="line">                //获取数组中字典对应的模型</span><br><span class="line">                NSString *type = [Self arrayContainModelClass][key];</span><br><span class="line">                //生成模型</span><br><span class="line">                Class classModel = NSClassFromString(type);</span><br><span class="line">                NSMutableArray *arrM = [NSMutableArray array];</span><br><span class="line">                //遍历字典数组，生成模型数组</span><br><span class="line">                for (NSDictionary *dict in value) &#123;</span><br><span class="line">                    //字典转模型 </span><br><span class="line">                    id model = [classModel modelWithDict: dict];</span><br><span class="line">                    [arrM addObject: model];</span><br><span class="line">                &#125;</span><br><span class="line">                //把模型数组赋值给value</span><br><span class="line">                value = arrM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (value) &#123;</span><br><span class="line">            //有值，才需要给模型的属性赋值</span><br><span class="line">            //利用KVC给模型中的属性赋值</span><br><span class="line">            [objc setValue:value forKey:key];    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return objc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.jianshu.com/p/e071206103a4" target="_blank" rel="noopener">http://www.jianshu.com/p/e071206103a4</a><br><a href="http://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">http://www.jianshu.com/p/adf0d566c887</a><br><a href="http://www.jianshu.com/p/927c8384855a" target="_blank" rel="noopener">http://www.jianshu.com/p/927c8384855a</a><br><a href="http://chun.tips/2014/11/05/objc-runtime-1/#more" target="_blank" rel="noopener">http://chun.tips/2014/11/05/objc-runtime-1/#more</a><br><a href="http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/</a><br><a href="http://blog.csdn.net/wzzvictory/article/details/8624057" target="_blank" rel="noopener">http://blog.csdn.net/wzzvictory/article/details/8624057</a><br><a href="http://www.cocoachina.com/ios/20151208/14595.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20151208/14595.html</a><br><a href="http://www.jianshu.com/p/46dd81402f63" target="_blank" rel="noopener">http://www.jianshu.com/p/46dd81402f63</a></p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS深入学习 - 多线程</title>
      <link href="/2017-10-19-thread/"/>
      <url>/2017-10-19-thread/</url>
      <content type="html"><![CDATA[<h2 id="多线程简单介绍"><a href="#多线程简单介绍" class="headerlink" title="多线程简单介绍"></a>多线程简单介绍</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p><strong>1、什么是进程</strong><br>进程是指在系统中正在运行的一个应用程序，每个进程之间是相互独立的，每个进程均运行在其专用且受保护的内存空间内。<br><img src="http://images.cnitblog.com/i/450136/201406/241224432836121.png" alt=""><br>比如同时打开QQ、Xcode，系统会分别启动2个进程，通过“活动监视器”可以查看Mac系统中所开启的进程。<br><strong>2、什么是线程</strong><br>1个进程想要执行任务，必须得有线程(每一个进程至少要有一条线程即：主线程)，线程是进程的基本执行单元，一个进程(程序)的所有任务都在线程中执行，比如使用音乐播放器播放音乐，使用下载器下载电影，都需要在线程中执行。<br><img src="http://images.cnitblog.com/i/450136/201406/241225080809896.png" alt=""><br><strong>3、线程的串行</strong><br>1个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个的按照顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。比如在1个线程中下载3个文件(分别是文件A、文件B、文件C)。<br><img src="http://images.cnitblog.com/i/450136/201406/241225242528638.png" alt=""></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><strong>1、什么是多线程</strong><br>1个进程中可以开启多条线程，每条线程可以并行(同时)执行不同的任务。进程-&gt;车间，线程-&gt;车间工人。多线程技术可以提高程序的执行效率。比如同时开启3条线程分别下载3个文件(分别是文件A、文件B、文件C)。<br><img src="http://images.cnitblog.com/i/450136/201406/241226293143615.png" alt=""><br><img src="http://images.cnitblog.com/i/450136/201406/241227387673566.png" alt=""><br><strong>2、多线程原理</strong><br>同一时间，CPU只能处理1条线程，只有1条线程在工作(执行)。多线程并发(同时)执行，其实是CPU快速的在多线程之间调度(切换)。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。<br>思考：如果线程非常非常多，会发生什么情况？<br>CPU会在N多个线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频率会降低(线程的执行效率降低)。<br><strong>3、多线程的优缺点</strong><br>多线程的优点：<br>    能适当提高程序的执行效率<br>    能适当的提高资源的利用率(CPU、内存利用率)</p><p>多线程的缺点：<br>    开启线程需要占用一定的内存空间(默认情况下，主线程占用1M，子线程占用512k)，如果开启大量的线程，会占用大量的内存空间，CPU在调度线程上的开销就越大。程序设计更加复杂：比如线程之间的通信、多线程的数据共享。<br><strong>4、多线程在iOS开发中的应用</strong><br>主线程：一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”。<br>主线程的主要作用：<strong>显示/刷新UI界面；处理UI事件(比如点击事件、滚动事件、拖拽事件等)</strong><br>主线程的使用注意：<strong>别将比较耗时的操作放到主线程中。</strong>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的体验<br><strong>5、代码示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">- (IBAction)btnClick;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//按钮的点击事件</span><br><span class="line">- (IBAction)btnClick&#123;</span><br><span class="line">    //1、获取当前线程</span><br><span class="line">    NSThread *current = [NSThread currentThread];</span><br><span class="line">    //2、使用for循环执行一些耗时操作</span><br><span class="line">    for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">        //3、输出线程</span><br><span class="line">        NSLog(@&quot;btnClick---%d---%@&quot;, i, current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>执行效果：<br><img src="http://images.cnitblog.com/i/450136/201406/241235051118926.png" alt=""><br>说明：当点击按钮的时候，textView点击没反应<br><img src="http://images.cnitblog.com/i/450136/201406/241236350808178.png" alt=""><br>执行分析：等待主线程串行执行。<br><img src="http://images.cnitblog.com/i/450136/201406/241238095028893.png" alt=""><br>开启子线程<br><img src="http://images.cnitblog.com/i/450136/201406/241238382996357.png" alt=""></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h3><p><strong>资源共享</strong><br>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源。比如多个线程访问同一个对象、同一个变量、同一个文件。当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。<br>示例一：<br><img src="http://images.cnitblog.com/i/450136/201406/241255270965550.png" alt=""><br>示例二：<br><img src="http://images.cnitblog.com/i/450136/201406/241256038464378.png" alt=""><br>问题代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import &quot;ViewController.h&quot;</span><br><span class="line">@interface ViewController()</span><br><span class="line">//剩余票数</span><br><span class="line">@property(nonatomic, assign)int leftTicketsCount;</span><br><span class="line">@property(nonatomic, assign)NSThread *thread1;</span><br><span class="line">@property(nonatomic, assign)NSThread *thread2;</span><br><span class="line">@property(nonatomic, assign)NSThread *thread3;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //默认有20张票</span><br><span class="line">    self.leftTicketsCount = 10;</span><br><span class="line">    </span><br><span class="line">    //开启多个线程，模拟售票员售票</span><br><span class="line">    self.thread1 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread1.name = @&quot;售票员A&quot;;</span><br><span class="line">    </span><br><span class="line">    self.thread2 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread2.name = @&quot;售票员B&quot;;</span><br><span class="line">    </span><br><span class="line">    self.thread3 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread3.name = @&quot;售票员C&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sellTickets &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        //1、先检查票数</span><br><span class="line">        int count = self.leftTicketsCount;</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            //暂停一段时间</span><br><span class="line">            [NSThread sleepForTimeInterval: 0.002];</span><br><span class="line">            //2、票数-1</span><br><span class="line">            self.leftTicketsCount = count - 1;</span><br><span class="line">            //获取当前线程</span><br><span class="line">            NSThread *current = [NSThread currentThread];</span><br><span class="line">            NSLog(@&quot;%@--卖了一张票，还剩余%d张票&quot;, current, self.leftTicketsCount);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //退出线程</span><br><span class="line">            [NSThread exit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //开启多线程</span><br><span class="line">    [self.thread1 start];</span><br><span class="line">    [self.thread2 start];</span><br><span class="line">    [self.thread3 start];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>打印结果：<br><img src="http://images.cnitblog.com/i/450136/201406/241302364867997.png" alt=""></p><h3 id="安全隐患分析"><a href="#安全隐患分析" class="headerlink" title="安全隐患分析"></a>安全隐患分析</h3><p><img src="http://images.cnitblog.com/i/450136/201406/241303131584567.png" alt=""><br><img src="http://images.cnitblog.com/i/450136/201406/241303355028628.png" alt=""></p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>互斥锁使用格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(锁对象)&#123;</span><br><span class="line">    //需要锁定的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：锁定1份代码只用1把锁，用多把锁是无效的</strong><br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">//剩余票数</span><br><span class="line">@property(nonatomic, assign)int leftTicketsCount;</span><br><span class="line">@property(nonatomic, strong)NSThread *thread1;</span><br><span class="line">@property(nonatomic, strong)NSThread *thread2;</span><br><span class="line">@property(nonatomic, strong)NSThread *thread3;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //默认有20张票</span><br><span class="line">    self.leftTicketsCount = 20;</span><br><span class="line">    </span><br><span class="line">    //开启多个线程，模拟售票员售票</span><br><span class="line">    self.thread1 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread1.name = @&quot;售票员A&quot;;</span><br><span class="line">    </span><br><span class="line">    self.thread2 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread2.name = @&quot;售票员B&quot;;</span><br><span class="line">    </span><br><span class="line">    self.thread3 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread3.name = @&quot;售票员C&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sellTickets &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        @synchronized(self) &#123;</span><br><span class="line">            //只能加一把锁</span><br><span class="line">            //1、先检查票数</span><br><span class="line">            int count = self.leftTicketsCount;</span><br><span class="line">            </span><br><span class="line">            if (count &gt; 0) &#123;</span><br><span class="line">                //暂停一段时间</span><br><span class="line">                [NSThread sleepForTimeInterval: 0.002];</span><br><span class="line">                //2、票数-1</span><br><span class="line">                self.leftTicketsCount = count - 1;</span><br><span class="line">                //获取当前线程</span><br><span class="line">                NSThread *current = [NSThread currentThread];</span><br><span class="line">                NSLog(@&quot;%@--卖了一张票，还剩余%d张票&quot;, current, self.leftTicketsCount); </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //退出线程</span><br><span class="line">                [NSThread exit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //开启多线程</span><br><span class="line">    [self.thread1 start];</span><br><span class="line">    [self.thread2 start];</span><br><span class="line">    [self.thread3 start];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>执行效果图：<br><img src="http://images.cnitblog.com/i/450136/201406/241315433467454.png" alt=""></p><pre><code>互斥锁的优缺点优点：能有效防止因多线程抢夺资源造成的数据安全问题缺点：需要消耗大量的CPU资源互斥锁的使用前提：多条线程抢夺同一块资源相关专业术语：线程同步，多条线程按照顺序的执行任务。互斥锁，就是使用了线程同步技术。</code></pre><h3 id="原子和非原子属性"><a href="#原子和非原子属性" class="headerlink" title="原子和非原子属性"></a>原子和非原子属性</h3><p>OC在定义属性时有nonatomic和atomic两种选择<br>atomic：源自属性，为setter方法加锁（默认就是atomic）<br>nonatomic：非原子属性，不会为setter方法加锁</p><p>atomic加锁原理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(assign, atomic) int age;</span><br><span class="line">- (void)setAge:(int)age &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        _age  = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原子和非原子属性的选择：<br>    nonatomic和atomic对比<br>    atomic：线程安全，需要消耗大量的资源<br>    nonatomic：非线程安全，适合内存小的移动设备</p><pre><code>iOS开发的建议：所有的属性都声明为nonatomic尽量避免多线程抢夺同一块资源尽量加锁、资源抢夺的业务逻辑交给服务器处理，减小移动客户端的压力</code></pre><h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p>线程间通信：在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信。<br>线程通信间的体现：1个线程传递数据给另1个线程；在1个线程中执行完特定任务后，转到另1个线程继续执行任务。<br>线程间通信常用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br></pre></td></tr></table></figure><p>线程间通信示例-图片下载<br><img src="http://images.cnitblog.com/i/450136/201406/241326487366534.png" alt=""><br>代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">@interface ViewController()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIImageView *iconView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //在子线程中调用download方法下载</span><br><span class="line">    [self performSelectorInBackground:@selector(download) withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)download &#123;</span><br><span class="line">    //1、根据URL下载图片</span><br><span class="line">    //从网络中下载图片</span><br><span class="line">    NSURL *urlstr = [NSURL URLWithString:@&quot;fdsf&quot;];</span><br><span class="line">    //把图片转换为二进制的数据</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:urlstr];//这一操作会比较耗时</span><br><span class="line">    //把数据转换成图片</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    //2、回到主线程中设置图片</span><br><span class="line">    [self performSelectorOnMainThread:@selector(settingImage:) withObject:image waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置显示图片</span><br><span class="line">- (void)settingImage:(UIImage *)image &#123;</span><br><span class="line">    self.iconView.image = image;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>代码2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;NSData.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIImageView *iconView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan: (NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //在子线程中调用download方法下载图片</span><br><span class="line">    [self performSelectorInBackground:@selector(download) withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)download &#123;</span><br><span class="line">    //1、根据url下载图片</span><br><span class="line">    //从网络下载图片</span><br><span class="line">    NSURL *urlstr = [NSURL URLWithString:@&quot;fdsf&quot;];</span><br><span class="line">    //把图片转换为二进制的数据</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:urlstr];//这一行操作比较耗时</span><br><span class="line">    //把数据转成图片</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    </span><br><span class="line">    //2、回到主线程设置图片</span><br><span class="line">    //第一种方式</span><br><span class="line">    //[self performSelectorOnMainThread:@selector(settingImage:) withObject:image waitUntilDone:NO];</span><br><span class="line">    //第二种方式</span><br><span class="line">    //    [self.iconView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:NO];</span><br><span class="line">    //第三种方式</span><br><span class="line">    [self.iconView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置显示图片</span><br><span class="line">//- (void)settingImage: (UIImage *)image &#123;</span><br><span class="line">//    self.iconView.image = image;</span><br><span class="line">//&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="多线程之-pthread、NSThread"><a href="#多线程之-pthread、NSThread" class="headerlink" title="多线程之[pthread、NSThread]"></a>多线程之[pthread、NSThread]</h2><h3 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h3><p>pthread简单介绍一下，pthread是一套通用的多线程API，可以在Unix/Linux/Windows等系统跨平台使用，使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，所以我们在iOS开发中几乎不使用pthread。</p><blockquote><p>引自<a href="https://baike.baidu.com/item/Pthread" target="_blank" rel="noopener">百度百科</a><br>POSIX线程(POSIX threads)，简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统(Unix、Linux、Mac OS X等)中，都使用Pthreads作为操作系统的线程。Windows操作系统也有其移植版pthreads-win32.</p><p>引自<a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">维基百科</a><br>POSIX线程(英语：POSIX Threads，常被缩写为Pthreads)是POSIX的线程标准，定义了创建和操纵线程的一套API。<br>实现POSIX线程标准的库常被称为Pthreads，一般基于Unix-like POSIX系统，如Linux、Solaris。但是Microsoft Windows上的实现也存在，例如直接使用Windows API实现的第三方库pthreads-w32；而利用windows的SFU/SUA子系统，则可以使用微软提供的一部分原生POSIX API。</p></blockquote><p><strong>pthread的使用方法</strong></p><ol><li>首先要包含头文件<code>#import &lt;pthread.h&gt;</code></li><li>其次要创建线程，并开启线程执行任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建线程：定义一个pthread_t类变量</span><br><span class="line">pthread_t thread;</span><br><span class="line">//开启线程--执行任务</span><br><span class="line">pthread_create(&amp;thread, NULL, run, NULL);</span><br><span class="line"></span><br><span class="line">void *run(void *param)&#123;</span><br><span class="line">    //新线程调用方法，里边为需要执行的任务</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_create(&amp;thread, NULL, run, NULL);</code>中各项参数含义：</p><ul><li>第一个参数&amp;thread是线程对象</li><li>第二个和第四个是线程属性，可赋值NULL</li><li>第三个run表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)</li></ul><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p> NSThread是苹果官方提供的，使用起来比pthread更加面向对象，简单易用，可以直接操作线程对象。不过也需要程序自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用NSThread。比如我们会经常调用<code>[NSThread currentThread]</code>来显示当前的进程信息。<br> 下边我们说说NSThread如何使用</p><p> <strong>1、创建、启动线程</strong></p><ul><li>先创建线程，再启动线程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">[thread start]; //线程一启动，就会在线程thread中执行self的run方法。</span><br></pre></td></tr></table></figure><ul><li>创建线程后自动启动线程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">* 隐式创建并启动线程</span><br></pre></td></tr></table></figure><p>[self performSelectorInBackground:@selector(run) withObject:nil];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**2、线程相关用法**</span><br></pre></td></tr></table></figure></p><p>//获得主线程</p><ul><li>(NSThread *)mainThread;<br>//判断是否为主线程(对象方法)</li></ul><ul><li>(BOOL)isMainThread;<br>//判断是否为主线程(类方法)</li></ul><ul><li>(BOOL)isMainThread;<br>//判断是否为主线程</li><li>(BOOL)isMultiThreaded;<br>//获取当前线程<br>NSThread *current = [NSThread currentThread];<br>//线程的名字-setter方法</li></ul><ul><li>(void)setName:(NSString *)n;<br>//线程的名字-getter方法</li><li>(NSString *)name;<br>//线程是否在执行</li><li>(BOOL)isExecuting;<br>//线程是否被取消</li><li>(BOOL)isCancelled;<br>//线程是否完成</li><li>(BOOL)isFinished;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**3、线程状态控制方法**</span><br><span class="line"></span><br><span class="line">* 启动线程方法</span><br></pre></td></tr></table></figure><ul><li>(void)start;<br>//线程进入就绪状态-&gt;运行状态。当线程任务执行完毕，自动进入死亡状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 阻塞(暂停)线程方法</span><br></pre></td></tr></table></figure></li></ul><ul><li>(void)sleepUntilDate:(NSDate *)date;</li><li><p>(void)sleepForTimeInterval:(NSTimeInterval)ti;<br>//线程进入阻塞状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 强制停止线程</span><br></pre></td></tr></table></figure></li><li><p>(void)exit;<br>//线程进入死亡状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">**4、线程的状态转换**</span><br><span class="line">当我们新建一条线程`NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];`,在内存中表现为：</span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1877784-557cafe9005287bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">当调用`[thread start];`后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示：</span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1877784-60021d1165ba05d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">当然，可调度线程池中，会有其他的线程对象，如下图所示：（在这里我们只关心左边的线程对象）</span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1877784-7c39f9d019cea9ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">下边我们来看看当前线程的状态转换：</span><br><span class="line"></span><br><span class="line">* 如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</span><br><span class="line">* 如果CPU在运行当前线程对象的时候调用了sleep方法/等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时/得到同步锁，则回到就绪状态。</span><br><span class="line">* 如果CPU在运行当前线程对象的时候，线程任务执行完毕/异常强制退出，则当前线程对象进入死亡状态。</span><br><span class="line"></span><br><span class="line">只看文字可能不太好理解，具体当前线程对象的状态变化如下图所示：</span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1877784-18eab813719d579d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">## GCD</span><br><span class="line">### GCD简介</span><br><span class="line">什么是GCD呢？我们先来看看百度百科的解释简单了解下概念</span><br><span class="line">&gt;引自[百度百科](https://baike.baidu.com/item/GCD)</span><br><span class="line">&gt;Grand Central Dispatch(GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的任务。在Mac OS X10.6雪豹中首次推出的，也可以在iOS4及以上版本使用</span><br><span class="line"></span><br><span class="line">**为什么要用GCD呢？**</span><br><span class="line">因为GCD有很多好处啊，具体如下：</span><br><span class="line"></span><br><span class="line">* GCD可用于多核的并行运算</span><br><span class="line">* GCD会自动利用更多的CPU内核（比如双核、四核）</span><br><span class="line">* GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</span><br><span class="line">* 程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</span><br><span class="line"></span><br><span class="line">既然GCD有这么多的好处，那下面我们就来系统的学习一下GCD的使用方法。</span><br><span class="line">### 任务和队列</span><br><span class="line">学习GCD之前，先来了解GCD中两个核心概念：任务和队列。</span><br><span class="line">**任务：**就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在GCD中是放在block中的。执行任务有两种方式：**同步执行**和**异步执行**。两者的主要区别是：是否具有开启新线程的能力。</span><br><span class="line"></span><br><span class="line">* 同步执行(sync)：只能在当前线程中执行任务，不具备开启新线程的能力。</span><br><span class="line">* 异步执行(async)：可以在新的线程中执行任务，具备开启新线程的能力。</span><br><span class="line"></span><br><span class="line">**队列：**这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO(先进先出)的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有两种队列：**串行队列**和**并行队列**。</span><br><span class="line"></span><br><span class="line">* 并行队列(Concurrent Dispatch Queue)：可以让多个任务并行（同时）执行（自动开启多个线程同时执行任务）。</span><br><span class="line"> &gt; 并行功能只有在异步（dispatch_async）函数下才有效</span><br><span class="line"> </span><br><span class="line">* 串行队列（Serial Dispatch Queue）：让任务一个接一个的执行（一个任务执行完毕后，再执行下一个任务）</span><br><span class="line"></span><br><span class="line">### GCD的使用步骤</span><br><span class="line">GCD的使用步骤其实很简单，只有两步。</span><br><span class="line"></span><br><span class="line">1. 创建一个队列（串行队列或者并行队列）</span><br><span class="line">2. 将任务添加到队列中，然后系统就会根据任务类型执行任务（同步执行或者异步执行）</span><br><span class="line"></span><br><span class="line">下边来看看队列的创建方法和任务的创建方法</span><br><span class="line"></span><br><span class="line">**1、队列的创建方法**</span><br><span class="line"></span><br><span class="line">* 可以使用`dispatch_queue_create`来创建对象，需要传入两个参数，第一个参数表示队列的唯一标识符，用于debug，可为空；第二个参数用来识别是串行队列还是并行队列。`DISPATCH_QUEUE_SERIAL`表示串行队列，`DISPATCH_QUEUE_CONCURRENT`表示并行队列。</span><br></pre></td></tr></table></figure></li></ul><p>//串行队列的创建方法<br>dispatch_queue_t queue = dispatch_queue_create(“test.queue”, DISPATCH_QUEUE_SERIAL);<br>//并行队列的创建方法<br>dispatch_queue_t queue = dispatch_queue_create(“test.queue”, DISPATCH_QUEUE_CONCURRENT);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 对于并行队列，还可以使用`dispatch_get_global_queue`来创建**全局并行队列**。GCD默认提供了全局的并行队列，需要传入两个参数。第一个参数表示队列优先级，一般用`DISPATCH_QUEUE_PRIORITY_DEFAULT`。第二个参数暂时没用，用0表示即可。</span><br><span class="line"></span><br><span class="line">**2、任务的创建方法**</span><br></pre></td></tr></table></figure></p><p>//同步执行任务创建方法<br>dispatch_sync(queue, ^{<br>    NSLog(@”%@”, [NSThread currentThread]);//这里放任何代码<br>});</p><p>//异步执行任务创建方法<br>dispatch_async(queue, ^{<br>    NSLog(@”%@”, [NSThread currentThread]);//这里放任何代码<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">虽然使用GCD只需要两步，但是既然我们有两种队列，两种任务执行方式，那么我们就有了4种不同的组合方式。这四种不同的组合方式是：</span><br><span class="line">&gt;1、并行队列 + 同步执行</span><br><span class="line">&gt;2、并行队列 + 异步执行</span><br><span class="line">&gt;3、串行队列 + 同步执行</span><br><span class="line">&gt;4、串行队列 + 异步执行</span><br><span class="line"></span><br><span class="line">实际上，我们还有一种特殊的队列是主队列，那样就有6种不同的组合方式了。</span><br><span class="line">&gt;5、主队列 + 同步执行</span><br><span class="line">&gt;6、主队列 + 异步执行</span><br><span class="line"></span><br><span class="line">那么这几种不同组合方式各有什么区别呢？这里为了方便，先上结果，再来讲解。为图省事儿，直接查看表格结果。</span><br><span class="line"></span><br><span class="line">              |            并行队列      |          串行队列         |      主队列       </span><br><span class="line">-------------|--------------------------| ------------------------|------------------------</span><br><span class="line"> 同步(sync)   | 没有开启新线程，串行执行任务 | 没有开启新线程，串行执行任务 | 没有开启新线程，串行执行任务</span><br><span class="line"> 异步(async)  | 有开启新线程，并行执行任务   | 有开启新线程(1条)，串行执行任务 | 没有开启新线程，串行执行任务</span><br><span class="line"></span><br><span class="line">下边我们来分别看看那这几种组合方式的使用方法</span><br><span class="line"></span><br><span class="line">### GCD的基本使用</span><br><span class="line">并行队列的两种使用方法：</span><br><span class="line"></span><br><span class="line">**1、并行队列 + 同步执行**</span><br><span class="line"></span><br><span class="line">* 不会开启新线程，执行完一个任务，再执行下一个任务</span><br></pre></td></tr></table></figure></p><ul><li><p>(void)syncConcurrent {<br>  NSLog(@”syncConcurrent—begin”);<br>  dispatch_queue_t queue = dispatch_queue_create(“test.queue”, DISPATCH_QUEUE_CONCURRENT);<br>  dispatch_sync(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_sync(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_sync(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });</p><p>  NSLog(@”syncConcurrent—end”);</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输出结果：</span><br><span class="line">2016-09-03 19:22:27.577 GCD[11557:1897538] syncConcurrent---begin</span><br><span class="line">2016-09-03 19:22:27.578 GCD[11557:1897538] 1------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:22:27.578 GCD[11557:1897538] 1------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:22:27.578 GCD[11557:1897538] 2------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:22:27.579 GCD[11557:1897538] 2------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:22:27.579 GCD[11557:1897538] 3------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:22:27.579 GCD[11557:1897538] 3------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:22:27.579 GCD[11557:1897538] syncConcurrent---end</span><br><span class="line"></span><br><span class="line">* 从**并行队列 + 同步执行**中可以看到，所有任务都是在主线程中执行的。由于只有一个线程，所以任务只能一个一个的执行。</span><br><span class="line">* 同时我们还可以看到，所有任务都在打印的**syncConcurrent---begin**和**syncConcurrent---end**之间，这说明任务是添加到队列中么马上执行的。</span><br><span class="line"></span><br><span class="line">**2、并行队列 + 异步执行**</span><br><span class="line"></span><br><span class="line">* 可同时开启多线程，任务交替完成</span><br></pre></td></tr></table></figure><ul><li><p>(void)asyncConcurrent {<br>  NSLog(@”asyncConcurrent—begin”);<br>  dispatch_queue_t queue = dispatch_queue_create(“test.queue”, DISPATCH_QUEUE_CONCURRENT);<br>  dispatch_async(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_async(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_async(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });</p><p>  NSLog(@”asyncConcurrent—end”);</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 输出结果：</span><br><span class="line">2016-09-03 19:27:31.503 GCD[11595:1901548] asyncConcurrent---begin</span><br><span class="line">2016-09-03 19:27:31.504 GCD[11595:1901548] asyncConcurrent---end</span><br><span class="line">2016-09-03 19:27:31.504 GCD[11595:1901626] 1------&lt;NSThread: 0x7f8309c22080&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:27:31.504 GCD[11595:1901625] 2------&lt;NSThread: 0x7f8309f0b790&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2016-09-03 19:27:31.504 GCD[11595:1901855] 3------&lt;NSThread: 0x7f8309e1a950&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-03 19:27:31.504 GCD[11595:1901626] 1------&lt;NSThread: 0x7f8309c22080&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:27:31.504 GCD[11595:1901625] 2------&lt;NSThread: 0x7f8309f0b790&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2016-09-03 19:27:31.505 GCD[11595:1901855] 3------&lt;NSThread: 0x7f8309e1a950&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">* 在**并行队列 + 异步执行**中可以看出，除了主线程，又开启了3个线程，并且交替着同时执行。</span><br><span class="line">* 另一方面可以看出，所有任务是在打印的**asyncConcurrent---begin** 和 **asyncConcurrent---end**之后才开始执行的。说明任务不是马上执行的，而是将所有任务添加到队列之后才开始异步执行的。</span><br><span class="line"></span><br><span class="line">接下来看看串行队列的执行方法。</span><br><span class="line"></span><br><span class="line">**3、串行队列 + 同步执行**</span><br><span class="line"></span><br><span class="line">* 不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务</span><br></pre></td></tr></table></figure><ul><li><p>(void)syncSerial{<br>  NSLog(@”syncSerial—-begin”);<br>  dispatch_queue_t queue = dispatch_queue_create(“test.queue”, DISPATCH_QUEUE_SERIAL);<br>  dispatch_sync(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_sync(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_sync(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });</p><p>  NSLog(@”syncSerial—end”);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输出结果为：</span><br><span class="line">2016-09-03 19:29:00.066 GCD[11622:1903904] syncSerial---begin</span><br><span class="line">2016-09-03 19:29:00.067 GCD[11622:1903904] 1------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:29:00.067 GCD[11622:1903904] 1------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:29:00.067 GCD[11622:1903904] 2------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:29:00.067 GCD[11622:1903904] 2------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:29:00.067 GCD[11622:1903904] 3------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:29:00.068 GCD[11622:1903904] 3------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:29:00.068 GCD[11622:1903904] syncSerial---end</span><br><span class="line"></span><br><span class="line">* 在**串行队列 + 同步执行**可以看到，所有任务都是在主线程中执行的，并没有开启新的线程。而且由于串行队列，所以按顺序一个一个执行。</span><br><span class="line">* 同时我们还可以看到，所有任务都在打印的**syncSerial---begin**和**syncSerial---end**之间，这说明任务是添加到队列中马上执行的。</span><br><span class="line"></span><br><span class="line">**4、串行队列 + 异步执行**</span><br><span class="line"></span><br><span class="line">* 会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</span><br></pre></td></tr></table></figure></li><li><p>(void)asyncSerial{<br>  NSLog(@”asyncSerial—begin”);</p><p>  dispatch_queue_t queue = dispatch_queue_create(“test.queue”, DISPATCH_QUEUE_SERIAL);</p><p>  dispatch_async(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_async(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_async(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });</p><p>  NSLog(@”asyncSerial—end”);<br>}</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输出结果为：</span><br><span class="line">2016-09-03 19:30:08.363 GCD[11648:1905817] asyncSerial---begin</span><br><span class="line">2016-09-03 19:30:08.364 GCD[11648:1905817] asyncSerial---end</span><br><span class="line">2016-09-03 19:30:08.364 GCD[11648:1905895] 1------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:30:08.364 GCD[11648:1905895] 1------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:30:08.364 GCD[11648:1905895] 2------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:30:08.364 GCD[11648:1905895] 2------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:30:08.365 GCD[11648:1905895] 3------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:30:08.365 GCD[11648:1905895] 3------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">* 在**串行队列 + 异步执行**可以看到，开启了一个新线程，但是任务还是串行，所以任务是一个一个执行的。</span><br><span class="line">* 另一方面可以看出，所有任务是在打印的**asyncSerial---begin** 和 **asyncSerial---end**之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</span><br><span class="line"></span><br><span class="line">下面我们看看特殊的队列---**主队列**</span><br><span class="line"></span><br><span class="line">* 主队列：GCD自带的一种特殊的**串行队列**</span><br><span class="line">&gt;所有放在主队列中的任务，都会放到主线程中执行。</span><br><span class="line">&gt;可使用`dispatch_get_main_queue()`获得主队列</span><br><span class="line"></span><br><span class="line">我们再看看主队列的两种组合方式</span><br><span class="line"></span><br><span class="line">**5、主队列 + 同步执行**</span><br><span class="line"></span><br><span class="line">* 互等卡住不可行（在主线程中调用）</span><br></pre></td></tr></table></figure><ul><li><p>(void)syncMain {<br>  NSLog(@”syncMain—begin”);<br>  dispatch_queue_t = dispatch_get_main_queue();<br>  dispatch_sync(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_sync(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_sync(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });   </p><p>  NSLog(@”syncMain—end”);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输出结果</span><br><span class="line">2016-09-03 19:32:15.356 GCD[11670:1908306] syncMain---begin</span><br><span class="line"></span><br><span class="line">这时候，我们惊奇的发现，在主线程中使用**主队列 + 同步执行**，任务不再执行了，而且**syncMain---end**也没有打印。这是为什么呢？</span><br><span class="line"></span><br><span class="line">这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主队列中，它就会立马执行。但是主线程现在在处理**syncMain**方法，所以任务需要等**syncMain**执行完才能执行。而**syncMain**执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个和第三个任务。</span><br><span class="line"></span><br><span class="line">那么，现在的情况就是**syncMain**方法和第一个任务都在等对方执行完毕。这样大家互相等待。所以就卡住了，所以我们的任务执行不了，而且**syncMain--end**也没有打印。</span><br><span class="line"></span><br><span class="line">如果不在主线程中调用，而在其他线程中调用会如何呢？</span><br><span class="line"></span><br><span class="line">* 不会开启新线程，执行完一个任务，再执行下一个任务(在其他线程中调用)</span><br></pre></td></tr></table></figure></li></ul><p>dispatch_queue_t queue = dispatch_queue_create(“test.queue”, DISPATCH_QUEUE_CONCURRENT);</p><p>dispatch_async(queue, ^{<br>    [self syncMain];<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-03 19:32:45.496 GCD[11686:1909617] syncMain---begin</span><br><span class="line">2016-09-03 19:32:45.497 GCD[11686:1909374] 1------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:32:45.498 GCD[11686:1909374] 1------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:32:45.498 GCD[11686:1909374] 2------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:32:45.498 GCD[11686:1909374] 2------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:32:45.499 GCD[11686:1909374] 3------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:32:45.499 GCD[11686:1909374] 3------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:32:45.499 GCD[11686:1909617] syncMain---end</span><br><span class="line"></span><br><span class="line">* 在其他线程中使用**主队列+同步执行**可看到：所有的任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按照顺序一个一个执行。</span><br><span class="line">* 同时我们还可以看到，所有任务都在打印的**syncConcurrent---begin**和**syncConcurrent---end**之间，这说明任务是添加到队列中马上执行的。</span><br><span class="line"></span><br><span class="line">**6、主队列 + 异步执行**</span><br><span class="line"></span><br><span class="line">* 只在主线程中执行任务，执行完一个任务，再执行下一个任务</span><br></pre></td></tr></table></figure></p><ul><li><p>(void)asyncMain {<br>  NSLog(@”asyncMain–begin”);<br>  dispatch_queue_t queue = dispatch_get_main_queue();</p><p>  dispatch_async(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_async(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });<br>  dispatch_async(queue, ^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);}</code></pre><p>  });  </p><p>  NSLog(@”asyncMain—end”);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-03 19:33:54.995 GCD[11706:1911313] asyncMain---begin</span><br><span class="line">2016-09-03 19:33:54.996 GCD[11706:1911313] asyncMain---end</span><br><span class="line">2016-09-03 19:33:54.996 GCD[11706:1911313] 1------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:33:54.997 GCD[11706:1911313] 1------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:33:54.997 GCD[11706:1911313] 2------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:33:54.997 GCD[11706:1911313] 2------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:33:54.997 GCD[11706:1911313] 3------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:33:54.997 GCD[11706:1911313] 3------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br><span class="line">* 我们发现所有任务都在主线程中，虽然异步执行，具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。</span><br><span class="line">* 另一方面可以看出，所有任务是在打印的**asyncMain---begin**和**asyncMain---end**之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</span><br><span class="line"></span><br><span class="line">弄懂了难理解、绕来绕去的**队列 + 任务**之后，我们来看看一个简单的东西--GCD线程之间的通信</span><br><span class="line"></span><br><span class="line">### GCD线程之间的通讯</span><br><span class="line">在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其它线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</span><br></pre></td></tr></table></figure></li></ul><p>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    for (int i = 0; i &lt; 2; ++i) {<br>        NSLog(@”1------%@”,[NSThread currentThread]);<br>    }</p><pre><code>// 回到主线程dispatch_async(dispatch_get_main_queue(), ^{    NSLog(@&quot;2-------%@&quot;,[NSThread currentThread]);});</code></pre><p>});</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-03 19:34:59.165 GCD[11728:1913039] 1------&lt;NSThread: 0x7f8319c06820&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:34:59.166 GCD[11728:1913039] 1------&lt;NSThread: 0x7f8319c06820&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:34:59.166 GCD[11728:1912961] 2-------&lt;NSThread: 0x7f8319e00560&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br><span class="line">* 可以看到在其他线程中先执行操作，执行完了之后回到主线程执行主线程的相应操作。</span><br><span class="line"></span><br><span class="line">### GCD其他方法</span><br><span class="line">**1、GCD的栅栏方法 `dispatch_barrier_async`**</span><br><span class="line"></span><br><span class="line">* 我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于**栅栏**一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到`dispatch_barrier_async`方法在两个操作组间形成栅栏。</span><br></pre></td></tr></table></figure><ul><li><p>(void)barrier<br>{<br>  dispatch_queue_t queue = dispatch_queue_create(“12312312”, DISPATCH_QUEUE_CONCURRENT);</p><p>  dispatch_async(queue, ^{</p><pre><code>NSLog(@&quot;----1-----%@&quot;, [NSThread currentThread]);</code></pre><p>  });<br>  dispatch_async(queue, ^{</p><pre><code>NSLog(@&quot;----2-----%@&quot;, [NSThread currentThread]);</code></pre><p>  });</p><p>  dispatch_barrier_async(queue, ^{</p><pre><code>NSLog(@&quot;----barrier-----%@&quot;, [NSThread currentThread]);</code></pre><p>  });</p><p>  dispatch_async(queue, ^{</p><pre><code>NSLog(@&quot;----3-----%@&quot;, [NSThread currentThread]);</code></pre><p>  });<br>  dispatch_async(queue, ^{</p><pre><code>NSLog(@&quot;----4-----%@&quot;, [NSThread currentThread]);</code></pre><p>  });<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输出结果：</span><br><span class="line">2016-09-03 19:35:51.271 GCD[11750:1914724] ----1-----&lt;NSThread: 0x7fb1826047b0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:35:51.272 GCD[11750:1914722] ----2-----&lt;NSThread: 0x7fb182423fd0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-03 19:35:51.272 GCD[11750:1914722] ----barrier-----&lt;NSThread: 0x7fb182423fd0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-03 19:35:51.273 GCD[11750:1914722] ----3-----&lt;NSThread: 0x7fb182423fd0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-03 19:35:51.273 GCD[11750:1914724] ----4-----&lt;NSThread: 0x7fb1826047b0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">* 可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</span><br><span class="line"></span><br><span class="line">**2、GCD延时执行方法 dispatch_after**</span><br><span class="line"></span><br><span class="line">* 当我们需要延迟执行一段代码时，就需要用到GCD的`dispatch_after`方法</span><br></pre></td></tr></table></figure></li></ul><p>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<br>    // 2秒后异步执行这里的代码…<br>   NSLog(@”run—–”);<br>});</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**3、GCD的一次性代码（只执行一次）`dispatch_once`**</span><br><span class="line"></span><br><span class="line">*我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了GCD的`dispatch_once`方法。使用`dispatch_once`函数能保证某段代码在程序运行过程中只执行1次。</span><br></pre></td></tr></table></figure><p>static dispatch_once_t onceToken;<br>dispatch_once(&amp;onceToken, ^{<br>    // 只执行1次的代码(这里面默认是线程安全的)<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**4、GCD的快速迭代方法 `dispatch_apply`**</span><br><span class="line"></span><br><span class="line">* 通常我们会for循环遍历，但是GCD给我们提供了快速迭代的方法`dispatch_apply`，使我们可以同时遍历。`dispatch_apply`可以同时遍历多个数字。</span><br></pre></td></tr></table></figure></p><p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p><p>dispatch_apply(6, queue, ^(size_t index) {<br>    NSLog(@”%zd------%@”,index, [NSThread currentThread]);<br>});</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-03 19:37:02.250 GCD[11764:1915764] 1------&lt;NSThread: 0x7fac9a7029e0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:37:02.250 GCD[11764:1915885] 0------&lt;NSThread: 0x7fac9a614bd0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-03 19:37:02.250 GCD[11764:1915886] 2------&lt;NSThread: 0x7fac9a542b20&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-03 19:37:02.251 GCD[11764:1915764] 4------&lt;NSThread: 0x7fac9a7029e0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-03 19:37:02.250 GCD[11764:1915884] 3------&lt;NSThread: 0x7fac9a76ca10&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2016-09-03 19:37:02.251 GCD[11764:1915885] 5------&lt;NSThread: 0x7fac9a614bd0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">从输出结果中前边的时间中可以看出，几乎是同时便利的。</span><br><span class="line"></span><br><span class="line">**5、GCD的队列组 `dispatch_group`**</span><br><span class="line"></span><br><span class="line">*有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后再回到主线程执行操作。这时候我们可以用到GCD的队列组。</span><br><span class="line"></span><br><span class="line">1. 我们可以先把任务放到队列中，然后将队列放入队列组中</span><br><span class="line">2. 调用队列组的`dispatch_group_notify`回到主线程执行操作。</span><br></pre></td></tr></table></figure><p>dispatch_group_t group =  dispatch_group_create();</p><p>dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    // 执行1个耗时的异步操作<br>});</p><p>dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    // 执行1个耗时的异步操作<br>});</p><p>dispatch_group_notify(group, dispatch_get_main_queue(), ^{<br>    // 等前面的异步操作都执行完毕后，回到主线程…<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**6、GCD dispatch_semaphore 信号量**</span><br><span class="line">在GCD中提供了一种信号机制，也可以解决资源抢占问题（和同步锁的机制并不一样）。</span><br><span class="line"></span><br><span class="line">GCD中信号量是`dispatch_semaphore_t`类型，支持信号通知和信号等待。每当发送一个信号通知，则信号量+1，每当发送一个等待信号时信号量-1。如果信号量为0则信号会处于等待状态，直到信号量大于0开始执行。根据这个原理我们可以初始化一个信号量变量，默认信号量设为1，每当有线程进入“加锁代码”之后就调用信号等待命令（此时信号量为0）开始等待，此时其他线程无法加入，执行完毕之后发送信号通知（此时信号量为1），其他线程开始进入执行，如此就达到了线程同步的目的。</span><br></pre></td></tr></table></figure></p><p>dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p><pre><code>//设置等待超时时间（5秒）dispatch_time_t timeOutCount = dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC);//设置等待超时时间(一直等下去)//dispatch_time_t timeOutCount = DISPATCH_TIME_FOREVER;//初始化信号量,参数是信号量初始值dispatch_semaphore_t semaphore= dispatch_semaphore_create(1);dispatch_async(globalQueue, ^{    if (dispatch_semaphore_wait(semaphore, timeOutCount) != 0) {        //等待超时后处理        //show error alertView on main Thread or something else...    } else {        //&quot;加锁代码&quot;        //do something...        dispatch_semaphore_signal(semaphore);//信号通知（信号量+1）    }});</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述代码中用到的三个重要函数的具体介绍：</span><br><span class="line"></span><br><span class="line">1. `dispatch_semaphore_create()` 创建信号量。传入的参数为long型，且必须大于或者等于0，否则函数返回NULL。</span><br><span class="line"></span><br><span class="line">2. `dispatch_semaphore_wait()` 方法为信号等待。如果信号量值为0，那么这个函数就阻塞当前线程等待timeOutCount,如果等待期间信号量大于0，则开始执行“加锁代码”，同时会使信号量-1。这个方法的返回值是当成功时则返回0，超时失败时则返回非0值。</span><br><span class="line"></span><br><span class="line">3. `dispatch_semaphore_signal()` 方法会使信号量+1。返回值为long类型，当返回值为0时表示当前并没有线程等待其处理的信号量，其处理的信号量的值加1即可。当返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程（当线程有优先级时，唤醒优先级最高的线程，否则随机唤醒）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## NSOperation</span><br><span class="line">### NSOperation简介</span><br><span class="line">NSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD更高一层的封装，但是比GCD更简单易用，代码可读性也高。</span><br><span class="line">NSOperation需要配合NSOperationQueue来实现多线程。**因为默认情况下，NSOperation单独使用时系统同步执行操作，并没有开辟新线程的能力，只有配合NSOperationQueue才能实现异步操作。**</span><br><span class="line">因为NSOperation是基于GCD的，那么使用起来也和GCD差不多，其中，NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。NSOperation实现多线程的使用步骤分为三步：</span><br><span class="line"></span><br><span class="line">1. 创建任务：现将需要执行的操作封装到一个NSOperation对象中。</span><br><span class="line">2. 创建队列：创建NSOperationQueue对象。</span><br><span class="line">3. 将任务加到队列中：然后将NSOperation对象添加到NSOperationQueue中。</span><br><span class="line"></span><br><span class="line">之后呢，系统就会自动将NSOperationQueue中的NSOperation取出来，在新线程中执行操作。</span><br><span class="line">下面我们来看看NSOperation和NSOperationQueue的基本使用。</span><br><span class="line">### NSOperation和NSOperationQueue的基本使用</span><br><span class="line">**1、创建任务**</span><br><span class="line">NSOperation是个抽象类，并不能封装任务。我们只有使用它的子类来封装任务。我们有三种方式来封装任务。</span><br><span class="line"></span><br><span class="line">1. 使用子类NSInvocationOperation</span><br><span class="line">2. 使用子类NSBlockOperation</span><br><span class="line">3. 定义继承自NSOperation的子类，通过实现内部相应的方法来封装任务。</span><br><span class="line"></span><br><span class="line">在不使用NSOperationQueue，单独使用NSOperation的情况下系统同步执行操作，下面我们看看以下任务的三种创建方式。</span><br><span class="line"></span><br><span class="line">**（1）、使用子类`- NSInvocationOperation：`**</span><br></pre></td></tr></table></figure><p>//1、创建NSInvocationOperation对象<br>NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];<br>//2、调用start方法开始执行操作<br>[op start];</p><ul><li>(void)run {<br>  NSLog(@”------%@”, [NSThread currentThread]);<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-05 14:29:58.483 NSOperation[15834:2384555] ------&lt;NSThread: 0x7fa3e2e05410&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br><span class="line">从中可以看到，在没有使用NSOperationQueue、单独使用NSInvocationOperation的情况下，NSInvocationOperation在主线程操作，并没有开启新线程。</span><br><span class="line"></span><br><span class="line">**（2）、使用子类`- NSBlockOperation`**</span><br></pre></td></tr></table></figure></li></ul><p>NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{<br>    //在主线程<br>    NSLog(@”-----%@”, [NSThread currentThread]);<br>}];</p><p>[op start];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-05 14:33:15.268 NSOperation[15884:2387780] ------&lt;NSThread: 0x7fb2196012c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br><span class="line">我们同样可以看到，在没有使用NSOperationQueue、单独使用NSBlockOperation的情况下，NSBlockOperation也是在主线程执行操作，并没有开启新线程。</span><br><span class="line"></span><br><span class="line">**但是，NSBlockOperation还提供了一个方法`addExecutionBlock：`，通过`addExecutionBlock：`就可以为NSBlockOperation添加额外的操作，这些额外的操作就会在其他线程并发执行。**</span><br></pre></td></tr></table></figure></p><ul><li><p>(void)blockOperation {<br>  NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{</p><pre><code>//在主线程NSLog(@&quot;1--------%@&quot;, [NSThread currentThread]);</code></pre><p>  }];</p><p>  //添加额外的任务(在子线程执行)<br>  [op addExecutionBlock:^{</p><pre><code>NSLog(@&quot;2--------%@&quot;, [NSThread currentThread]);</code></pre><p>  }];<br>  [op addExecutionBlock:^{</p><pre><code>NSLog(@&quot;3--------%@&quot;, [NSThread currentThread]);</code></pre><p>  }];<br>  [op addExecutionBlock:^{</p><pre><code>NSLog(@&quot;4--------%@&quot;, [NSThread currentThread]);</code></pre><p>  }];</p><p>  [op start];<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-05 14:36:59.353 NSOperation[15896:2390616] 1------&lt;NSThread: 0x7ff633f03be0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-05 14:36:59.354 NSOperation[15896:2390825] 2------&lt;NSThread: 0x7ff633e24600&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-05 14:36:59.354 NSOperation[15896:2390657] 3------&lt;NSThread: 0x7ff633c411e0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-05 14:36:59.354 NSOperation[15896:2390656] 4------&lt;NSThread: 0x7ff633f1d3e0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">可以看出，`blockOperationWithBlock:`方法中的操作是在主线程中执行的，而`addExecutionBlock：`方法中的操作是在其他线程中执行的。</span><br><span class="line"></span><br><span class="line">**（3）、定义继承自NSOperation的子类**</span><br><span class="line">先定义一个继承自NSOperation的子类，重写main方法</span><br></pre></td></tr></table></figure></li></ul><p>#import &lt;Foundation/Foundation.h&gt;<br>@interface YSCOperation : NSOperation</p><p>@end</p><p>#import “YSCOperation.h”<br>@implementation YSCOperation<br>/*<em> </em>需要执行的任务<br> */</p><ul><li>(void)main {<br> for (int i = 0; i &lt; 2; ++i) {<pre><code>NSLog(@&quot;1-------%@&quot;, [NSThread currentThread]);</code></pre> }<br>}<br>@end<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后使用的时候导入头文件`YSCOperation.h`</span><br></pre></td></tr></table></figure></li></ul><p>//创建YSCOperation<br>YSCOperation *op1 = [[YSCOperation alloc] init];</p><p>[op1 start];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-05 18:15:59.674 NSOperation[16566:2501606] 1-----&lt;NSThread: 0x7f8030d05150&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2016-09-05 18:15:59.675 NSOperation[16566:2501606] 1-----&lt;NSThread: 0x7f8030d05150&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br><span class="line">可以看出：在没有使用NSOperationQueue、单独使用自定义子类的情况下，是在主线程执行操作、并没有开启新线程。</span><br><span class="line">下边我们简单讲讲NSOperationQueue的创建</span><br><span class="line"></span><br><span class="line">**2、创建队列**</span><br><span class="line">和GCD中的并发队列、串行队列略有不同的是`NSOperationQueue`一共有两种队列：主队列、其他队列。其中其他队列包含了串行、并发功能。下面是主队列、其他队列的基本创建方法和特点。</span><br><span class="line"></span><br><span class="line">* 主队列</span><br><span class="line">    凡是添加到主队列中的任务(NSOperation)，都会放倒主线程中执行</span><br></pre></td></tr></table></figure></p><p>NSOperationQueue *queue = [NSOperationQueue mainQueue];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 其他队列(非主队列)</span><br><span class="line">    添加到这种队列中的任务(NSOperation)，就会自动放到子线程中执行；</span><br><span class="line">    同时包含了：串行、并发功能</span><br></pre></td></tr></table></figure></p><p>NSOperationQueue *queue = [[NSOperationQueue alloc] init];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**3、将任务加入到队列中** </span><br><span class="line">前边说了，NSOperation需要配合NSOperationQueue来实现多线程。那么我们需要将创建好的任务加入到队列中去。总共有两种方法：</span><br><span class="line"></span><br><span class="line">1. `- (void)addOperation:(NSOperation *)op;`</span><br><span class="line">    需要先创建任务，再将创建好的任务加入到创建好的队列中去</span><br></pre></td></tr></table></figure></p><ul><li><p>(void)addOperation:(NSOperation <em>)op {<br>  //1、创建队列<br>  NSOperationQueue </em>queue = [[NSOperationQueue alloc] init];<br>  //2、创建操作<br>  //创建NSInvocationOperation<br>  NSInvocationOperation <em>op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];<br>  //创建NSBlockOperation<br>  NSBlockOperation </em>op2 = [NSBlockOperation blockOperationWithBlock:^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;1-------%@&quot;, [NSThread currentThread]);}</code></pre><p>  }];</p><p>  //3、添加操作到队列中：addOperation:<br>  [queue addOperation:op1];<br>  [queue addOperation:op2];<br>}</p></li><li><p>(void)run {<br>  for (int i = 0; i &lt; 2; ++i) {</p><pre><code>    NSLog(@&quot;2-------%@&quot;, [NSThread currentThread]);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-05 17:06:00.241 NSOperationQueue[16201:2452281] 1-----&lt;NSThread: 0x7fe4824080e0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-05 17:06:00.241 NSOperationQueue[16201:2452175] 2-----&lt;NSThread: 0x7fe482404a50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-05 17:06:00.242 NSOperationQueue[16201:2452175] 2-----&lt;NSThread: 0x7fe482404a50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-05 17:06:00.241 NSOperationQueue[16201:2452281] 1-----&lt;NSThread: 0x7fe4824080e0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">可以看出：NSInvocationOperation和NSOperationQueue结合后能够开启新线程，进行并发执行NSBlockOperation和NSOperationQueue也能够开启新线程，进行并发执行。</span><br><span class="line"></span><br><span class="line">2.`- (void)addOperationWithBlock:(void (^)(void))block`;</span><br><span class="line">    无需先创建任务，在block中添加任务，直接将任务block加入到队列中。</span><br></pre></td></tr></table></figure></li><li><p>(void)addOperationWithBlockToQueue {<br>  //1、创建对联<br>  NSOperationQueue *queue = [[NSOperationQueue alloc] init];</p><p>  //2、添加操作到队列中：addOperationWithBlock:<br>  [queue addOperationWithBlock:^{</p><pre><code>for (int i = 0; i &lt; 2; ++i) {    NSLog(@&quot;-------%@&quot;, [NSThread currentThread]);}</code></pre><p>  }];<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出结果：</span><br><span class="line">2016-09-05 17:10:47.023 NSOperationQueue[16293:2457487] -----&lt;NSThread: 0x7ffa6bc0e1e0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-05 17:10:47.024 NSOperationQueue[16293:2457487] -----&lt;NSThread: 0x7ffa6bc0e1e0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">可以看出addOperationWithBlock:和NSOperationQueue能够开启新线程，进行并发执行。</span><br><span class="line"></span><br><span class="line">**4、控制串行执行和并发执行的关键**</span><br><span class="line">之前我们说过，NSOperationQueue创建的其他队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？</span><br><span class="line">这里有个关键参数`maxConcurrentOperationCount`，叫做最大并发数。</span><br><span class="line"></span><br><span class="line">最大并发数：`maxConcurrentOperationCount`</span><br><span class="line">`maxConcurrentOperationCount`默认情况下为-1，表示不进行限制，默认并发执行。</span><br><span class="line">当`maxConcurrentOperationCount`为1时，进行串行执行。</span><br><span class="line">当`maxConcurrentOperationCount`大于1时，进行并发执行，当然这个值不应该超过系统限制，急事自己设置一个很大的值，系统也会自动调整。</span><br></pre></td></tr></table></figure></li><li><p>(void)operationQueue {<br>  //创建队列<br>  NSOperationQueue *queue = [[NSOperationQueue alloc] init];<br>  //设置最大并发操作数<br>  //7queue.maxConcurrentOperationCount = 2;<br>  queue.maxConcurrentOperationCount = 1;//就变成了串行队列</p><p>  //添加操作<br>  [queue addOperationWithBlock:^{</p><pre><code>NSLog(@&quot;1------%@&quot;, [NSThread currentThread]);[NSThread sleepForTimeInterval:0,01];</code></pre><p>  }];<br>  [queue addOperationWithBlock:^{</p><pre><code>NSLog(@&quot;2------%@&quot;, [NSThread currentThread]);[NSThread sleepForTimeInterval:0,01];</code></pre><p>  }];<br>  [queue addOperationWithBlock:^{</p><pre><code>NSLog(@&quot;3------%@&quot;, [NSThread currentThread]);[NSThread sleepForTimeInterval:0,01];</code></pre><p>  }];<br>  [queue addOperationWithBlock:^{</p><pre><code>NSLog(@&quot;4------%@&quot;, [NSThread currentThread]);[NSThread sleepForTimeInterval:0,01];</code></pre><p>  }];<br>  [queue addOperationWithBlock:^{</p><pre><code>NSLog(@&quot;5------%@&quot;, [NSThread currentThread]);[NSThread sleepForTimeInterval:0,01];</code></pre><p>  }];<br>  [queue addOperationWithBlock:^{</p><pre><code>NSLog(@&quot;6------%@&quot;, [NSThread currentThread]);[NSThread sleepForTimeInterval:0,01];</code></pre><p>  }];<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;最大并发数为1输出结果：</span><br><span class="line">2016-09-05 17:21:54.124 NSOperationQueue[16320:2464630] 1-----&lt;NSThread: 0x7fc892d0b3a0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-05 17:21:54.136 NSOperationQueue[16320:2464631] 2-----&lt;NSThread: 0x7fc892c0a7b0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-05 17:21:54.148 NSOperationQueue[16320:2464630] 3-----&lt;NSThread: 0x7fc892d0b3a0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-05 17:21:54.160 NSOperationQueue[16320:2464631] 4-----&lt;NSThread: 0x7fc892c0a7b0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-05 17:21:54.171 NSOperationQueue[16320:2464631] 5-----&lt;NSThread: 0x7fc892c0a7b0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-05 17:21:54.184 NSOperationQueue[16320:2464630] 6-----&lt;NSThread: 0x7fc892d0b3a0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">最大并发数为2输出结果：</span><br><span class="line">2016-09-05 17:23:36.030 NSOperationQueue[16331:2466366] 2-----&lt;NSThread: 0x7fd729f0f270&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-05 17:23:36.030 NSOperationQueue[16331:2466491] 1-----&lt;NSThread: 0x7fd729f4e290&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2016-09-05 17:23:36.041 NSOperationQueue[16331:2466367] 3-----&lt;NSThread: 0x7fd729d214e0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2016-09-05 17:23:36.041 NSOperationQueue[16331:2466366] 4-----&lt;NSThread: 0x7fd729f0f270&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-05 17:23:36.053 NSOperationQueue[16331:2466366] 6-----&lt;NSThread: 0x7fd729f0f270&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2016-09-05 17:23:36.053 NSOperationQueue[16331:2466511] 5-----&lt;NSThread: 0x7fd729e056c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">**5、操作依赖**</span><br><span class="line">NSOperation和NSOperationQueue最吸引人的地方是它能添加操作之间的依赖关系。比如说有A、B两个操作，其中A执行完操作，B才能执行操作，那么就需要让B依赖于A。具体如下：</span><br></pre></td></tr></table></figure></li><li><p>(void)addDependency {<br>  NSOperationQueue <em>queue = [[NSOperationQueue alloc] init];<br>  NSBlockOperation </em>op1 = [NSBlockOperation blockOperationWithBlock:^{</p><pre><code>NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</code></pre><p>  }];</p><p>  NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{</p><pre><code>NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</code></pre><p>  }];<br>  [op2 addDepenDency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2</p><p>  [queue addOperation:op1];<br>  [queue addOperation:op2];<br>}<br><code>`</code></p><blockquote><p>输出结果：<br>2016-09-05 17:51:28.811 操作依赖[16423:2484866] 1—–&lt;NSThread: 0x7fc138e1e7c0&gt;{number = 2, name = (null)}<br>2016-09-05 17:51:28.812 操作依赖[16423:2484866] 2—–&lt;NSThread: 0x7fc138e1e7c0&gt;{number = 2, name = (null)}</p></blockquote></li></ul><p>可以看到，无论运行几次，其结果都是op1先执行，op2后执行。</p><p><strong>6、一些其他方法</strong></p><ul><li><code>- (void)cancel;</code>NSOperation提供的方法，可取消单个操作</li><li><code>- (void)cancelAllOperations;</code>NSOperationQueue提供的方法，可以取消队列的所有操作</li><li><code>- (void)setSuspended:(BOOL)b;</code>可设置任务的暂停和恢复，YES代表暂停队列，NO代表恢复队列</li><li><code>- (BOOL)isSuspended;</code>判断暂停状态</li></ul><blockquote><p>注意：</p></blockquote><pre><code>这里的暂停和取消并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。暂停和取消的区别在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</code></pre>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS深入学习 - RunLoop</title>
      <link href="/2017-10-9-runLoop/"/>
      <url>/2017-10-9-runLoop/</url>
      <content type="html"><![CDATA[<h2 id="RunLoop概念："><a href="#RunLoop概念：" class="headerlink" title="RunLoop概念："></a>RunLoop概念：</h2><p><a href="https://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="noopener">原文作者Blog地址</a>点这里。<br>一般来讲一个线程只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时执行任务但不退出，代码逻辑通常如下：runloop处理事件的代码逻辑模拟（Event Loop）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_messsage();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; while (message != quite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：<br>实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立即被唤醒</strong></p><p>1、OSX/iOS系统中提供了两个对象：NSRunLoop、CFRunLoopRef。<br><strong>CFRunLoopRef</strong>是在<strong>CoreFoundation</strong>框架内的，它提供了纯C函数的API，所有这些API都是线程安全的。<br><strong>NSRunLoop</strong>是基于<strong>CFRunLoopRef</strong>封装的，提供了面向对象的API，但是这些API不是线程安全的。</p><p><a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CFRunLoopRef源码</a></p><p>跨平台的<a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CoreFoundation版本源码</a></p><h2 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h2><p>iOS开发中可能遇到两个线程对象：<strong>pthread_t</strong>和<strong>NSThread</strong>。过去苹果有份<a href="https://www.fenestrated.net/mac/mirrors/Apple%20Technotes%20(As%20of%202002" target="_blank" rel="noopener">文档</a>/tn/tn2028.html)标明了<strong>NSThread</strong>只是<strong>pthread_t</strong>的封装，但是那份文档已经失效了，现在它们也有可能都是直接包装自最底层的<strong>mach thread</strong>。苹果没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是<strong>pthread_t</strong>和<strong>NSThread</strong>是一一对应的。比如，可以通过<strong>pthread_main_thread_np()</strong>或者<strong>[NSThread mainThread]</strong>来获取主线程；也可以通过<strong>pthread_self()</strong>或者<strong>[NSThread currentThread]</strong>来获取当前线程。<strong>CFRunLoop</strong>基于<strong>pthread</strong>来管理的。</p><p>苹果不允许直接创建RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//全局的Dictionary，key是pthread_t, value是CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">//访问loopsDic时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line">//获取一个pthread对应的Runloop</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        //第一次进入时，初始化全局Dic，并先为主线程创建一个RunLoop。</span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ///直接从Dictionary里获取</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread);</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        ///取不到，创建一个</span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        ///注册一个回调，当线程销毁时，顺便也销毁对应的RunLoop</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSPinLockUnlock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary里。线程刚创建时并没有RunLoop，如果你不主动获取，拿它一直不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁是发生在线程结束时。你只能在一个线程的内部获取其RunLoop（主线程除外）</p><h2 id="RunLoop对外的接口"><a href="#RunLoop对外的接口" class="headerlink" title="RunLoop对外的接口"></a>RunLoop对外的接口</h2><p>在CoreFoundation里面关于RunLoop有5个类：</p><ol><li>CFRunLoopRef </li><li>CFRunLoopModeRef </li><li>CFRunLoopSourceRef </li><li>CFRunLoopTimerRef </li><li>CFRunLoopObserverRef</li></ol><p>其中<strong>CFRunLoopModeRef</strong>类并没有对外暴露，只是通过<strong>CFRunLoopRef</strong>的接口进行了封装。他们的关系如下：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt=""></p><p>一个RunLoop包含若干个Mode，每个Mode又包含若干个<strong>Source/Timer/Observer</strong>。每次调用<strong>RunLoop</strong>的<strong>主函数</strong>时，只能指定其中一个<strong>Mode</strong>，这个<strong>Mode</strong>被称作<strong>CurrentMode</strong>。如果需要切换<strong>Mode</strong>，只能退出<strong>Loop</strong>，再重新指定一个<strong>Mode</strong>进入。这样做主要是为了分隔开不同组的<strong>Source/Timer/Observer</strong>，让其互不影响。</p><p><strong>CFRunLoopSourceRef</strong>是事件产生的地方。Source有两个版本：Source0和Source1.</p><ul><li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用<br>CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件。</li><li>Source1包含了一个mach_port和一个回调（函数指针），被用于通过内核和其它线程互相发送消息。这种Source能主动唤醒RunLoop的线程，其原理下面会讲到。</li></ul><p><strong>CFRunLoopTimerRef</strong>是基于时间的触发器， 它和NSTimer是toll_free bridged（对象桥接）的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒已执行那个回调。</p><p><strong>CFRunLoopObserverRef</strong>是观察者，每个Observer都包含了一个回调（函数指针），当RunLoop的状态发生变化的时候，观察者就能通过回调接受这个变化。可以观测的时间点有以下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry                = (1UL &lt;&lt; 0), //即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers         = (1UL &lt;&lt; 1), //即将处理Timer</span><br><span class="line">    kCFRunLoopBeforeSources        = (1UL &lt;&lt; 2), //即将处理Source</span><br><span class="line">    kCFRunLoopBeforeWaiting        = (1UL &lt;&lt; 5), //即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting         = (1UL &lt;&lt; 6), //刚冲休眠中唤醒</span><br><span class="line">    kCFRunLoopExit                 = (1UL &lt;&lt; 7), //即将退出Loop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<strong>Source/Timer/Observer</strong>被统称为mode item， 一个item可以被同时加入多个mode。但是一个item被重复加入同一个mode时是不会有效果的。如果一个mode中一个item都没有，则RunLoop会直接退出，不会进入循环。</p><h2 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a>RunLoop的Mode</h2><p>CFRunLoopMode和CFRunLoop的结构大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;                // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _source0;</span><br><span class="line">    CFMutableSetRef _source1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;  // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;     // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个概念叫<strong>“CommonModes”</strong>：一个Mode可以将自己标为<strong>“Common”</strong>属性（通过将其<strong>ModeName</strong>添加到RunLoop的<strong>“commonModes”</strong>中）。每当RunLoop的内容发生变化时，RunLoop都会自动将<strong>_commonModeItems</strong>里的<strong>Source/Timer/Observer</strong>同步到具有<strong>“Common”</strong>标记的所有Mode里。</p><p>应用场景举例：主线程的RunLoop里有两个预置的Mode：<strong>kCFRunLoopDefaultMode</strong>和<strong>UITrackingRunLoopMode</strong>。这两个Mode都已经被标记为<strong>“Common”</strong>属性。<strong>DefaultMode</strong>是APP平时所处的状态，<strong>TrackingRunLoopMode</strong>是追踪ScrollView滑动时的状态。当你创建一个Timer并追加到<strong>DefaultModel</strong>时，Timer会得到重复回调，但此时滑动一个TableView时，RunLoop会将mode切换为<strong>TrackingRunLoopMode</strong>，这时Timer就不会被调用，并且也不会影响滑动操作。</p><p>有时你需要一个Timer，在两个Mode中都能得到回调，一种办法就是将这个Timer分别加入这两个Mode。还有一种方式，就是将Timer加入到顶层的RunLoop的<strong>”commonModeItems“</strong>中。<strong>”commonModeItems“</strong>被RunLoop自动更新到所有具有<strong>“Common”</strong>属性的Mode里去。</p><ul><li>CFRunLoop对外暴露的管理Mode接口只有下面2个：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure><ul><li>Mode暴露的管理mode item 的接口有下面几个：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef r1, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef r1, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef r1, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef r1, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef r1, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef r1, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure><p>你只能通过modeName来操作内部的mode，当你传入一个新的mode name但RunLoop内部没有对应的mode时，RunLoop会自动帮你创建对应的CFRunLoopModeRef。对于一个RunLoop来说，其内部的mode只能增加不能删除。</p><p>苹果公开提供的 Mode 有两个：<strong>kCFRunLoopDefaultMode (NSDefaultRunLoopMode)</strong> 和 <strong>UITrackingRunLoopMode</strong>，你可以用这两个 Mode Name 来操作其对应的 Mode。</p><p>同时苹果还提供了一个操作 Common 标记的字符串：<strong>kCFRunLoopCommonModes (NSRunLoopCommonModes)</strong>，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p><h2 id="RunLoop的内部逻辑"><a href="#RunLoop的内部逻辑" class="headerlink" title="RunLoop的内部逻辑"></a>RunLoop的内部逻辑</h2><p>根据苹果<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">文档</a>里的说明，RunLoop内部逻辑大致如下：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png" alt=""><br>其内部代码整理如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">///用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), KCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///用指定的Mode启动， 允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopInMode(CFString modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    //首先根据modeName找到对应的mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    //如果mode里没有Source/Timer/Observer，直接返回</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">    </span><br><span class="line">    //1、通知Observer：RunLoop即将进入loop</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    //内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            //2、通知Observers：RunLoop即将触发Timer回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            //3、通知Observers：RunLoop即将触发Source0（非port）回调</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            //执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            //4、RunLoop触发Source0(非port)回调</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            //执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            //5、如果有Source1(基于port)处于ready状态，直接处理这个Source1然后跳转去处理消息</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatch, &amp;msg);</span><br><span class="line">                if (hasMsg) &#123;</span><br><span class="line">                    goto handle_msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //6、通知Observers： RunLoop的线程即将进入休眠(sleep)</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //7、调用mach_msg等待接受mach_port的消息。线程即将进入休眠，直接被下面某一个事件唤醒</span><br><span class="line">            //一个基于port的Source事件</span><br><span class="line">            //一个Timer到时间了</span><br><span class="line">            //RunLoop自身超时时间到了</span><br><span class="line">            //被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buff), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); //线程等待接收消息</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //8、通知Observers： RunLoop的线程刚刚被唤醒</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            //收到消息，处理消息</span><br><span class="line">            handle_msg:</span><br><span class="line">            </span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                //9.1 如果一个timer时间到了，触发这个timer的回调</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time());</span><br><span class="line">            &#125; else if（msg_is_dispatch）&#123;</span><br><span class="line">                //9.2 如果有dispatch到main_queue的block， 执行block</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //9.3 如果一个Source1(基于port)发出事件了，处理这个事件</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopSource1(runloop, current, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //执行加入到Loop的Block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                //进入loop时参数说处理完事件就返回</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                //超出传入参数标记的超市时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimeOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                //被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__kCFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //如果没超时， mode里没空，loop没有被停止， 那继续loop</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //10、通知Observers： RunLoop即将退出</span><br><span class="line">    __CFRunLoopDoObservers(r1, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际上RunLoop就是这样一个函数，其内部是一个do-while循环。当你调用CFRunLoopRun()时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p><h2 id="RunLoop的底层实现"><a href="#RunLoop的底层实现" class="headerlink" title="RunLoop的底层实现"></a>RunLoop的底层实现</h2><p>从上面代码可以看到，RunLoop的核心是基于mach port的，其进入休眠时调用的函数是mach_msg()。为了解释这个逻辑，下面稍微介绍一下OSX/iOS的系统架构。<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_3.png" alt=""><br>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包含用户能接触到的图形应用，例如：Spotlight、Aqua、SpringBoard等。<br>应用框架层即开发人员接触到的Cocoa等框架。<br>核心框架层包含各种核心框架、OpenGL等内容。<br>Darwin即操作系统的核心，包含系统内核、驱动、Shell等内容，这一层是开源的，其所有源码都可以在<a href="opensource.apple.com">opensource.apple.com</a>里找到。</p><p>我们在深入看一下Darwin这个核心的架构：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_4.png" alt=""></p><p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit（还包括一些上面没标注的内容），共同组成了XNU内核。</p><ul><li>XNU内核的内环被称作Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC（进程间通信）等非常少量的基础服务。</li><li>BSD层可以看作围绕Mach层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</li><li>IOKit层为设备驱动提供了一个面向对象（C++）的一个框架。</li></ul><p>Mach 本身提供的API非常有限，而且苹果也不鼓励使用Mach的API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在Mach中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为“对象”。和其他架构不同，Mach的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。“消息”是Mach中最基础的概念，消息在两个端口（port）之间传递，这就是Mach的IPC（进程通信）的核心。</p><p>Mach的消息定义是在&lt;mach/message.h&gt;头文件中，很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    mach_msg_header_t header;</span><br><span class="line">    mach_msg_body_t body;</span><br><span class="line">&#125; mach_msg_base_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    mach_msg_bits_t msgh_bits;</span><br><span class="line">    mach_msg_size_t msgh_size;</span><br><span class="line">    mach_port_t msgh_remote_port;</span><br><span class="line">    mach_port_t msgh_local_port;</span><br><span class="line">    mach_port_name_t msgh_voucher_port;</span><br><span class="line">    mach_msg_id_t msgh_id;</span><br><span class="line">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure><p>一条Mach消息实际上就是一个二进制数据包（BLOB），其头部定义了当前端口local_port和目标端口remote_port，发送和接收消息是通过同一个API进行的，其option标记了消息传递的方向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mach_msg_return_t mach_msg(</span><br><span class="line">    mach_msg_header_t *msg,</span><br><span class="line">    mach_msg_option_t *option,</span><br><span class="line">    mach_msg_size_t send_size,</span><br><span class="line">    mach_msg_size_t rcv_size,</span><br><span class="line">    mach_port_name_t rcv_name,</span><br><span class="line">    mach_msg_timeout_t timeout,</span><br><span class="line">    mach_port_name_t notify);</span><br></pre></td></tr></table></figure><p>为了实现消息的发送和接收，<strong>mach_msg()</strong> 函数实际上是调用一个Mach陷阱（trap），即函数 <strong>mach_msg_trap()</strong>,陷阱这个概念在Mach中等同于系统调用。当你在用户态调用<strong>mach_msg_trap()</strong>会触发陷阱机制，切换到内核态；内核态中内核实现的<strong>mach_msg()</strong>函数会完成实际的工作，如下图：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_5.png" alt=""><br>这些概念可以参考维基百科：<a href="http://en.wikipedia.org/wiki/System_call" target="_blank" rel="noopener">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing" target="_blank" rel="noopener">Trap_(computing)</a>)。</p><p><strong>RunLoop</strong> 的核心就是一个 <strong>mach_msg()</strong> (见上面代码的第7步)，<strong>RunLoop</strong>调用这个函数去接收消息， 如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个iOS的App，然后App静止时点击暂停，你会看到主线程调用栈是停留在mach_msg_trap() 这个地方。</p><p>关于具体的如何利用mach_port 发送消息，可以看看<a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="noopener">NSHipster这一篇文章</a>，或者<a href="http://segmentfault.com/a/1190000002400329" target="_blank" rel="noopener">这里</a>的中文翻译。</p><p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/" target="_blank" rel="noopener">Mac OS X 背后的故事（三） Mach 之父 Avie Tevanian</a>。</p><h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    common mode items = &#123;</span><br><span class="line">        //source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;</span><br><span class="line">            order = -1, &#123;</span><br><span class="line">                callout = _UIApplicationHandleEventQueue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRunLoopSource &#123;</span><br><span class="line">            order = -1, &#123;</span><br><span class="line">                callout = PurpleEventSignalCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRunLoopSource &#123;</span><br><span class="line">            order = 0, &#123;</span><br><span class="line">                callout = FBSSerialQueueRunLoopSourceHandler</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">            callout = PurpleEventCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;</span><br><span class="line">            port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // Observer</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = -2147483647, </span><br><span class="line">            activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = 0, </span><br><span class="line">            activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = 1999000, </span><br><span class="line">            activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = 2000000,</span><br><span class="line">            activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopObserver &#123;</span><br><span class="line">            order = 2147483647, </span><br><span class="line">            activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;</span><br><span class="line">            firing = No, </span><br><span class="line">            interval = 3.1536e+09, </span><br><span class="line">            tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;</span><br><span class="line">                    order = 0, &#123;</span><br><span class="line">                        callout = FBSSerialQueueRunLoopSourceHandler</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;</span><br><span class="line">                    activities = 0xa0, </span><br><span class="line">                    order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;</span><br><span class="line">                    order = -1, &#123;</span><br><span class="line">                        callout = PurpleEventSignalCallback</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;</span><br><span class="line">                    order = -1, &#123;</span><br><span class="line">                        callout = PurpleEventCallback</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到系统默认注册了5个Mode：</p><ol><li>kCFRunLoopDefaultMode: App的默认Mode，通常主线程是在这个Mode下运行的。</li><li>UITrackingRunLoopMode: 界面跟踪Mode，用于scrollView追踪触摸滑动，保证界面滑动时不受其他mode影响。</li><li>UIInitializationRunLoopMode: 在刚启动App时进入的第一个Mode，启动完成后就不在使用。</li><li>GSEventReceiveRunLoopMode: 接收系统事件的内部Mode，通常用不到</li><li>kCFRunLoopCommonModes: 这是一个占位的Mode，没有实际作用</li></ol><p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="noopener">这里</a>看到更多的苹果内部的Mode，但那些Mode在开发中就很难遇到了。</p><p>当RunLoop进行回调时，一般都是通过一个很长的函数调用出去（call out），当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈上看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ///1、通知Observer，即将进入runloop</span><br><span class="line">    ///此处有Observer会创建AutoreleasePool：_objc_autoreleasePoolPush();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry)</span><br><span class="line">    do &#123;</span><br><span class="line">        ///2、通知Observers：即将触发timer回调</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNTION__(kCFRunLoopBeforeTimers)</span><br><span class="line">        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        /// 4. 触发 Source0 (非基于port的) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        /// 5. 通知Observers，即将进入休眠</span><br><span class="line">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line"> </span><br><span class="line">        /// 6. sleep to wait msg.</span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">    </span><br><span class="line">        /// 7. 通知Observers，线程被唤醒</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line"> </span><br><span class="line">        /// 8.1 如果是被Timer唤醒的，回调Timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line"> </span><br><span class="line">        /// 8.2 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        /// 8.3 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line">    &#125; while (...);</span><br><span class="line">    /// 9. 通知Observers，即将退出RunLoop</span><br><span class="line">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>App启动后，苹果会在主线程RunLoop里注册两个 Observer，其回调都是<strong>_wrapRunLoopWithAutoreleasePoolHandler()</strong>。</p><p>第一个Observer监视的事件是Entry(即将进入RunLoop)，其回调内会调用<strong>_objc_autoreleasePoolPush()</strong> 创建自动释放池。其order是-2147483647，优先级最高，保证创建释放池发生在其它所有回调之前。</p><p>第二个Observer监视了两个事件：BeforeWaiting（准备进入休眠）时调用<strong>_objc_autoreleasePoolPop()</strong> 和 <strong>_objc_autoreleasePoolPush()</strong>释放旧的池并创建新池；Exit(即将退出Loop)时调用<strong>_objc_autoreleasePoolPop()</strong>来释放自动释放池。这个Observer的Order是2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建Pool了。</p><h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><p>苹果注册了一个Source1（基于mach port的）用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallBack()。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由IOKit.framework生成一个IOHIDEvent事件并由SpringBoard接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="noopener">这里</a>。<strong>SpringBoard</strong>只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种Event，随后用<strong>mach port</strong>转发给需要的App进程。随后苹果注册的那个Source1就会触发回调，并调用<strong>_UIApplicationHandleEventQueue()</strong>进行应用内部的分发。</p><p><strong>_UIApplicationHandleEventQueue()</strong>会把<strong>IOHIDEvent</strong>处理并包装成UIEvent进行处理或分发，其中包括识别<strong>UIGesture/处理屏幕旋转/发送给UIWindow</strong>等。通常事件比如 <strong>UIButton点击、touchesBegin/Move/End/Cancel</strong> 事件都是在这个回调中完成的。</p><h2 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h2><p>当上面的 <strong>_UIApplicationHandleEventQueue()</strong> 识别了一个手势时，其首先会调用Cancel将当前的 <strong>touchesBegin/Move/End</strong> 系列回调打断。随后系统将对应的 <strong>UIGestureRecognizer</strong> 标记为待处理。</p><p>苹果注册了一个<strong>Observer</strong>监测<strong>BeforeWaiting</strong>(Loop即将进入休眠)事件，这个<strong>Observer</strong>的回调函数是 <strong>_UIGestureRecognizerUpdateObserver()</strong>, 其内部会获取所有刚被标记为待处理的 <strong>GestureRecognizer</strong>，并执行<strong>GestureRecognizer</strong>的回调。</p><p>当有 <strong>UIGestureRecognizer</strong> 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h2 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h2><p>当在操作UI时，比如改变了Frame、更新了UIView/CALayer的层次时，或者手动调用了 <strong>UIView/CALayer</strong> 的 <strong>setNeedsLayout/setNeedsDisplay</strong> 方法后，这个 <strong>UIView/CALayer</strong> 方法后，这个 <strong>UIView/CALayer</strong> 就被标记为待处理，并提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit(即将退出Loop) 事件，回调去执行一个很长的函数：<strong>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</strong>。这个函数里会遍历所有待处理的 <strong>UIView/CALayer</strong> 以执行实际的绘制和调整，并更新UI界面。</p><p>这个函数内部的调用栈大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>NSTimer 其实就是CFRunLoopTimerRef，他们之间是 toll-free bridged的。一个NSTimer注册到RunLoop后，RunLoop会为其重复的时间点注册好事件。例如 10:00,10:10,10:20这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer有个属性叫做Tolerance(宽容度), 标记了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果10:10时我忙着玩手机错过了那个点的公交车，那我只能等10:20这一趟了。</p><p>CADisplayLink是一个和屏幕刷新率一致的定时器(但实际实现原理更复杂，和NSTimer并不一样，其内部实际是操作了一个Source)。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去 (和NSTimer相似)，造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook开源的AsyncDisplayLink就是为了解决界面卡顿的问题，其内部也用到了RunLoop。</p><h2 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h2><p>当调用 NSObject 的 performSelecter:afterDelay:后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop中。所以如果当前线程没有RunLoop，则这个方法会失效。</p><p>当调用performSelector:onThread:时，实际上其会创建一个Timer加到对应的线程去，同样的，如果对应线程没有RunLoop该方法也会失效。</p><h2 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h2><p>实际上RunLoop底层也会用到GCD的东西，（NSTimer是用了XNU内核的mk_timer, 而非GCD驱动的）GCD提供的某些接口也用到了RunLoop，例如dispatch_async()。</p><p>当调用dispatch_async(dispatch_get_main_queue(), block)时，libDispatch会向主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中取的这个block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个block。但这个逻辑仅限于dispatch到主线程，dispatch到其他线程仍然是由libDispatch处理的。</p><h2 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h2><p>iOS中，关于网络请求的接口自下至上有如下几层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork        -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection  -&gt;AFNetworking</span><br><span class="line">NSURLSession     -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure><ul><li><strong>CFSocket</strong> 是最底层的接口，只负责<strong>socket</strong>通信。</li><li><strong>CFNetwork</strong> 是基于<strong>CFSocket</strong>等接口的上层封装，<strong>ASIHttpRequest</strong>工作于这一层。</li><li><strong>NSURLConnection</strong> 是基于<strong>CFNetwork</strong>的更高层的封装，提供面向对象的接口，<strong>AFNetworking</strong>工作于这一层。</li><li><strong>NSURLSession</strong>是<strong>iOS7</strong>中新增的借口，表面上是和<strong>NSURLConnection</strong>并列的，但底层仍然用到了<strong>NSURLConnection</strong>的部分功能(比如<strong>com.apple.NEURLConnectionLoader</strong>线程)，<strong>AFNetworking2</strong>和<strong>Alamofire</strong>工作于这一层。</li></ul><p>下面主要介绍下NSURLConnnection的工作过程。</p><p>通常使用<strong>NSURLConnection</strong>时，你会传入一个<strong>Delegate</strong>，当调用了<strong>[connection start]</strong>后，这个<strong>Delegate</strong>就会不停收到事件回调。实际上，start这个函数的内部会获取<strong>CurrentRunLoop</strong>，然后在其中的<strong>DefaultMode</strong>添加了4个Source0(即需要手动触发的Source)。<strong>CFMultiplexerSource</strong>是负责各种Delegate回调的，<strong>CFHTTPCookieStorage</strong>是处理各种<strong>Cookie</strong>的。</p><p>当开始网络传输时，我们可以看到<strong>NSURLConnection</strong>创建了两个新线程：<strong>com.apple.NSURLConnectionLoader</strong>和<strong>com.apple.CFSocket.private</strong>。其中<strong>CFSocket</strong>线程是处理<strong>底层socket</strong>连接的。<strong>NSURLConnectionLoader</strong>这个线程内部会使用<strong>RunLoop</strong>来接收底层<strong>socket</strong>事件，并通过之前添加的<strong>Source0</strong>通知上层的<strong>Delegate</strong>。<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt=""><br><strong>NSURLConnectionLoader</strong>中的<strong>RunLoop</strong>通过一些基于<strong>mach port</strong>的<strong>Source</strong>接收来自底层<strong>CFSocket</strong>的通知。当收到通知后，其会在合适的时机向<strong>CFMultiplexerSource</strong>等<strong>Source0</strong>发送通知，同时唤醒<strong>Delegate</strong>线程的<strong>RunLoop</strong>来让其处理这些通知。<strong>CFMultiplexerSource</strong>会在<strong>Delegate</strong>线程的<strong>RunLoop</strong>对<strong>Delegate</strong>执行实际的回调。</p><h2 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h2><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p><strong>AFURLConnectionOperation</strong> 这个类是基于NSURLConnection构建的，其希望能在后台线程接收Delegate回调。为此AFNetworking单独创建了一个线程，并在这个线程中启动了一个RunLoop：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+(void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runloop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runloop addPort:[NSMachPort port] forMode: NSDefaultRunLoopMode];</span><br><span class="line">        [runloop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(NSThread *)networkingRequestThread &#123;</span><br><span class="line">    static NSThread *_networkingRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkingRequestThread = [[NSThread alloc] initWithTarget: self selector: @selector(networkRequestThreadEntryPoint:) object: nil];</span><br><span class="line">        [_networkingRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return _networkingRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop启动前内部必须要有一个<strong>Timer/Observer/Source</strong>，所以<strong>AFNetWorking</strong>在<strong>[runloop run]</strong>之前先创建了一个新的<strong>NSMachPort</strong>添加进去了。通常情况下，调用者需要持有这个<strong>NSMachPort(mach port)</strong>并在外部线程通过这个<strong>port</strong>发送消息到<strong>loop</strong>内；但此处添加<strong>port</strong>只是为了让<strong>RunLoop</strong>不至于退出，并没有用于实际的发送消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector: @selector(cancelConnection) onThread: [[self class] networkRequestThread] withObject: nil waitUntilDone: NO modes: [self.runloopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector: @selector(operationDidStart) onThread: [[self class] networkRequestThread] withObject: nil waitUntilDone: NO modes: [self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要这个后台线程执行任务时，<strong>AFNetworking</strong>通过调用<strong>[NSObject performSelector:onThread:…]</strong>将这个任务扔到了后台线程的<strong>RunLoop</strong>中。</p><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a href="https://github.com/facebookarchive/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a>是Facebook推出的用于保持界面流畅性的框架，其原理大致如下：</p><p>UI线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版、绘制、UI对象操作。</p><p>排版通常包括计算视图大小、计算文本高度、重新计算子视图的排版等操作。</p><p>绘制一般有文本绘制(例如CoreText)、图片绘制(例如预先解压)、元素绘制(Quartz)等操作。UI对象操作通常包括UIView/CALayer等UI对象的创建、设置属性和销毁。</p><p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果(例如TextView创建时可能需要提前计算出文本的大小)。ASDK所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟(例如视图的创建、属性的调整)。</p><p>为此，ASDK创建了一个名为ASDisplayNode的对象，并在内部封装了<strong>UIView/CALayer</strong>，它具有和<strong>UIView/CALayer</strong>相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过Node来操作其内部的<strong>UIView/CALayer</strong>，这样就可以将排版和绘制放入了后台线程。但无论怎么操作，这些属性总需要在某个时刻同步到主线程的<strong>UIView/CALayer</strong>去。</p><p>ASDK仿照<strong>QuartzCore/UIKit</strong>框架的模式，实现了一套类似的界面更新机制：即在主线程的RunLoop中添加一个Observer，监听了<strong>kCFRunLoopBeforeWaiting</strong>和<strong>kCFRunLoopExit</strong>事件，在收到回调时，遍历所有之前放入到队列的待处理的任务，然后一一执行。</p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>总得停下来思考思考</title>
      <link href="/2017-06-20-sum/"/>
      <url>/2017-06-20-sum/</url>
      <content type="html"><![CDATA[<h2 id="走的有点着急"><a href="#走的有点着急" class="headerlink" title="走的有点着急"></a>走的有点着急</h2><p><img src="https://github.com/xiongzf/img/blob/master/1.png?raw=true" alt=""></p><p>之前跟女朋友提起过，该总结一下毕业这么久以来的生活、工作，然后想想自己想要的到底是什么。才发现，以前赶路赶的有些着急了。</p><p>记得刚毕业那段时间，天天忙着找工作。因为喜欢编程，所以就在大学自学了java。毕业之后就一直在找it行业的工作，放弃了大学四年所学的专业。工作以后，每天来回奔波，看看技术相关的东西，业余时间打打篮球，没有别的。现在回想起来，自己的第一份正式工作，总归还是学到了不少东西。</p><p>可是，那个时候总想到大城市看看，觉得趁着自己年轻，是不是得去取取经，长长见识。然后第二年年初，自己一个人就傻头傻脑的跑到了上海。开始寻找自己的机会，谋求一份工作，以为一切都很简单，发现自己还是太简单了。总归，还是找到了一份工作，看着团队的组建，看着自己辛苦加班之后，亲手缔造的产品，总觉得这些都是值得的。</p><p>在魔都，看过夜里外滩，看过繁华的南京东路，才发现，其实这些和自己都毫不相干，第二天依旧要挤着地铁去公司，干着自己本分的工作，给自己充充电。要说，在这里学会了什么？唯一的就是，<strong>在你一无所有的时候，你除了努力还是得努力。</strong></p><h2 id="家，足以让自己安静"><a href="#家，足以让自己安静" class="headerlink" title="家，足以让自己安静"></a>家，足以让自己安静</h2><p><img src="https://github.com/xiongzf/img/blob/master/2.png?raw=true" alt=""></p><p>可是，却没有停下脚步好好地思考一番，自己适合做什么？得到了什么？还有什么要改进的？只是往前走，一昧的往前走。毕业的时候，还知道自己喜欢编程，然后就奔着这个方向走，到现在开始怀疑自己，如果不干这一行，还能干什么？记得那时候自己信心满满，觉得个人能力也还行，态度摆的也很低。社会却很现实，姿态摆的低虽然好，但是你能做什么？你能给公司带来什么？这些好像才是应该放在第一位的。</p><p>前几天回家待了几天，想着在家，远离喧嚣看看能不能静下心来好好地思考总结一下这段时间以来的不足和收获。还好，在家里远离网络，搬个凳子坐在院子里，吹吹风，和家里的老人聊聊天，静静的坐在那里，回顾一下之前快节奏的生活。还是有不少的收获，当自己快要迷失的时候，快没有能量的时候，回家歇一歇总会是一个不错的抉择。因为，总会有人给予关心与呵护，还有鼓励。所以，当我有什么想法的时候，首先会找我老姐吐槽一番，然后神清气爽。</p><h2 id="心平气和，接着走"><a href="#心平气和，接着走" class="headerlink" title="心平气和，接着走"></a>心平气和，接着走</h2><p><img src="https://github.com/xiongzf/img/blob/master/3.png?raw=true" alt=""></p><p>当自己想明白之后，又是动力满满，继续往前走。如今，重新回到上海，继续寻求新的开始，也许前面会坎坎坷坷比较难走，我也会心平气和，一步步迈过去。努力，肩扛着自己的责任，稳！</p><p>初心不改，继续锻造自己，当你能独当一面的时候，你会感激今天的不放弃。<strong>正当年少</strong>，你没有放弃的理由，改变现状，从容不迫。</p><p>感谢有家人和女票的陪伴，努力让自己更好，让你们更好。</p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS开发-渐变色踩的坑</title>
      <link href="/2017-06-08-secondBlog/"/>
      <url>/2017-06-08-secondBlog/</url>
      <content type="html"><![CDATA[<h2 id="这些坑踩的好疼"><a href="#这些坑踩的好疼" class="headerlink" title="这些坑踩的好疼"></a>这些坑踩的好疼</h2><p>个人的域名和blog搭建好了有一段时间，但是一直没有抽时间来写自己的blog。所以就抽了一点时间来记录一下，最近项目中遇到的一些坑。言归正传，最近的项目中，UI的设计图里出了一个渐变色的按钮，而且按钮点击的时候还需要一个透明度为0.3的黑色遮盖在渐变色上。然后，坑就开始了。</p><h2 id="第一个大坑（hitTest-withEvent-）"><a href="#第一个大坑（hitTest-withEvent-）" class="headerlink" title="第一个大坑（hitTest:withEvent:）"></a>第一个大坑（hitTest:withEvent:）</h2><p>我实现的大体思路是把渐变色绘制成image设置成按钮的背景图，然后，在<strong>button</strong>上添加一个<strong>view</strong>，没点击时，设置为透明色，点击时设置为alpha为0.3的黑色。因为点击<strong>button</strong>的事件会被<strong>view</strong>给拦截掉。所以，我就在自己创建的<strong>button</strong>里重写了如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 转换点击</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    // 1.判断当前控件能否接收事件</span><br><span class="line">    if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;</span><br><span class="line">    // 2.判断点在不在coverView上</span><br><span class="line">    if ([self.coverView pointInside:point withEvent:event]) return self;</span><br><span class="line">    // 3. 判断点在不在当前控件</span><br><span class="line">    if ([self pointInside:point withEvent:event] == NO) return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一个判断是如果当前的视图不能交互，被隐藏，或者alpha值＜0.01的话，此次Touch操作初始点所在的视图就返回为nil。</li><li>第二个判断是调用 <code>pointInside: withEvent:</code>方法，判断当前touch的点在不在添加到<strong>button</strong>上的<strong>view</strong>上，如果在上面，就返回<strong>button</strong>，让<strong>button</strong>来响应点击</li><li>第三个判断如果当前的点击不在覆盖的<strong>view</strong>上就返回nil.</li></ol><p>刚开始的时候，并没有测试出问题，然后一次偶然的点击触发了一系列的问题。刚开始只是在一个包含我的渐变色按钮的页面点击出现了奔溃，我们并没有往我的按钮那里去想，最后在其他界面点击也会出现奔溃，控制台打印出来的奔溃信息是<code>[UIWindow dealloced]</code>;<br>内心很奔溃，我们定位了很久，比较不同的版本，修改按钮为普通按钮，最后终于定位到了上述方法上。<br>触发这个问题的方式就是，触碰按钮的边缘，然后就会100%的复现这个问题，分析原因应该就是我的最后一个判断，处理得太唐突，当点不在<strong>button</strong>或者<strong>coverView</strong>上的时候，直接返回了<strong>nil</strong>。最后利用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGPoint subPoint = [subview convertPoint:point fromView:self];</span><br><span class="line">UIView *result = [subview hitTest:subPoint withEvent:event];</span><br></pre></td></tr></table></figure><p>处理了一下，就好了。但是最后由于怕有疏忽。所以放弃了这种方式处理。然后就有了第二种坑。</p><h2 id="第二个坑（CGColorSpaceRelease-colorSpace-）"><a href="#第二个坑（CGColorSpaceRelease-colorSpace-）" class="headerlink" title="第二个坑（CGColorSpaceRelease(colorSpace)）"></a>第二个坑（CGColorSpaceRelease(colorSpace)）</h2><p>在一个坑中，我最后放弃了在<strong>button</strong>上添加遮盖的处理方式，而是在点击<strong>button</strong>的时候，先是将渐变色绘制成图片，再将遮盖色绘制成图片，最后将两张图片绘制成一张图片，设置为<strong>button</strong>的背景色。核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark --渐变色</span><br><span class="line">+ (UIImage *)setGradualChangeColor:(NSArray *)colors</span><br><span class="line">                        startPoint:(CGPoint)startPoint</span><br><span class="line">                          endPoint:(CGPoint)endPoint</span><br><span class="line">                             frame:(CGRect)frame &#123;</span><br><span class="line">    NSMutableArray *cgColors = [NSMutableArray array];</span><br><span class="line">    for(UIColor *c in colors) &#123;</span><br><span class="line">        [cgColors addObject:(id)c.CGColor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(frame.size, YES, 1);</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    CGContextSaveGState(context);</span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorGetColorSpace([[colors lastObject] CGColor]);</span><br><span class="line">    CGGradientRef gradient = CGGradientCreateWithColors(colorSpace, (CFArrayRef)cgColors, NULL);</span><br><span class="line">    CGContextDrawLinearGradient(context, gradient, startPoint, endPoint, kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation);</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    CGGradientRelease(gradient);</span><br><span class="line">    CGContextRestoreGState(context);</span><br><span class="line">//    CGColorSpaceRelease(colorSpace);</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 设置带有阴影的渐变色</span><br><span class="line">- (UIImage *)createGraduallyCoverImage:(UIImage *)graduallyImage</span><br><span class="line">                            coverImage:(UIImage *)coverImage &#123;</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(self.size, NO, 2);</span><br><span class="line">    </span><br><span class="line">    [graduallyImage drawInRect:CGRectMake(0, 0, self.width, self.height)];</span><br><span class="line">    [coverImage drawInRect:CGRectMake(0, 0, self.width, self.height)];</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    </span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在有渐变色按钮的地方，有一定的概率触发崩溃，当时为了定位这个问题，就多点几次按钮，然后打断点，打开了<strong>僵尸对象</strong>调试，发现打印的奔溃信息是：<br><code>Assertion failed: (!state-&gt;is_singleton), function color_space_state_dealloc, file ColorSpaces/CGColorSpace.c, line 127.</code><br>然后就开始在网上找相关的问题，然后在一篇<a href="http://blog.csdn.net/zhchaoo/article/details/8962157" target="_blank" rel="noopener">blog</a>中找到了症结所在。具体的原因就是，第一个方法中我注释掉的那行代码。在苹果的api中指出，<strong>如果你需要维持这个实例，retain 它，如果没有 retain ，不要 release 它。</strong>所以由于我将其<strong>release</strong>掉了，就会有一定的几率触发奔溃。处理方式，就是注释掉<code>CGColorSpaceRelease(colorSpace);</code>这行代码，就OK了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于在以前的开发中很少手动处理<code>hitTest:withEvent:</code>，以及接触<strong>绘图</strong>这一块，所以在开发中出现了上述的问题，还好在互联网发达的今天，能够快速的在网上找到解决方案。对于不太懂<code>hitTest:withEvent:</code>的，可以看看<a href="http://blog.csdn.net/jiajiayouba/article/details/23447145" target="_blank" rel="noopener">这一篇文章</a>，作者写的很到位。当时还看了一篇讲解<code>convertPoint: fromView:</code>和<code>convertPoint: toView:</code>几个方法的作用的<a href="http://blog.csdn.net/xuhuan_wh/article/details/8486337" target="_blank" rel="noopener">文章</a>。也可以在网上找找其他的看看。<br>最后，谢谢这些文章的作者，正是有了他们的经验，才为我们这些后来的开发者，提供了宝贵的经验。</p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS开发-xib添加常用的KeyPath修改属性</title>
      <link href="/2017-03-18-keyPath/"/>
      <url>/2017-03-18-keyPath/</url>
      <content type="html"><![CDATA[<p>###步骤<br>1、点击xib，在xcode右半部分切换到第三项，如图：<img src="http://img.blog.csdn.net/20170315175948004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDAzMjQxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>2、点击+添加key，选择类型，设置值；常用的有<strong>clipsToBounds</strong>，<strong>layer.cornerRadius</strong>设置圆角等</p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS开发-没有数据时不显示tableView的分割线</title>
      <link href="/2017-03-16-tableView/"/>
      <url>/2017-03-16-tableView/</url>
      <content type="html"><![CDATA[<p>#iOS开发中关于没有数据时不显示tableView的分割线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//可以直接添加如下代码即可</span><br><span class="line">self.tableView.tableFooterView = [[UIView alloc]initWithFrame:CGRectZero];</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS开发--常见的退出键盘的几种方式</title>
      <link href="/2017-03-15-keyboard/"/>
      <url>/2017-03-15-keyboard/</url>
      <content type="html"><![CDATA[<p>原文来自于<a href="http://www.cnblogs.com/GarveyCalvin/p/4167759.html" target="_blank" rel="noopener">http://www.cnblogs.com/GarveyCalvin/p/4167759.html</a></p><p>1、第一种是最常见的resignFirstResponder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[textField resignFirstResponder];</span><br></pre></td></tr></table></figure><p>2、第二种，点击view结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.view endEditing:YES];</span><br></pre></td></tr></table></figure><p>3、利用window统一收起键盘（同第二种）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[UIApplication sharedApplication] keyWindow] endEditing:YES];</span><br></pre></td></tr></table></figure><p>4、源自：《iOS开发进阶》  —— 唐巧，直接发送resignFirstResponder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>用Jekyll搭建个人的Blog</title>
      <link href="/2017-03-02-first/"/>
      <url>/2017-03-02-first/</url>
      <content type="html"><![CDATA[<h2 id="第一篇blog-–纪念搭建我的个人Blog"><a href="#第一篇blog-–纪念搭建我的个人Blog" class="headerlink" title="第一篇blog –纪念搭建我的个人Blog"></a>第一篇blog –纪念搭建我的个人Blog</h2><p>前段时间，我的一个室友提起搭建个人的blog，当时没太在意。偶然间在浏览简书的时候，看见了<a href="http://www.jianshu.com/p/9a6bc31d329d" target="_blank" rel="noopener">一篇文章</a>勾起了我的兴趣。然后就开始鼓捣起来，期间也遇到一些坑。现在开始进入正题：</p><h2 id="第一步先搭建本地Jekyll"><a href="#第一步先搭建本地Jekyll" class="headerlink" title="第一步先搭建本地Jekyll"></a>第一步先搭建本地Jekyll</h2><p>Jekyll是什么？上文给的链接中讲得很清楚，是一个生成静态Blog的简易工具，支持<strong>markdown</strong>语法，支持自定义样式等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、先安装rubyGems：</span><br><span class="line">//因为之前安装的rubyGems是taobao，由于原作者不维护了，所以就换了一个ruby-china(如果已经是了，先更新一下)</span><br><span class="line"></span><br><span class="line">$ gem sources --add https://gems.ruby-china.org/ --remove https://ruby.taobao.org /</span><br><span class="line">$ gem sources -l</span><br><span class="line">https://gems.ruby-china.org</span><br><span class="line"></span><br><span class="line">// 确保只有 gems.ruby-china.org</span><br><span class="line"></span><br><span class="line">2、使用gem安装Jekyll </span><br><span class="line">//由于用的是mac，所以直接打开终端输入下面指令</span><br><span class="line"></span><br><span class="line"> gem install jekyll</span><br></pre></td></tr></table></figure><p>但是提示安装jekyll的一系列依赖工具，所以又挨个安装了jekyll的依赖，但是在安装中出现类似的错误<strong><em>/usr/bin 的“Operation not permitted”</em></strong>，所以就在网上找到了<a href="http://www.jianshu.com/p/22b89f19afd6" target="_blank" rel="noopener">解决办法</a>。按照文章里的操作，顺利解决。接着来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3、使用Jekyll创建你的博客站点</span><br><span class="line">jekyll new blog  #创建你的站点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、开启Jekyll服务</span><br><span class="line">//进入blog目录,记得一定要进入创建的目录，否则服务无法开启</span><br><span class="line">cd blog         </span><br><span class="line">jekyll serve      #启动你的http服务</span><br></pre></td></tr></table></figure><p> 因为Jekyll默认的端口号是4000，所以打开浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>就可以访问自己的blog了。<br> 关于jekyll其他一些命令的用法上文中也有我就直接copy了一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">再次感谢上文的作者们</span><br><span class="line">$ jekyll build</span><br><span class="line"># =&gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中。</span><br><span class="line"></span><br><span class="line">$ jekyll build --destination &lt;destination&gt;</span><br><span class="line"># =&gt; 当前文件夹中的内容将会生成到目标文件夹&lt;destination&gt;中。</span><br><span class="line"></span><br><span class="line">$ jekyll build --source &lt;source&gt; --destination &lt;destination&gt;</span><br><span class="line"># =&gt; 指定源文件夹&lt;source&gt;中的内容将会生成到目标文件夹&lt;destination&gt;中。</span><br><span class="line"></span><br><span class="line">$ jekyll build --watch</span><br><span class="line"># =&gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中，</span><br><span class="line">#    查看改变，并且自动再生成。</span><br><span class="line"></span><br><span class="line">$ jekyll serve</span><br><span class="line"># =&gt; 一个开发服务器将会运行在 http://localhost:4000/</span><br><span class="line"># Auto-regeneration（自动再生成文件）: 开启。使用 `--no-watch` 来关闭。</span><br><span class="line"></span><br><span class="line">$ jekyll serve --detach</span><br><span class="line"># =&gt; 功能和`jekyll serve`命令相同，但是会脱离终端在后台运行。</span><br><span class="line">#    如果你想关闭服务器，可以使用`kill -9 1234`命令，&quot;1234&quot; 是进程号（PID）。</span><br><span class="line">#    如果你找不到进程号，那么就用`ps aux | grep jekyll`命令来查看，然后关闭服务器。[更多](http://unixhelp.ed.ac.uk/shell/jobz5.html).</span><br></pre></td></tr></table></figure><p>让我们再来看看Jekyll的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml              (配置文件)</span><br><span class="line">├── _drafts                  (drafts（草稿）是未发布的文章)</span><br><span class="line">|   ├── begin-with-the-crazy-ideas.textile</span><br><span class="line">|   └── on-simplicity-in-technology.markdown</span><br><span class="line">├── _includes             (加载这些包含部分到你的布局)</span><br><span class="line">|   ├── footer.html</span><br><span class="line">|   └── header.html</span><br><span class="line">├── _layouts                 (包裹在文章外部的模板)</span><br><span class="line">|   ├── default.html</span><br><span class="line">|   └── post.html</span><br><span class="line">├── _posts                   (这里都是存放文章)</span><br><span class="line">|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile</span><br><span class="line">|   └── 2009-04-26-barcamp-boston-4-roundup.textile</span><br><span class="line">├── _site                 (生成的页面都会生成在这个目录下)</span><br><span class="line">├── .jekyll-metadata      (该文件帮助 Jekyll 跟踪哪些文件从上次建立站点开始到现在没有被修改，哪些文件需要在下一次站点建立时重新生成。该文件不会被包含在生成的站点中。)</span><br><span class="line">└── index.html            (网站的index)</span><br></pre></td></tr></table></figure><h2 id="Jekyll的主题"><a href="#Jekyll的主题" class="headerlink" title="Jekyll的主题"></a>Jekyll的主题</h2><p>既然自己的blog搭建好了，当然要更好看一些。你可以自己写HTML5+CSS来定制自己的Jekyll主题，也可以在求助万能的网站，来寻找各种<a href="https://jekyllthemes.io/" target="_blank" rel="noopener">主题</a>。</p><h2 id="使用-Github-Pages-的服务"><a href="#使用-Github-Pages-的服务" class="headerlink" title="使用 Github Pages 的服务"></a>使用 Github Pages 的服务</h2><p>1、创建我们的仓库<br>把username替换成自己的名字<br><img src="http://upload-images.jianshu.io/upload_images/1194012-1609f73ca0242750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>2、设置我们的仓库<br><img src="https://github.com/xiongzf/img/blob/master/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2017-05-02T14-14-48.287Z.png?raw=true" alt="火狐截图_2017-05-02T14-14-48.287Z"><br>3、部署我们的blog<br>我们先把刚刚新建的仓库git clone到本地，然后cd 到仓库的目录下，执行jekyll serve -B </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//克隆下来到本地的git文件夹</span><br><span class="line">cd username.github.com</span><br><span class="line">jekyll serve -B</span><br></pre></td></tr></table></figure><p>注意，启动前确保其他目录下没有jekyll服务，可以 ps aux|grep jekyll 查看进程,有的话,用kill -9 进程号 杀掉其他进程。<br>现在我们打开<a href="">http://localhost:4000</a>,即可看见我们在Github上创建的主页，理论上和<a href="">https://username.com/username.github.io/</a> 访问的应该是一模一样的。<br>接着我们把我们自己做好的blog目录整个都拷贝到这个仓库文件夹中(<strong><em>如果是自己下载的主题：</em></strong>直接将下载的主题文件拷贝替换掉原blog文件下的所有文件，启动一下服务，即可。)，当然，这个仓库之前的文件可以删除了，只留下README即可。把整个文件都push到github上去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all                          #添加到暂存区 </span><br><span class="line">git commit -m &quot;提交jekyll默认页面&quot;       #提交到本地仓库</span><br><span class="line">git push origin master                 #线上的站点是部署在master下面的</span><br></pre></td></tr></table></figure><p>注意，在提交前，请确保_config.yml文件里面下面是这样配置的，因为这个是Github Pages的规定，如果选择了其他的模式，会立即收到编译警告的邮件提醒的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">highlighter: rouge</span><br><span class="line">markdown: kramdown</span><br></pre></td></tr></table></figure><h2 id="申请个人域名"><a href="#申请个人域名" class="headerlink" title="申请个人域名"></a>申请个人域名</h2><p>我的个人域名是在<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>申请的。申请好了之后就是和自己的blog绑定（上面链接文章写的比较清楚）：<br>1、我们要绑定的话需要在username.github.com目录下增加一个CNAME文件。 在里面添加你的域名，假设为example.com，然后推送CNAME文件到远程仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add CNAME</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>在这里遇到比较大的一个坑，当时想了半天CNAME是什么格式的文件，在网上找了半天，也没找到答案。最后才发现自己想错了，直接在<code>终端</code>进入从git上克隆下来的文件夹，然后在终端输入指令<br><code>vim CNAME</code><br>输入自己的域名，保存退出，提交就行了。<br>2、到域名服务商增加你的CNAME记录。 添加两条记录，@和www的主机记录，记录类型为CNAME类型，CNAME表示别名记录，该记录可以将多个名字映射到同一台计算机。 记录值请写username.github.io.,值得注意的是io<br>后面还有一个圆点，切记。<br><img src="http://upload-images.jianshu.io/upload_images/1194012-888c87d7134d7ff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>添加@和www的记录的时候出现了冲突，我直接把冲突给删除了。上文链接文章中也有相关介绍。</p><h2 id="申请”小绿锁”HTTPS"><a href="#申请”小绿锁”HTTPS" class="headerlink" title="申请”小绿锁”HTTPS"></a>申请”小绿锁”HTTPS</h2><p>在这一块我也遇见很多坑，最后看了<a href="https://zhuanlan.zhihu.com/p/22667528" target="_blank" rel="noopener">这篇文章</a>，然后直接在<a href="https://www.cloudflare.com" target="_blank" rel="noopener">Cloudflare</a>上申请了https。<br>具体的可按照上面操作。</p><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>有两个规定先记下：</p><pre><code>文章必须新建在./_posts文件夹中文章名称必须是yyyy-mm-dd-xxxxx-xxx-xxx格式，后缀名可以是.markdown | .html | .textile （不过我还是推荐markdown形式，因为易学、通用、效率高）</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在最后，再次感谢上面几篇文章的作者，以后我的blog主题的作者，正是有了你们的付出，才让技术没有界限。<br>通过这次的实验，以及动手的操作，才发现未知并不可怕，只要你开动自己的脚步，总能窥探一二。希望以后的日子里，不仅仅忙碌，还能怀揣着酒和故事，带着诗意，去远方。</p>]]></content>
      
      <categories>
          
          <category> 搭建blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jekyll </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
