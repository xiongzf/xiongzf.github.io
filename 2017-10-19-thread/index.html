<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ios深入学习 - 多线程 | KNOWLEDGE IS POWER</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="多线程" />
  
  
  
  
  <meta name="description" content="多线程简单介绍进程和线程1、什么是进程进程是指在系统中正在运行的一个应用程序，每个进程之间是相互独立的，每个进程均运行在其专用且受保护的内存空间内。比如同时打开QQ、Xcode，系统会分别启动2个进程，通过“活动监视器”可以查看Mac系统中所开启的进程。2、什么是线程1个进程想要执行任务，必须得有线程(每一个进程至少要有一条线程即：主线程)，线程是进程的基本执行单元，一个进程(程序)的所有任务都">
<meta name="keywords" content="多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS深入学习 - 多线程">
<meta property="og:url" content="http://yoursite.com/2017-10-19-thread/index.html">
<meta property="og:site_name" content="KNOWLEDGE IS POWER">
<meta property="og:description" content="多线程简单介绍进程和线程1、什么是进程进程是指在系统中正在运行的一个应用程序，每个进程之间是相互独立的，每个进程均运行在其专用且受保护的内存空间内。比如同时打开QQ、Xcode，系统会分别启动2个进程，通过“活动监视器”可以查看Mac系统中所开启的进程。2、什么是线程1个进程想要执行任务，必须得有线程(每一个进程至少要有一条线程即：主线程)，线程是进程的基本执行单元，一个进程(程序)的所有任务都">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2017-10-19-thread/18.jpg">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241224432836121.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241225080809896.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241225242528638.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241226293143615.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241227387673566.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241235051118926.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241236350808178.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241238095028893.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241238382996357.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241255270965550.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241256038464378.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241302364867997.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241303131584567.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241303355028628.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241315433467454.png">
<meta property="og:image" content="http://images.cnitblog.com/i/450136/201406/241326487366534.png">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1877784-557cafe9005287bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1877784-60021d1165ba05d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1877784-7c39f9d019cea9ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1877784-18eab813719d579d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-07-24T08:05:09.358Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS深入学习 - 多线程">
<meta name="twitter:description" content="多线程简单介绍进程和线程1、什么是进程进程是指在系统中正在运行的一个应用程序，每个进程之间是相互独立的，每个进程均运行在其专用且受保护的内存空间内。比如同时打开QQ、Xcode，系统会分别启动2个进程，通过“活动监视器”可以查看Mac系统中所开启的进程。2、什么是线程1个进程想要执行任务，必须得有线程(每一个进程至少要有一条线程即：主线程)，线程是进程的基本执行单元，一个进程(程序)的所有任务都">
<meta name="twitter:image" content="http://yoursite.com/2017-10-19-thread/18.jpg">
  
    <link rel="alternate" href="/atom.xml" title="KNOWLEDGE IS POWER" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-2017-10-19-thread" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      iOS深入学习 - 多线程
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017-10-19-thread/" class="article-date">
	  <time datetime="2017-10-18T16:00:00.000Z" itemprop="datePublished">2017-10-19</time>
	</a>

      
    <a class="article-category-link" href="/categories/iOS-深入学习/">iOS 深入学习</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/2017-10-19-thread/18.jpg" alt=""></p>
<h2 id="多线程简单介绍"><a href="#多线程简单介绍" class="headerlink" title="多线程简单介绍"></a>多线程简单介绍</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p><strong>1、什么是进程</strong><br>进程是指在系统中正在运行的一个应用程序，每个进程之间是相互独立的，每个进程均运行在其专用且受保护的内存空间内。<br><img src="http://images.cnitblog.com/i/450136/201406/241224432836121.png" alt=""><br>比如同时打开QQ、Xcode，系统会分别启动2个进程，通过“活动监视器”可以查看Mac系统中所开启的进程。<br><strong>2、什么是线程</strong><br>1个进程想要执行任务，必须得有线程(每一个进程至少要有一条线程即：主线程)，线程是进程的基本执行单元，一个进程(程序)的所有任务都在线程中执行，比如使用音乐播放器播放音乐，使用下载器下载电影，都需要在线程中执行。<br><img src="http://images.cnitblog.com/i/450136/201406/241225080809896.png" alt=""><br><strong>3、线程的串行</strong><br>1个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个的按照顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。比如在1个线程中下载3个文件(分别是文件A、文件B、文件C)。<br><img src="http://images.cnitblog.com/i/450136/201406/241225242528638.png" alt=""></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><strong>1、什么是多线程</strong><br>1个进程中可以开启多条线程，每条线程可以并行(同时)执行不同的任务。进程-&gt;车间，线程-&gt;车间工人。多线程技术可以提高程序的执行效率。比如同时开启3条线程分别下载3个文件(分别是文件A、文件B、文件C)。<br><img src="http://images.cnitblog.com/i/450136/201406/241226293143615.png" alt=""><br><img src="http://images.cnitblog.com/i/450136/201406/241227387673566.png" alt=""><br><strong>2、多线程原理</strong><br>同一时间，CPU只能处理1条线程，只有1条线程在工作(执行)。多线程并发(同时)执行，其实是CPU快速的在多线程之间调度(切换)。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。<br>思考：如果线程非常非常多，会发生什么情况？<br>CPU会在N多个线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频率会降低(线程的执行效率降低)。<br><strong>3、多线程的优缺点</strong><br>多线程的优点：<br>    能适当提高程序的执行效率<br>    能适当的提高资源的利用率(CPU、内存利用率)</p>
<p>多线程的缺点：<br>    开启线程需要占用一定的内存空间(默认情况下，主线程占用1M，子线程占用512k)，如果开启大量的线程，会占用大量的内存空间，CPU在调度线程上的开销就越大。程序设计更加复杂：比如线程之间的通信、多线程的数据共享。<br><strong>4、多线程在iOS开发中的应用</strong><br>主线程：一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”。<br>主线程的主要作用：<strong>显示/刷新UI界面；处理UI事件(比如点击事件、滚动事件、拖拽事件等)</strong><br>主线程的使用注意：<strong>别将比较耗时的操作放到主线程中。</strong>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的体验<br><strong>5、代码示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">- (IBAction)btnClick;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//按钮的点击事件</span><br><span class="line">- (IBAction)btnClick&#123;</span><br><span class="line">    //1、获取当前线程</span><br><span class="line">    NSThread *current = [NSThread currentThread];</span><br><span class="line">    //2、使用for循环执行一些耗时操作</span><br><span class="line">    for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">        //3、输出线程</span><br><span class="line">        NSLog(@&quot;btnClick---%d---%@&quot;, i, current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>执行效果：<br><img src="http://images.cnitblog.com/i/450136/201406/241235051118926.png" alt=""><br>说明：当点击按钮的时候，textView点击没反应<br><img src="http://images.cnitblog.com/i/450136/201406/241236350808178.png" alt=""><br>执行分析：等待主线程串行执行。<br><img src="http://images.cnitblog.com/i/450136/201406/241238095028893.png" alt=""><br>开启子线程<br><img src="http://images.cnitblog.com/i/450136/201406/241238382996357.png" alt=""></p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h3><p><strong>资源共享</strong><br>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源。比如多个线程访问同一个对象、同一个变量、同一个文件。当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。<br>示例一：<br><img src="http://images.cnitblog.com/i/450136/201406/241255270965550.png" alt=""><br>示例二：<br><img src="http://images.cnitblog.com/i/450136/201406/241256038464378.png" alt=""><br>问题代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import &quot;ViewController.h&quot;</span><br><span class="line">@interface ViewController()</span><br><span class="line">//剩余票数</span><br><span class="line">@property(nonatomic, assign)int leftTicketsCount;</span><br><span class="line">@property(nonatomic, assign)NSThread *thread1;</span><br><span class="line">@property(nonatomic, assign)NSThread *thread2;</span><br><span class="line">@property(nonatomic, assign)NSThread *thread3;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //默认有20张票</span><br><span class="line">    self.leftTicketsCount = 10;</span><br><span class="line">    </span><br><span class="line">    //开启多个线程，模拟售票员售票</span><br><span class="line">    self.thread1 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread1.name = @&quot;售票员A&quot;;</span><br><span class="line">    </span><br><span class="line">    self.thread2 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread2.name = @&quot;售票员B&quot;;</span><br><span class="line">    </span><br><span class="line">    self.thread3 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread3.name = @&quot;售票员C&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sellTickets &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        //1、先检查票数</span><br><span class="line">        int count = self.leftTicketsCount;</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            //暂停一段时间</span><br><span class="line">            [NSThread sleepForTimeInterval: 0.002];</span><br><span class="line">            //2、票数-1</span><br><span class="line">            self.leftTicketsCount = count - 1;</span><br><span class="line">            //获取当前线程</span><br><span class="line">            NSThread *current = [NSThread currentThread];</span><br><span class="line">            NSLog(@&quot;%@--卖了一张票，还剩余%d张票&quot;, current, self.leftTicketsCount);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //退出线程</span><br><span class="line">            [NSThread exit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //开启多线程</span><br><span class="line">    [self.thread1 start];</span><br><span class="line">    [self.thread2 start];</span><br><span class="line">    [self.thread3 start];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>打印结果：<br><img src="http://images.cnitblog.com/i/450136/201406/241302364867997.png" alt=""></p>
<h3 id="安全隐患分析"><a href="#安全隐患分析" class="headerlink" title="安全隐患分析"></a>安全隐患分析</h3><p><img src="http://images.cnitblog.com/i/450136/201406/241303131584567.png" alt=""><br><img src="http://images.cnitblog.com/i/450136/201406/241303355028628.png" alt=""></p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>互斥锁使用格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(锁对象)&#123;</span><br><span class="line">    //需要锁定的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：锁定1份代码只用1把锁，用多把锁是无效的</strong><br>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">//剩余票数</span><br><span class="line">@property(nonatomic, assign)int leftTicketsCount;</span><br><span class="line">@property(nonatomic, strong)NSThread *thread1;</span><br><span class="line">@property(nonatomic, strong)NSThread *thread2;</span><br><span class="line">@property(nonatomic, strong)NSThread *thread3;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //默认有20张票</span><br><span class="line">    self.leftTicketsCount = 20;</span><br><span class="line">    </span><br><span class="line">    //开启多个线程，模拟售票员售票</span><br><span class="line">    self.thread1 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread1.name = @&quot;售票员A&quot;;</span><br><span class="line">    </span><br><span class="line">    self.thread2 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread2.name = @&quot;售票员B&quot;;</span><br><span class="line">    </span><br><span class="line">    self.thread3 = [[NSThread alloc] initWithTarget: self selector: @selector(sellTickets) object: nil];</span><br><span class="line">    self.thread3.name = @&quot;售票员C&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sellTickets &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        @synchronized(self) &#123;</span><br><span class="line">            //只能加一把锁</span><br><span class="line">            //1、先检查票数</span><br><span class="line">            int count = self.leftTicketsCount;</span><br><span class="line">            </span><br><span class="line">            if (count &gt; 0) &#123;</span><br><span class="line">                //暂停一段时间</span><br><span class="line">                [NSThread sleepForTimeInterval: 0.002];</span><br><span class="line">                //2、票数-1</span><br><span class="line">                self.leftTicketsCount = count - 1;</span><br><span class="line">                //获取当前线程</span><br><span class="line">                NSThread *current = [NSThread currentThread];</span><br><span class="line">                NSLog(@&quot;%@--卖了一张票，还剩余%d张票&quot;, current, self.leftTicketsCount); </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //退出线程</span><br><span class="line">                [NSThread exit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //开启多线程</span><br><span class="line">    [self.thread1 start];</span><br><span class="line">    [self.thread2 start];</span><br><span class="line">    [self.thread3 start];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>执行效果图：<br><img src="http://images.cnitblog.com/i/450136/201406/241315433467454.png" alt=""></p>
<pre><code>互斥锁的优缺点
优点：能有效防止因多线程抢夺资源造成的数据安全问题
缺点：需要消耗大量的CPU资源
互斥锁的使用前提：多条线程抢夺同一块资源
相关专业术语：线程同步，多条线程按照顺序的执行任务。互斥锁，就是使用了线程同步技术。
</code></pre><h3 id="原子和非原子属性"><a href="#原子和非原子属性" class="headerlink" title="原子和非原子属性"></a>原子和非原子属性</h3><p>OC在定义属性时有nonatomic和atomic两种选择<br>atomic：源自属性，为setter方法加锁（默认就是atomic）<br>nonatomic：非原子属性，不会为setter方法加锁</p>
<p>atomic加锁原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(assign, atomic) int age;</span><br><span class="line">- (void)setAge:(int)age &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        _age  = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原子和非原子属性的选择：<br>    nonatomic和atomic对比<br>    atomic：线程安全，需要消耗大量的资源<br>    nonatomic：非线程安全，适合内存小的移动设备</p>
<pre><code>iOS开发的建议：
所有的属性都声明为nonatomic
尽量避免多线程抢夺同一块资源
尽量加锁、资源抢夺的业务逻辑交给服务器处理，减小移动客户端的压力
</code></pre><h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p>线程间通信：在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信。<br>线程通信间的体现：1个线程传递数据给另1个线程；在1个线程中执行完特定任务后，转到另1个线程继续执行任务。<br>线程间通信常用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br></pre></td></tr></table></figure>
<p>线程间通信示例-图片下载<br><img src="http://images.cnitblog.com/i/450136/201406/241326487366534.png" alt=""><br>代码1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">@interface ViewController()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIImageView *iconView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //在子线程中调用download方法下载</span><br><span class="line">    [self performSelectorInBackground:@selector(download) withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)download &#123;</span><br><span class="line">    //1、根据URL下载图片</span><br><span class="line">    //从网络中下载图片</span><br><span class="line">    NSURL *urlstr = [NSURL URLWithString:@&quot;fdsf&quot;];</span><br><span class="line">    //把图片转换为二进制的数据</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:urlstr];//这一操作会比较耗时</span><br><span class="line">    //把数据转换成图片</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    //2、回到主线程中设置图片</span><br><span class="line">    [self performSelectorOnMainThread:@selector(settingImage:) withObject:image waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置显示图片</span><br><span class="line">- (void)settingImage:(UIImage *)image &#123;</span><br><span class="line">    self.iconView.image = image;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>代码2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;NSData.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIImageView *iconView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan: (NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //在子线程中调用download方法下载图片</span><br><span class="line">    [self performSelectorInBackground:@selector(download) withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)download &#123;</span><br><span class="line">    //1、根据url下载图片</span><br><span class="line">    //从网络下载图片</span><br><span class="line">    NSURL *urlstr = [NSURL URLWithString:@&quot;fdsf&quot;];</span><br><span class="line">    //把图片转换为二进制的数据</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:urlstr];//这一行操作比较耗时</span><br><span class="line">    //把数据转成图片</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    </span><br><span class="line">    //2、回到主线程设置图片</span><br><span class="line">    //第一种方式</span><br><span class="line">    //[self performSelectorOnMainThread:@selector(settingImage:) withObject:image waitUntilDone:NO];</span><br><span class="line">    //第二种方式</span><br><span class="line">    //    [self.iconView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:NO];</span><br><span class="line">    //第三种方式</span><br><span class="line">    [self.iconView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置显示图片</span><br><span class="line">//- (void)settingImage: (UIImage *)image &#123;</span><br><span class="line">//    self.iconView.image = image;</span><br><span class="line">//&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="多线程之-pthread、NSThread"><a href="#多线程之-pthread、NSThread" class="headerlink" title="多线程之[pthread、NSThread]"></a>多线程之[pthread、NSThread]</h2><h3 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h3><p>pthread简单介绍一下，pthread是一套通用的多线程API，可以在Unix/Linux/Windows等系统跨平台使用，使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，所以我们在iOS开发中几乎不使用pthread。</p>
<blockquote>
<p>引自<a href="https://baike.baidu.com/item/Pthread" target="_blank" rel="noopener">百度百科</a><br>POSIX线程(POSIX threads)，简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统(Unix、Linux、Mac OS X等)中，都使用Pthreads作为操作系统的线程。Windows操作系统也有其移植版pthreads-win32.</p>
<p>引自<a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">维基百科</a><br>POSIX线程(英语：POSIX Threads，常被缩写为Pthreads)是POSIX的线程标准，定义了创建和操纵线程的一套API。<br>实现POSIX线程标准的库常被称为Pthreads，一般基于Unix-like POSIX系统，如Linux、Solaris。但是Microsoft Windows上的实现也存在，例如直接使用Windows API实现的第三方库pthreads-w32；而利用windows的SFU/SUA子系统，则可以使用微软提供的一部分原生POSIX API。</p>
</blockquote>
<p><strong>pthread的使用方法</strong></p>
<ol>
<li>首先要包含头文件<code>#import &lt;pthread.h&gt;</code></li>
<li>其次要创建线程，并开启线程执行任务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建线程：定义一个pthread_t类变量</span><br><span class="line">pthread_t thread;</span><br><span class="line">//开启线程--执行任务</span><br><span class="line">pthread_create(&amp;thread, NULL, run, NULL);</span><br><span class="line"></span><br><span class="line">void *run(void *param)&#123;</span><br><span class="line">    //新线程调用方法，里边为需要执行的任务</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pthread_create(&amp;thread, NULL, run, NULL);</code>中各项参数含义：</p>
<ul>
<li>第一个参数&amp;thread是线程对象</li>
<li>第二个和第四个是线程属性，可赋值NULL</li>
<li>第三个run表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)</li>
</ul>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p> NSThread是苹果官方提供的，使用起来比pthread更加面向对象，简单易用，可以直接操作线程对象。不过也需要程序自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用NSThread。比如我们会经常调用<code>[NSThread currentThread]</code>来显示当前的进程信息。<br> 下边我们说说NSThread如何使用</p>
<p> <strong>1、创建、启动线程</strong></p>
<ul>
<li>先创建线程，再启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">[thread start]; //线程一启动，就会在线程thread中执行self的run方法。</span><br></pre></td></tr></table></figure>
<ul>
<li>创建线程后自动启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>
<ul>
<li>隐式创建并启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorInBackground:@selector(run) withObject:nil];</span><br></pre></td></tr></table></figure>
<p><strong>2、线程相关用法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//获得主线程</span><br><span class="line">+ (NSThread *)mainThread;</span><br><span class="line">//判断是否为主线程(对象方法)</span><br><span class="line">- (BOOL)isMainThread;</span><br><span class="line">//判断是否为主线程(类方法)</span><br><span class="line">+ (BOOL)isMainThread;</span><br><span class="line">//判断是否为主线程</span><br><span class="line">+ (BOOL)isMultiThreaded;</span><br><span class="line">//获取当前线程</span><br><span class="line">NSThread *current = [NSThread currentThread];</span><br><span class="line">//线程的名字-setter方法</span><br><span class="line">- (void)setName:(NSString *)n;</span><br><span class="line">//线程的名字-getter方法</span><br><span class="line">- (NSString *)name;</span><br><span class="line">//线程是否在执行</span><br><span class="line">- (BOOL)isExecuting;</span><br><span class="line">//线程是否被取消</span><br><span class="line">- (BOOL)isCancelled;</span><br><span class="line">//线程是否完成</span><br><span class="line">- (BOOL)isFinished;</span><br></pre></td></tr></table></figure>
<p><strong>3、线程状态控制方法</strong></p>
<ul>
<li>启动线程方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)start;</span><br><span class="line">//线程进入就绪状态-&gt;运行状态。当线程任务执行完毕，自动进入死亡状态</span><br></pre></td></tr></table></figure>
<ul>
<li>阻塞(暂停)线程方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br><span class="line">//线程进入阻塞状态</span><br></pre></td></tr></table></figure>
<ul>
<li>强制停止线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)exit;</span><br><span class="line">//线程进入死亡状态</span><br></pre></td></tr></table></figure>
<p><strong>4、线程的状态转换</strong></p>
<p>当我们新建一条线程<code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</code>,在内存中表现为：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1877784-557cafe9005287bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当调用<code>[thread start];</code>后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1877784-60021d1165ba05d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当然，可调度线程池中，会有其他的线程对象，如下图所示：（在这里我们只关心左边的线程对象）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1877784-7c39f9d019cea9ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下边我们来看看当前线程的状态转换：</p>
<ul>
<li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候调用了sleep方法/等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时/得到同步锁，则回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候，线程任务执行完毕/异常强制退出，则当前线程对象进入死亡状态。</li>
</ul>
<p>只看文字可能不太好理解，具体当前线程对象的状态变化如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1877784-18eab813719d579d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="GCD简介"><a href="#GCD简介" class="headerlink" title="GCD简介"></a>GCD简介</h3><p>什么是GCD呢？我们先来看看百度百科的解释简单了解下概念</p>
<blockquote>
<p>引自<a href="https://baike.baidu.com/item/GCD" target="_blank" rel="noopener">百度百科</a><br>Grand Central Dispatch(GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的任务。在Mac OS X10.6雪豹中首次推出的，也可以在iOS4及以上版本使用</p>
</blockquote>
<p><strong>为什么要用GCD呢？</strong></p>
<p>因为GCD有很多好处啊，具体如下：</p>
<ul>
<li>GCD可用于多核的并行运算</li>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
<p>既然GCD有这么多的好处，那下面我们就来系统的学习一下GCD的使用方法。</p>
<h3 id="任务和队列"><a href="#任务和队列" class="headerlink" title="任务和队列"></a>任务和队列</h3><p>学习GCD之前，先来了解GCD中两个核心概念：任务和队列。<br><strong>任务：</strong>就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在GCD中是放在block中的。执行任务有两种方式：<strong>同步执行</strong>和<strong>异步执行</strong>。两者的主要区别是：是否具有开启新线程的能力。</p>
<ul>
<li>同步执行(sync)：只能在当前线程中执行任务，不具备开启新线程的能力。</li>
<li>异步执行(async)：可以在新的线程中执行任务，具备开启新线程的能力。</li>
</ul>
<p><strong>队列：</strong>这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO(先进先出)的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有两种队列：<strong>串行队列</strong>和<strong>并行队列</strong>。</p>
<ul>
<li><p>并行队列(Concurrent Dispatch Queue)：可以让多个任务并行（同时）执行（自动开启多个线程同时执行任务）。</p>
<blockquote>
<p>并行功能只有在异步（dispatch_async）函数下才有效</p>
</blockquote>
</li>
<li><p>串行队列（Serial Dispatch Queue）：让任务一个接一个的执行（一个任务执行完毕后，再执行下一个任务）</p>
</li>
</ul>
<h3 id="GCD的使用步骤"><a href="#GCD的使用步骤" class="headerlink" title="GCD的使用步骤"></a>GCD的使用步骤</h3><p>GCD的使用步骤其实很简单，只有两步。</p>
<ol>
<li>创建一个队列（串行队列或者并行队列）</li>
<li>将任务添加到队列中，然后系统就会根据任务类型执行任务（同步执行或者异步执行）</li>
</ol>
<p>下边来看看队列的创建方法和任务的创建方法</p>
<p><strong>1、队列的创建方法</strong></p>
<ul>
<li>可以使用<code>dispatch_queue_create</code>来创建对象，需要传入两个参数，第一个参数表示队列的唯一标识符，用于debug，可为空；第二个参数用来识别是串行队列还是并行队列。<code>DISPATCH_QUEUE_SERIAL</code>表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code>表示并行队列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//串行队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">//并行队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<ul>
<li>对于并行队列，还可以使用<code>dispatch_get_global_queue</code>来创建<strong>全局并行队列</strong>。GCD默认提供了全局的并行队列，需要传入两个参数。第一个参数表示队列优先级，一般用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>。第二个参数暂时没用，用0表示即可。</li>
</ul>
<p><strong>2、任务的创建方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同步执行任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);//这里放任何代码</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//异步执行任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);//这里放任何代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然使用GCD只需要两步，但是既然我们有两种队列，两种任务执行方式，那么我们就有了4种不同的组合方式。这四种不同的组合方式是：</p>
<blockquote>
<p>1、并行队列 + 同步执行<br>2、并行队列 + 异步执行<br>3、串行队列 + 同步执行<br>4、串行队列 + 异步执行</p>
</blockquote>
<p>实际上，我们还有一种特殊的队列是主队列，那样就有6种不同的组合方式了。</p>
<blockquote>
<p>5、主队列 + 同步执行<br>6、主队列 + 异步执行</p>
</blockquote>
<p>那么这几种不同组合方式各有什么区别呢？这里为了方便，先上结果，再来讲解。为图省事儿，直接查看表格结果。</p>
<pre><code>| | 并行队列 | 串行队列 | 主队列 |      
</code></pre><p>|————–|————–| ————–|————–|<br>|同步(sync)   | 没有开启新线程，串行执行任务 | 没有开启新线程，串行执行任务 | 没有开启新线程，串行执行任务|<br>|异步(async)  | 有开启新线程，并行执行任务   | 有开启新线程(1条)，串行执行任务 | 没有开启新线程，串行执行任务|</p>
<p>下边我们来分别看看那这几种组合方式的使用方法</p>
<h3 id="GCD的基本使用"><a href="#GCD的基本使用" class="headerlink" title="GCD的基本使用"></a>GCD的基本使用</h3><p>并行队列的两种使用方法：</p>
<p><strong>1、并行队列 + 同步执行</strong></p>
<ul>
<li>不会开启新线程，执行完一个任务，再执行下一个任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)syncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-03 19:22:27.577 GCD[11557:1897538] syncConcurrent—begin<br>2016-09-03 19:22:27.578 GCD[11557:1897538] 1——&lt;NSThread: 0x7f82a1d058b0&gt;{number = 1, name = main}<br>2016-09-03 19:22:27.578 GCD[11557:1897538] 1——&lt;NSThread: 0x7f82a1d058b0&gt;{number = 1, name = main}<br>2016-09-03 19:22:27.578 GCD[11557:1897538] 2——&lt;NSThread: 0x7f82a1d058b0&gt;{number = 1, name = main}<br>2016-09-03 19:22:27.579 GCD[11557:1897538] 2——&lt;NSThread: 0x7f82a1d058b0&gt;{number = 1, name = main}<br>2016-09-03 19:22:27.579 GCD[11557:1897538] 3——&lt;NSThread: 0x7f82a1d058b0&gt;{number = 1, name = main}<br>2016-09-03 19:22:27.579 GCD[11557:1897538] 3——&lt;NSThread: 0x7f82a1d058b0&gt;{number = 1, name = main}<br>2016-09-03 19:22:27.579 GCD[11557:1897538] syncConcurrent—end</p>
</blockquote>
<ul>
<li>从<strong>并行队列 + 同步执行</strong>中可以看到，所有任务都是在主线程中执行的。由于只有一个线程，所以任务只能一个一个的执行。</li>
<li>同时我们还可以看到，所有任务都在打印的<strong>syncConcurrent—begin</strong>和<strong>syncConcurrent—end</strong>之间，这说明任务是添加到队列中么马上执行的。</li>
</ul>
<p><strong>2、并行队列 + 异步执行</strong></p>
<ul>
<li>可同时开启多线程，任务交替完成</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)asyncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-03 19:27:31.503 GCD[11595:1901548] asyncConcurrent—begin<br>2016-09-03 19:27:31.504 GCD[11595:1901548] asyncConcurrent—end<br>2016-09-03 19:27:31.504 GCD[11595:1901626] 1——&lt;NSThread: 0x7f8309c22080&gt;{number = 2, name = (null)}<br>2016-09-03 19:27:31.504 GCD[11595:1901625] 2——&lt;NSThread: 0x7f8309f0b790&gt;{number = 4, name = (null)}<br>2016-09-03 19:27:31.504 GCD[11595:1901855] 3——&lt;NSThread: 0x7f8309e1a950&gt;{number = 3, name = (null)}<br>2016-09-03 19:27:31.504 GCD[11595:1901626] 1——&lt;NSThread: 0x7f8309c22080&gt;{number = 2, name = (null)}<br>2016-09-03 19:27:31.504 GCD[11595:1901625] 2——&lt;NSThread: 0x7f8309f0b790&gt;{number = 4, name = (null)}<br>2016-09-03 19:27:31.505 GCD[11595:1901855] 3——&lt;NSThread: 0x7f8309e1a950&gt;{number = 3, name = (null)}</p>
</blockquote>
<ul>
<li>在<strong>并行队列 + 异步执行</strong>中可以看出，除了主线程，又开启了3个线程，并且交替着同时执行。</li>
<li>另一方面可以看出，所有任务是在打印的<strong>asyncConcurrent—begin</strong> 和 <strong>asyncConcurrent—end</strong>之后才开始执行的。说明任务不是马上执行的，而是将所有任务添加到队列之后才开始异步执行的。</li>
</ul>
<p>接下来看看串行队列的执行方法。</p>
<p><strong>3、串行队列 + 同步执行</strong></p>
<ul>
<li>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)syncSerial&#123;</span><br><span class="line">    NSLog(@&quot;syncSerial----begin&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果为：<br>2016-09-03 19:29:00.066 GCD[11622:1903904] syncSerial—begin<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 1——&lt;NSThread: 0x7fa2e9f00980&gt;{number = 1, name = main}<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 1——&lt;NSThread: 0x7fa2e9f00980&gt;{number = 1, name = main}<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 2——&lt;NSThread: 0x7fa2e9f00980&gt;{number = 1, name = main}<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 2——&lt;NSThread: 0x7fa2e9f00980&gt;{number = 1, name = main}<br>2016-09-03 19:29:00.067 GCD[11622:1903904] 3——&lt;NSThread: 0x7fa2e9f00980&gt;{number = 1, name = main}<br>2016-09-03 19:29:00.068 GCD[11622:1903904] 3——&lt;NSThread: 0x7fa2e9f00980&gt;{number = 1, name = main}<br>2016-09-03 19:29:00.068 GCD[11622:1903904] syncSerial—end</p>
</blockquote>
<ul>
<li>在<strong>串行队列 + 同步执行</strong>可以看到，所有任务都是在主线程中执行的，并没有开启新的线程。而且由于串行队列，所以按顺序一个一个执行。</li>
<li>同时我们还可以看到，所有任务都在打印的<strong>syncSerial—begin</strong>和<strong>syncSerial—end</strong>之间，这说明任务是添加到队列中马上执行的。</li>
</ul>
<p><strong>4、串行队列 + 异步执行</strong></p>
<ul>
<li>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)asyncSerial&#123;</span><br><span class="line">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果为：<br>2016-09-03 19:30:08.363 GCD[11648:1905817] asyncSerial—begin<br>2016-09-03 19:30:08.364 GCD[11648:1905817] asyncSerial—end<br>2016-09-03 19:30:08.364 GCD[11648:1905895] 1——&lt;NSThread: 0x7fb548c0e390&gt;{number = 2, name = (null)}<br>2016-09-03 19:30:08.364 GCD[11648:1905895] 1——&lt;NSThread: 0x7fb548c0e390&gt;{number = 2, name = (null)}<br>2016-09-03 19:30:08.364 GCD[11648:1905895] 2——&lt;NSThread: 0x7fb548c0e390&gt;{number = 2, name = (null)}<br>2016-09-03 19:30:08.364 GCD[11648:1905895] 2——&lt;NSThread: 0x7fb548c0e390&gt;{number = 2, name = (null)}<br>2016-09-03 19:30:08.365 GCD[11648:1905895] 3——&lt;NSThread: 0x7fb548c0e390&gt;{number = 2, name = (null)}<br>2016-09-03 19:30:08.365 GCD[11648:1905895] 3——&lt;NSThread: 0x7fb548c0e390&gt;{number = 2, name = (null)}</p>
</blockquote>
<ul>
<li>在<strong>串行队列 + 异步执行</strong>可以看到，开启了一个新线程，但是任务还是串行，所以任务是一个一个执行的。</li>
<li>另一方面可以看出，所有任务是在打印的<strong>asyncSerial—begin</strong> 和 <strong>asyncSerial—end</strong>之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</li>
</ul>
<p>下面我们看看特殊的队列—<strong>主队列</strong></p>
<ul>
<li>主队列：GCD自带的一种特殊的<strong>串行队列</strong><blockquote>
<p>所有放在主队列中的任务，都会放到主线程中执行。<br>可使用<code>dispatch_get_main_queue()</code>获得主队列</p>
</blockquote>
</li>
</ul>
<p>我们再看看主队列的两种组合方式</p>
<p><strong>5、主队列 + 同步执行</strong></p>
<ul>
<li>互等卡住不可行（在主线程中调用）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)syncMain &#123;</span><br><span class="line">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class="line">    dispatch_queue_t = dispatch_get_main_queue();</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);   </span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果<br>2016-09-03 19:32:15.356 GCD[11670:1908306] syncMain—begin</p>
</blockquote>
<p>这时候，我们惊奇的发现，在主线程中使用<strong>主队列 + 同步执行</strong>，任务不再执行了，而且<strong>syncMain—end</strong>也没有打印。这是为什么呢？</p>
<p>这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主队列中，它就会立马执行。但是主线程现在在处理<strong>syncMain</strong>方法，所以任务需要等<strong>syncMain</strong>执行完才能执行。而<strong>syncMain</strong>执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个和第三个任务。</p>
<p>那么，现在的情况就是<strong>syncMain</strong>方法和第一个任务都在等对方执行完毕。这样大家互相等待。所以就卡住了，所以我们的任务执行不了，而且<strong>syncMain–end</strong>也没有打印。</p>
<p>如果不在主线程中调用，而在其他线程中调用会如何呢？</p>
<ul>
<li>不会开启新线程，执行完一个任务，再执行下一个任务(在其他线程中调用)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [self syncMain];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-03 19:32:45.496 GCD[11686:1909617] syncMain—begin<br>2016-09-03 19:32:45.497 GCD[11686:1909374] 1——&lt;NSThread: 0x7faef2f01600&gt;{number = 1, name = main}<br>2016-09-03 19:32:45.498 GCD[11686:1909374] 1——&lt;NSThread: 0x7faef2f01600&gt;{number = 1, name = main}<br>2016-09-03 19:32:45.498 GCD[11686:1909374] 2——&lt;NSThread: 0x7faef2f01600&gt;{number = 1, name = main}<br>2016-09-03 19:32:45.498 GCD[11686:1909374] 2——&lt;NSThread: 0x7faef2f01600&gt;{number = 1, name = main}<br>2016-09-03 19:32:45.499 GCD[11686:1909374] 3——&lt;NSThread: 0x7faef2f01600&gt;{number = 1, name = main}<br>2016-09-03 19:32:45.499 GCD[11686:1909374] 3——&lt;NSThread: 0x7faef2f01600&gt;{number = 1, name = main}<br>2016-09-03 19:32:45.499 GCD[11686:1909617] syncMain—end</p>
</blockquote>
<ul>
<li>在其他线程中使用<strong>主队列+同步执行</strong>可看到：所有的任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按照顺序一个一个执行。</li>
<li>同时我们还可以看到，所有任务都在打印的<strong>syncConcurrent—begin</strong>和<strong>syncConcurrent—end</strong>之间，这说明任务是添加到队列中马上执行的。</li>
</ul>
<p><strong>6、主队列 + 异步执行</strong></p>
<ul>
<li>只在主线程中执行任务，执行完一个任务，再执行下一个任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)asyncMain &#123;</span><br><span class="line">    NSLog(@&quot;asyncMain--begin&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);  </span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-03 19:33:54.995 GCD[11706:1911313] asyncMain—begin<br>2016-09-03 19:33:54.996 GCD[11706:1911313] asyncMain—end<br>2016-09-03 19:33:54.996 GCD[11706:1911313] 1——&lt;NSThread: 0x7fb623d015e0&gt;{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 1——&lt;NSThread: 0x7fb623d015e0&gt;{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 2——&lt;NSThread: 0x7fb623d015e0&gt;{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 2——&lt;NSThread: 0x7fb623d015e0&gt;{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 3——&lt;NSThread: 0x7fb623d015e0&gt;{number = 1, name = main}<br>2016-09-03 19:33:54.997 GCD[11706:1911313] 3——&lt;NSThread: 0x7fb623d015e0&gt;{number = 1, name = main}</p>
</blockquote>
<ul>
<li>我们发现所有任务都在主线程中，虽然异步执行，具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。</li>
<li>另一方面可以看出，所有任务是在打印的<strong>asyncMain—begin</strong>和<strong>asyncMain—end</strong>之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</li>
</ul>
<p>弄懂了难理解、绕来绕去的<strong>队列 + 任务</strong>之后，我们来看看一个简单的东西–GCD线程之间的通信</p>
<h3 id="GCD线程之间的通讯"><a href="#GCD线程之间的通讯" class="headerlink" title="GCD线程之间的通讯"></a>GCD线程之间的通讯</h3><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其它线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">        NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回到主线程</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;2-------%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-03 19:34:59.165 GCD[11728:1913039] 1——&lt;NSThread: 0x7f8319c06820&gt;{number = 2, name = (null)}<br>2016-09-03 19:34:59.166 GCD[11728:1913039] 1——&lt;NSThread: 0x7f8319c06820&gt;{number = 2, name = (null)}<br>2016-09-03 19:34:59.166 GCD[11728:1912961] 2——-&lt;NSThread: 0x7f8319e00560&gt;{number = 1, name = main}</p>
</blockquote>
<ul>
<li>可以看到在其他线程中先执行操作，执行完了之后回到主线程执行主线程的相应操作。</li>
</ul>
<h3 id="GCD其他方法"><a href="#GCD其他方法" class="headerlink" title="GCD其他方法"></a>GCD其他方法</h3><p><strong>1、GCD的栅栏方法 <code>dispatch_barrier_async</code></strong></p>
<ul>
<li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于<strong>栅栏</strong>一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到<code>dispatch_barrier_async</code>方法在两个操作组间形成栅栏。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)barrier</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;----1-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;----2-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;----barrier-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;----3-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;----4-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-03 19:35:51.271 GCD[11750:1914724] —-1—–&lt;NSThread: 0x7fb1826047b0&gt;{number = 2, name = (null)}<br>2016-09-03 19:35:51.272 GCD[11750:1914722] —-2—–&lt;NSThread: 0x7fb182423fd0&gt;{number = 3, name = (null)}<br>2016-09-03 19:35:51.272 GCD[11750:1914722] —-barrier—–&lt;NSThread: 0x7fb182423fd0&gt;{number = 3, name = (null)}<br>2016-09-03 19:35:51.273 GCD[11750:1914722] —-3—–&lt;NSThread: 0x7fb182423fd0&gt;{number = 3, name = (null)}<br>2016-09-03 19:35:51.273 GCD[11750:1914724] —-4—–&lt;NSThread: 0x7fb1826047b0&gt;{number = 2, name = (null)}</p>
</blockquote>
<ul>
<li>可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</li>
</ul>
<p><strong>2、GCD延时执行方法 dispatch_after</strong></p>
<ul>
<li>当我们需要延迟执行一段代码时，就需要用到GCD的<code>dispatch_after</code>方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    // 2秒后异步执行这里的代码...</span><br><span class="line">   NSLog(@&quot;run-----&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>3、GCD的一次性代码（只执行一次）<code>dispatch_once</code></strong></p>
<p>*我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了GCD的<code>dispatch_once</code>方法。使用<code>dispatch_once</code>函数能保证某段代码在程序运行过程中只执行1次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    // 只执行1次的代码(这里面默认是线程安全的)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>4、GCD的快速迭代方法 <code>dispatch_apply</code></strong></p>
<ul>
<li>通常我们会for循环遍历，但是GCD给我们提供了快速迭代的方法<code>dispatch_apply</code>，使我们可以同时遍历。<code>dispatch_apply</code>可以同时遍历多个数字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"></span><br><span class="line">dispatch_apply(6, queue, ^(size_t index) &#123;</span><br><span class="line">    NSLog(@&quot;%zd------%@&quot;,index, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-03 19:37:02.250 GCD[11764:1915764] 1——&lt;NSThread: 0x7fac9a7029e0&gt;{number = 1, name = main}<br>2016-09-03 19:37:02.250 GCD[11764:1915885] 0——&lt;NSThread: 0x7fac9a614bd0&gt;{number = 2, name = (null)}<br>2016-09-03 19:37:02.250 GCD[11764:1915886] 2——&lt;NSThread: 0x7fac9a542b20&gt;{number = 3, name = (null)}<br>2016-09-03 19:37:02.251 GCD[11764:1915764] 4——&lt;NSThread: 0x7fac9a7029e0&gt;{number = 1, name = main}<br>2016-09-03 19:37:02.250 GCD[11764:1915884] 3——&lt;NSThread: 0x7fac9a76ca10&gt;{number = 4, name = (null)}<br>2016-09-03 19:37:02.251 GCD[11764:1915885] 5——&lt;NSThread: 0x7fac9a614bd0&gt;{number = 2, name = (null)}</p>
</blockquote>
<p>从输出结果中前边的时间中可以看出，几乎是同时便利的。</p>
<p><strong>5、GCD的队列组 <code>dispatch_group</code></strong></p>
<p>*有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后再回到主线程执行操作。这时候我们可以用到GCD的队列组。</p>
<ol>
<li>我们可以先把任务放到队列中，然后将队列放入队列组中</li>
<li>调用队列组的<code>dispatch_group_notify</code>回到主线程执行操作。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group =  dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    // 执行1个耗时的异步操作</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    // 执行1个耗时的异步操作</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    // 等前面的异步操作都执行完毕后，回到主线程...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>6、GCD dispatch_semaphore 信号量</strong><br>在GCD中提供了一种信号机制，也可以解决资源抢占问题（和同步锁的机制并不一样）。</p>
<p>GCD中信号量是<code>dispatch_semaphore_t</code>类型，支持信号通知和信号等待。每当发送一个信号通知，则信号量+1，每当发送一个等待信号时信号量-1。如果信号量为0则信号会处于等待状态，直到信号量大于0开始执行。根据这个原理我们可以初始化一个信号量变量，默认信号量设为1，每当有线程进入“加锁代码”之后就调用信号等待命令（此时信号量为0）开始等待，此时其他线程无法加入，执行完毕之后发送信号通知（此时信号量为1），其他线程开始进入执行，如此就达到了线程同步的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    //设置等待超时时间（5秒）</span><br><span class="line">    dispatch_time_t timeOutCount = dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC);</span><br><span class="line">    </span><br><span class="line">    //设置等待超时时间(一直等下去)</span><br><span class="line">    //dispatch_time_t timeOutCount = DISPATCH_TIME_FOREVER;</span><br><span class="line">    </span><br><span class="line">    //初始化信号量,参数是信号量初始值</span><br><span class="line">    dispatch_semaphore_t semaphore= dispatch_semaphore_create(1);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(globalQueue, ^&#123;</span><br><span class="line">        if (dispatch_semaphore_wait(semaphore, timeOutCount) != 0) &#123;</span><br><span class="line">            //等待超时后处理</span><br><span class="line">            //show error alertView on main Thread or something else...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //&quot;加锁代码&quot;</span><br><span class="line">            //do something...</span><br><span class="line">            </span><br><span class="line">            dispatch_semaphore_signal(semaphore);//信号通知（信号量+1）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码中用到的三个重要函数的具体介绍：</p>
<ol>
<li><p><code>dispatch_semaphore_create()</code> 创建信号量。传入的参数为long型，且必须大于或者等于0，否则函数返回NULL。</p>
</li>
<li><p><code>dispatch_semaphore_wait()</code> 方法为信号等待。如果信号量值为0，那么这个函数就阻塞当前线程等待timeOutCount,如果等待期间信号量大于0，则开始执行“加锁代码”，同时会使信号量-1。这个方法的返回值是当成功时则返回0，超时失败时则返回非0值。</p>
</li>
<li><p><code>dispatch_semaphore_signal()</code> 方法会使信号量+1。返回值为long类型，当返回值为0时表示当前并没有线程等待其处理的信号量，其处理的信号量的值加1即可。当返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程（当线程有优先级时，唤醒优先级最高的线程，否则随机唤醒）。</p>
</li>
</ol>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><h3 id="NSOperation简介"><a href="#NSOperation简介" class="headerlink" title="NSOperation简介"></a>NSOperation简介</h3><p>NSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD更高一层的封装，但是比GCD更简单易用，代码可读性也高。<br>NSOperation需要配合NSOperationQueue来实现多线程。<strong>因为默认情况下，NSOperation单独使用时系统同步执行操作，并没有开辟新线程的能力，只有配合NSOperationQueue才能实现异步操作。</strong><br>因为NSOperation是基于GCD的，那么使用起来也和GCD差不多，其中，NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。NSOperation实现多线程的使用步骤分为三步：</p>
<ol>
<li>创建任务：现将需要执行的操作封装到一个NSOperation对象中。</li>
<li>创建队列：创建NSOperationQueue对象。</li>
<li>将任务加到队列中：然后将NSOperation对象添加到NSOperationQueue中。</li>
</ol>
<p>之后呢，系统就会自动将NSOperationQueue中的NSOperation取出来，在新线程中执行操作。<br>下面我们来看看NSOperation和NSOperationQueue的基本使用。</p>
<h3 id="NSOperation和NSOperationQueue的基本使用"><a href="#NSOperation和NSOperationQueue的基本使用" class="headerlink" title="NSOperation和NSOperationQueue的基本使用"></a>NSOperation和NSOperationQueue的基本使用</h3><p><strong>1、创建任务</strong><br>NSOperation是个抽象类，并不能封装任务。我们只有使用它的子类来封装任务。我们有三种方式来封装任务。</p>
<ol>
<li>使用子类NSInvocationOperation</li>
<li>使用子类NSBlockOperation</li>
<li>定义继承自NSOperation的子类，通过实现内部相应的方法来封装任务。</li>
</ol>
<p>在不使用NSOperationQueue，单独使用NSOperation的情况下系统同步执行操作，下面我们看看以下任务的三种创建方式。</p>
<p><strong>（1）、使用子类<code>- NSInvocationOperation：</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1、创建NSInvocationOperation对象</span><br><span class="line">NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">//2、调用start方法开始执行操作</span><br><span class="line">[op start];</span><br><span class="line"></span><br><span class="line">- (void)run &#123;</span><br><span class="line">    NSLog(@&quot;------%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-05 14:29:58.483 NSOperation[15834:2384555] ——&lt;NSThread: 0x7fa3e2e05410&gt;{number = 1, name = main}</p>
</blockquote>
<p>从中可以看到，在没有使用NSOperationQueue、单独使用NSInvocationOperation的情况下，NSInvocationOperation在主线程操作，并没有开启新线程。</p>
<p><strong>（2）、使用子类<code>- NSBlockOperation</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    //在主线程</span><br><span class="line">    NSLog(@&quot;-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-05 14:33:15.268 NSOperation[15884:2387780] ——&lt;NSThread: 0x7fb2196012c0&gt;{number = 1, name = main}</p>
</blockquote>
<p>我们同样可以看到，在没有使用NSOperationQueue、单独使用NSBlockOperation的情况下，NSBlockOperation也是在主线程执行操作，并没有开启新线程。</p>
<p><strong>但是，NSBlockOperation还提供了一个方法<code>addExecutionBlock：</code>，通过<code>addExecutionBlock：</code>就可以为NSBlockOperation添加额外的操作，这些额外的操作就会在其他线程并发执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)blockOperation &#123;</span><br><span class="line">    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        //在主线程</span><br><span class="line">        NSLog(@&quot;1--------%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //添加额外的任务(在子线程执行)</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2--------%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3--------%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;4--------%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-05 14:36:59.353 NSOperation[15896:2390616] 1——&lt;NSThread: 0x7ff633f03be0&gt;{number = 1, name = main}<br>2016-09-05 14:36:59.354 NSOperation[15896:2390825] 2——&lt;NSThread: 0x7ff633e24600&gt;{number = 2, name = (null)}<br>2016-09-05 14:36:59.354 NSOperation[15896:2390657] 3——&lt;NSThread: 0x7ff633c411e0&gt;{number = 3, name = (null)}<br>2016-09-05 14:36:59.354 NSOperation[15896:2390656] 4——&lt;NSThread: 0x7ff633f1d3e0&gt;{number = 4, name = (null)}</p>
</blockquote>
<p>可以看出，<code>blockOperationWithBlock:</code>方法中的操作是在主线程中执行的，而<code>addExecutionBlock：</code>方法中的操作是在其他线程中执行的。</p>
<p><strong>（3）、定义继承自NSOperation的子类</strong><br>先定义一个继承自NSOperation的子类，重写main方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface YSCOperation : NSOperation</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;YSCOperation.h&quot;</span><br><span class="line">@implementation YSCOperation</span><br><span class="line">/**</span><br><span class="line"> *需要执行的任务</span><br><span class="line"> */</span><br><span class="line"> - (void)main &#123;</span><br><span class="line">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">        NSLog(@&quot;1-------%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后使用的时候导入头文件<code>YSCOperation.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建YSCOperation</span><br><span class="line">YSCOperation *op1 = [[YSCOperation alloc] init];</span><br><span class="line"></span><br><span class="line">[op1 start];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-05 18:15:59.674 NSOperation[16566:2501606] 1—–&lt;NSThread: 0x7f8030d05150&gt;{number = 1, name = main}<br>2016-09-05 18:15:59.675 NSOperation[16566:2501606] 1—–&lt;NSThread: 0x7f8030d05150&gt;{number = 1, name = main}</p>
</blockquote>
<p>可以看出：在没有使用NSOperationQueue、单独使用自定义子类的情况下，是在主线程执行操作、并没有开启新线程。<br>下边我们简单讲讲NSOperationQueue的创建</p>
<p><strong>2、创建队列</strong><br>和GCD中的并发队列、串行队列略有不同的是<code>NSOperationQueue</code>一共有两种队列：主队列、其他队列。其中其他队列包含了串行、并发功能。下面是主队列、其他队列的基本创建方法和特点。</p>
<ul>
<li>主队列<br>  凡是添加到主队列中的任务(NSOperation)，都会放倒主线程中执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
<ul>
<li>其他队列(非主队列)<br>  添加到这种队列中的任务(NSOperation)，就会自动放到子线程中执行；<br>  同时包含了：串行、并发功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>
<p><strong>3、将任务加入到队列中</strong><br>前边说了，NSOperation需要配合NSOperationQueue来实现多线程。那么我们需要将创建好的任务加入到队列中去。总共有两种方法：</p>
<ol>
<li><code>- (void)addOperation:(NSOperation *)op;</code><br> 需要先创建任务，再将创建好的任务加入到创建好的队列中去</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperation:(NSOperation *)op &#123;</span><br><span class="line">    //1、创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    //2、创建操作</span><br><span class="line">    //创建NSInvocationOperation</span><br><span class="line">    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    //创建NSBlockOperation</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;1-------%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //3、添加操作到队列中：addOperation:</span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run &#123;</span><br><span class="line">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;2-------%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-05 17:06:00.241 NSOperationQueue[16201:2452281] 1—–&lt;NSThread: 0x7fe4824080e0&gt;{number = 3, name = (null)}<br>2016-09-05 17:06:00.241 NSOperationQueue[16201:2452175] 2—–&lt;NSThread: 0x7fe482404a50&gt;{number = 2, name = (null)}<br>2016-09-05 17:06:00.242 NSOperationQueue[16201:2452175] 2—–&lt;NSThread: 0x7fe482404a50&gt;{number = 2, name = (null)}<br>2016-09-05 17:06:00.241 NSOperationQueue[16201:2452281] 1—–&lt;NSThread: 0x7fe4824080e0&gt;{number = 3, name = (null)}</p>
</blockquote>
<p>可以看出：NSInvocationOperation和NSOperationQueue结合后能够开启新线程，进行并发执行NSBlockOperation和NSOperationQueue也能够开启新线程，进行并发执行。</p>
<p>2.<code>- (void)addOperationWithBlock:(void (^)(void))block</code>;<br>    无需先创建任务，在block中添加任务，直接将任务block加入到队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperationWithBlockToQueue &#123;</span><br><span class="line">    //1、创建对联</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    </span><br><span class="line">    //2、添加操作到队列中：addOperationWithBlock:</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;-------%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-05 17:10:47.023 NSOperationQueue[16293:2457487] —–&lt;NSThread: 0x7ffa6bc0e1e0&gt;{number = 2, name = (null)}<br>2016-09-05 17:10:47.024 NSOperationQueue[16293:2457487] —–&lt;NSThread: 0x7ffa6bc0e1e0&gt;{number = 2, name = (null)}</p>
</blockquote>
<p>可以看出addOperationWithBlock:和NSOperationQueue能够开启新线程，进行并发执行。</p>
<p><strong>4、控制串行执行和并发执行的关键</strong><br>之前我们说过，NSOperationQueue创建的其他队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？<br>这里有个关键参数<code>maxConcurrentOperationCount</code>，叫做最大并发数。</p>
<p>最大并发数：<code>maxConcurrentOperationCount</code><br><code>maxConcurrentOperationCount</code>默认情况下为-1，表示不进行限制，默认并发执行。<br>当<code>maxConcurrentOperationCount</code>为1时，进行串行执行。<br>当<code>maxConcurrentOperationCount</code>大于1时，进行并发执行，当然这个值不应该超过系统限制，即使自己设置一个很大的值，系统也会自动调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)operationQueue &#123;</span><br><span class="line">    //创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    //设置最大并发操作数</span><br><span class="line">    //queue.maxConcurrentOperationCount = 2;</span><br><span class="line">    queue.maxConcurrentOperationCount = 1;//就变成了串行队列</span><br><span class="line">    </span><br><span class="line">    //添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1------%@&quot;, [NSThread currentThread]);</span><br><span class="line">        [NSThread sleepForTimeInterval:0,01];</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2------%@&quot;, [NSThread currentThread]);</span><br><span class="line">        [NSThread sleepForTimeInterval:0,01];</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3------%@&quot;, [NSThread currentThread]);</span><br><span class="line">        [NSThread sleepForTimeInterval:0,01];</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;4------%@&quot;, [NSThread currentThread]);</span><br><span class="line">        [NSThread sleepForTimeInterval:0,01];</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;5------%@&quot;, [NSThread currentThread]);</span><br><span class="line">        [NSThread sleepForTimeInterval:0,01];</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;6------%@&quot;, [NSThread currentThread]);</span><br><span class="line">        [NSThread sleepForTimeInterval:0,01];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最大并发数为1输出结果：<br>2016-09-05 17:21:54.124 NSOperationQueue[16320:2464630] 1—–&lt;NSThread: 0x7fc892d0b3a0&gt;{number = 2, name = (null)}<br>2016-09-05 17:21:54.136 NSOperationQueue[16320:2464631] 2—–&lt;NSThread: 0x7fc892c0a7b0&gt;{number = 3, name = (null)}<br>2016-09-05 17:21:54.148 NSOperationQueue[16320:2464630] 3—–&lt;NSThread: 0x7fc892d0b3a0&gt;{number = 2, name = (null)}<br>2016-09-05 17:21:54.160 NSOperationQueue[16320:2464631] 4—–&lt;NSThread: 0x7fc892c0a7b0&gt;{number = 3, name = (null)}<br>2016-09-05 17:21:54.171 NSOperationQueue[16320:2464631] 5—–&lt;NSThread: 0x7fc892c0a7b0&gt;{number = 3, name = (null)}<br>2016-09-05 17:21:54.184 NSOperationQueue[16320:2464630] 6—–&lt;NSThread: 0x7fc892d0b3a0&gt;{number = 2, name = (null)}</p>
</blockquote>
<p>最大并发数为2输出结果：<br>2016-09-05 17:23:36.030 NSOperationQueue[16331:2466366] 2—–&lt;NSThread: 0x7fd729f0f270&gt;{number = 3, name = (null)}<br>2016-09-05 17:23:36.030 NSOperationQueue[16331:2466491] 1—–&lt;NSThread: 0x7fd729f4e290&gt;{number = 2, name = (null)}<br>2016-09-05 17:23:36.041 NSOperationQueue[16331:2466367] 3—–&lt;NSThread: 0x7fd729d214e0&gt;{number = 4, name = (null)}<br>2016-09-05 17:23:36.041 NSOperationQueue[16331:2466366] 4—–&lt;NSThread: 0x7fd729f0f270&gt;{number = 3, name = (null)}<br>2016-09-05 17:23:36.053 NSOperationQueue[16331:2466366] 6—–&lt;NSThread: 0x7fd729f0f270&gt;{number = 3, name = (null)}<br>2016-09-05 17:23:36.053 NSOperationQueue[16331:2466511] 5—–&lt;NSThread: 0x7fd729e056c0&gt;{number = 5, name = (null)}</p>
<p><strong>5、操作依赖</strong><br>NSOperation和NSOperationQueue最吸引人的地方是它能添加操作之间的依赖关系。比如说有A、B两个操作，其中A执行完操作，B才能执行操作，那么就需要让B依赖于A。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDependency &#123;</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op2 addDepenDency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2016-09-05 17:51:28.811 操作依赖[16423:2484866] 1—–&lt;NSThread: 0x7fc138e1e7c0&gt;{number = 2, name = (null)}<br>2016-09-05 17:51:28.812 操作依赖[16423:2484866] 2—–&lt;NSThread: 0x7fc138e1e7c0&gt;{number = 2, name = (null)}</p>
</blockquote>
<p>可以看到，无论运行几次，其结果都是op1先执行，op2后执行。</p>
<p><strong>6、一些其他方法</strong></p>
<ul>
<li><code>- (void)cancel;</code>NSOperation提供的方法，可取消单个操作</li>
<li><code>- (void)cancelAllOperations;</code>NSOperationQueue提供的方法，可以取消队列的所有操作</li>
<li><code>- (void)setSuspended:(BOOL)b;</code>可设置任务的暂停和恢复，YES代表暂停队列，NO代表恢复队列</li>
<li><code>- (BOOL)isSuspended;</code>判断暂停状态</li>
</ul>
<blockquote>
<p>注意：</p>
</blockquote>
<pre><code>这里的暂停和取消并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。
暂停和取消的区别在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。
</code></pre>
      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/xiongzf/img/master/WechatIMG7.jpeg',
  alipayImage: 'https://raw.githubusercontent.com/xiongzf/img/master/WechatIMG9.jpeg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>菜鸟先生</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2017-10-19-thread/" target="_blank" title="iOS深入学习 - 多线程">http://yoursite.com/2017-10-19-thread/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8zOTY2MC8xNjE4Nw==">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017-10-20-runtime/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          iOS深入学习 - Runtime
        
      </div>
    </a>
  
  
    <a href="/2017-10-9-runLoop/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">iOS深入学习 - RunLoop</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程简单介绍"><span class="nav-number">1.</span> <span class="nav-text">多线程简单介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程和线程"><span class="nav-number">1.1.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程"><span class="nav-number">1.2.</span> <span class="nav-text">多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全"><span class="nav-number">2.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程的安全隐患"><span class="nav-number">2.1.</span> <span class="nav-text">多线程的安全隐患</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全隐患分析"><span class="nav-number">2.2.</span> <span class="nav-text">安全隐患分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何解决"><span class="nav-number">2.3.</span> <span class="nav-text">如何解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子和非原子属性"><span class="nav-number">2.4.</span> <span class="nav-text">原子和非原子属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程间的通信"><span class="nav-number">3.</span> <span class="nav-text">线程间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单说明"><span class="nav-number">3.1.</span> <span class="nav-text">简单说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程之-pthread、NSThread"><span class="nav-number">4.</span> <span class="nav-text">多线程之[pthread、NSThread]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread"><span class="nav-number">4.1.</span> <span class="nav-text">pthread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSThread"><span class="nav-number">4.2.</span> <span class="nav-text">NSThread</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD"><span class="nav-number">5.</span> <span class="nav-text">GCD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD简介"><span class="nav-number">5.1.</span> <span class="nav-text">GCD简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务和队列"><span class="nav-number">5.2.</span> <span class="nav-text">任务和队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD的使用步骤"><span class="nav-number">5.3.</span> <span class="nav-text">GCD的使用步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD的基本使用"><span class="nav-number">5.4.</span> <span class="nav-text">GCD的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD线程之间的通讯"><span class="nav-number">5.5.</span> <span class="nav-text">GCD线程之间的通讯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD其他方法"><span class="nav-number">5.6.</span> <span class="nav-text">GCD其他方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperation"><span class="nav-number">6.</span> <span class="nav-text">NSOperation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSOperation简介"><span class="nav-number">6.1.</span> <span class="nav-text">NSOperation简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSOperation和NSOperationQueue的基本使用"><span class="nav-number">6.2.</span> <span class="nav-text">NSOperation和NSOperationQueue的基本使用</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2019 KNOWLEDGE IS POWER All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            KNOWLEDGE IS POWER
          </div>
          <div class="panel-body">
            Copyright © 2019 菜鸟先生 All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>